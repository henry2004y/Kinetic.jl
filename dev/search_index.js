var documenterSearchIndex = {"docs":
[{"location":"para_dist/#Distributed-computing","page":"Distributed","title":"Distributed computing","text":"","category":"section"},{"location":"para_dist/","page":"Distributed","title":"Distributed","text":"The distributed computation is built upon Julia's @distributed macro in the Distributed module.","category":"page"},{"location":"para_dist/","page":"Distributed","title":"Distributed","text":"using Distributed\n@distributed [reducer] for var = range\n    body\nend","category":"page"},{"location":"para_dist/","page":"Distributed","title":"Distributed","text":"It provides a MPI-type parallelization with a leaner code size. The specified range is partitioned and locally executed across all workers.  In case an optional reducer function is specified, @distributed performs local reductions on each worker with a final reduction on the calling process. Without a reducer function, @distributed will execute asynchronously, i.e. it spawns independent tasks on all available workers and returns immediately without waiting for completion.  To make it wait for completion, prefix the call with @sync like :","category":"page"},{"location":"para_dist/","page":"Distributed","title":"Distributed","text":"@sync @distributed for var = range\n    body\nend","category":"page"},{"location":"para_dist/","page":"Distributed","title":"Distributed","text":"In the following, we present an example to conduct distributed computing with the help Julia's SharedArrays module, which creates arrays shared by all the processors. More massive computing can be made with DistributedArrays. First, we consider a distributed computing.","category":"page"},{"location":"para_dist/","page":"Distributed","title":"Distributed","text":"using Distributed, SharedArrays\naddprocs(3)\n@everywhere using KitBase\n\nbegin\n    vars = Dict{Symbol,Any}()\n    vars[:matter] = \"gas\"\n    vars[:case] = \"sod\"\n    vars[:space] = \"1d0f0v\"\n    vars[:flux] = \"kfvs\"\n    vars[:collision] = \"bgk\"\n    vars[:nSpecies] = 1\n    vars[:interpOrder] = 1\n    vars[:limiter] = \"vanleer\"\n    vars[:boundary] = \"fix\"\n    vars[:cfl] = 0.5\n    vars[:maxTime] = 0.2\n    vars[:x0] = 0.0\n    vars[:x1] = 1.0\n    vars[:nx] = 2000\n    vars[:pMeshType] = \"uniform\"\n    vars[:nxg] = 0\n    vars[:knudsen] = 0.001\n    vars[:mach] = 0.0\n    vars[:prandtl] = 1.0\n    vars[:inK] = 0.0\n    vars[:omega] = 0.81\n    vars[:alphaRef] = 1.0\n    vars[:omegaRef] = 0.5\nend\n\nset = KitBase.set_setup(vars)\npSpace = KitBase.set_geometry(vars)\nvSpace = KitBase.set_velocity(vars)\ngas = KitBase.set_property(vars)\nib = KitBase.set_ib(vars, set, vSpace, gas)\nfolder = @__DIR__\nks = KitBase.SolverSet(set, pSpace, vSpace, gas, ib, folder)\n\ndt = ks.pSpace.dx[1] / (5.0 + KitBase.sound_speed(ks.ib.primL, ks.gas.γ))\nnt = floor(ks.set.maxTime / dt) |> Int\n\nwp = SharedArray{Float64}((ks.pSpace.nx, 3), init=A->(A=zeros(ks.pSpace.nx, 3)))\nfor i in 1:ks.pSpace.nx\n    if i <= ks.pSpace.nx ÷ 2\n        wp[i,:] .= ks.ib.wL\n    else\n        wp[i,:] .= ks.ib.wR\n    end\nend     \nfwp = SharedArray{Float64}((ks.pSpace.nx+1, 3), init=A->(A=zeros(ks.pSpace.nx+1, 3)))\n\n@time for iter = 1:nt÷3\n    @sync @distributed for i in 2:ks.pSpace.nx\n        flux = @view fwp[i,:]\n        KitBase.flux_gks!(\n            flux,\n            wp[i-1,:],\n            wp[i,:],\n            ks.gas.γ,\n            ks.gas.K,\n            ks.gas.μᵣ,\n            ks.gas.ω,\n            dt,\n            0.5 * ks.pSpace.dx[i-1],\n            0.5 * ks.pSpace.dx[i],\n        )\n    end\n    \n    @sync @distributed for i in 2:ks.pSpace.nx-1\n        for j in 1:3\n            wp[i,j] += (fwp[i,j] - fwp[i+1,j]) / ks.pSpace.dx[i]\n        end\n    end\nend","category":"page"},{"location":"para_dist/","page":"Distributed","title":"Distributed","text":"The benchmark result on a Intel NUC8i7BEH desktop is around 13.620491 seconds (2.26 M allocations: 101.219 MiB, 0.22% gc time). Then, we compare the efficiency with a serial execution.","category":"page"},{"location":"para_dist/","page":"Distributed","title":"Distributed","text":"w = zeros(ks.pSpace.nx, 3)\nfor i in 1:ks.pSpace.nx\n    if i <= ks.pSpace.nx ÷ 2\n        w[i,:] .= ks.ib.wL\n    else\n        w[i,:] .= ks.ib.wR\n    end\nend     \nfw = zeros(ks.pSpace.nx+1, 3)\n\n@time for iter = 1:nt÷3\n    for i in 2:ks.pSpace.nx\n        flux = @view fw[i,:]\n        KitBase.flux_gks!(\n            flux,\n            w[i-1,:],\n            w[i,:],\n            ks.gas.γ,\n            ks.gas.K,\n            ks.gas.μᵣ,\n            ks.gas.ω,\n            dt,\n            0.5 * ks.pSpace.dx[i-1],\n            0.5 * ks.pSpace.dx[i],\n        )\n    end\n    \n    for i in 2:ks.pSpace.nx-1\n        for j in 1:3\n            w[i,j] += (fw[i,j] - fw[i+1,j]) / ks.pSpace.dx[i]\n        end\n    end\nend","category":"page"},{"location":"para_dist/","page":"Distributed","title":"Distributed","text":"The result on the same desktop is around 20.830331 seconds (323.96 M allocations: 24.472 GiB, 16.89% gc time). With more grid cells being used, the performance deviation is expected to be more significant.","category":"page"},{"location":"solver_update/#Update","page":"Update","title":"Update","text":"","category":"section"},{"location":"solver_update/","page":"Update","title":"Update","text":"The update solver calculate the variables at n+1 step based on numerical fluxes and in-cell collisions.","category":"page"},{"location":"solver_update/","page":"Update","title":"Update","text":"update!","category":"page"},{"location":"solver_update/#KitBase.update!","page":"Update","title":"KitBase.update!","text":"update!(\n    KS::X,\n    ctr::Y,\n    face::Z,\n    dt,\n    residual; # 1D / 2D\n    coll = :bgk::Symbol,\n    bc = :fix::Symbol,\n) where {\n    X<:AbstractSolverSet,\n    Y<:AbstractArray{ControlVolume1D1F,1},\n    Z<:AbstractArray{Interface1D1F,1},\n}\n\nupdate!(\n    KS::X,\n    ctr::Y,\n    face::Z,\n    dt,\n    residual; # 1D / 2D\n    coll = :bgk::Symbol,\n    bc = :extra::Symbol,\n) where {\n    X<:AbstractSolverSet,\n    Y<:AbstractArray{ControlVolume1D2F,1},\n    Z<:AbstractArray{Interface1D2F,1},\n}\n\nupdate!(\n    KS::X,\n    ctr::Y,\n    face::Z,\n    dt,\n    residual; # 1D / 2D\n    coll = :bgk::Symbol,\n    bc = :extra::Symbol,\n    isMHD = true::Bool,\n) where {\n    X<:AbstractSolverSet,\n    Y<:AbstractArray{ControlVolume1D3F,1},\n    Z<:AbstractArray{Interface1D3F,1},\n}\n\nupdate!(\n    KS::X,\n    ctr::Y,\n    face::Z,\n    dt,\n    residual; # 1D / 2D\n    coll = :bgk::Symbol,\n    bc = :extra::Symbol,\n    isMHD = true::Bool,\n) where {\n    X<:AbstractSolverSet,\n    Y<:AbstractArray{ControlVolume1D4F,1},\n    Z<:AbstractArray{Interface1D4F,1},\n}\n\nupdate!(\n    KS::X,\n    ctr::Y,\n    a1face::Z,\n    a2face::Z,\n    dt,\n    residual; # 1D / 2D\n    coll = :bgk::Symbol,\n    bc = :fix::Symbol,\n) where {\n    X<:AbstractSolverSet,\n    Y<:AbstractArray{ControlVolume2D2F,2},\n    Z<:AbstractArray{Interface2D2F,2},\n}\n\nUpdate flow variables over control volumes\n\n\n\n\n\n","category":"function"},{"location":"solver_update/","page":"Update","title":"Update","text":"The current solver supports different collision models, for example:","category":"page"},{"location":"solver_update/","page":"Update","title":"Update","text":":bgk: BGK relaxation model\n:shakhov: Shakhov relaxation model\n:boltzmann: Boltzmann: original Boltzmann collision integral","category":"page"},{"location":"solver_update/","page":"Update","title":"Update","text":"The boundary conditions vary.","category":"page"},{"location":"solver_update/","page":"Update","title":"Update","text":":fix: fixed Dirichlet boundary\n:period: periodic boundary\n:extra: extrapolation\n:maxwell: Maxwell's diffusive boundary","category":"page"},{"location":"solver_update/","page":"Update","title":"Update","text":"The current solver adopts implicit-explicit (IMEX) uniformly. Further Multi-step time integrators can be used in conjunction with method of lines in DifferentialEquations.jl.","category":"page"},{"location":"api_theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"api_theory/","page":"Theory","title":"Theory","text":"prim_conserve\nconserve_prim\nmixture_prim_conserve\nmixture_conserve_prim\nem_coefficients\nadvection_flux\nburgers_flux\neuler_flux\neuler_jacobi\ngauss_moments\nmixture_gauss_moments\nmoments_conserve\nmixture_moments_conserve\npdf_slope\nmixture_pdf_slope\nmoments_conserve_slope\nmixture_moments_conserve_slope\ndiscrete_moments\nstress\nheat_flux\nmaxwellian\nmixture_maxwellian\nshakhov\nreduce_distribution\nfull_distribution\nref_vhs_vis\nvhs_collision_time\naap_hs_collision_time\naap_hs_prim\naap_hs_diffeq!\nshift_pdf!\nhs_boltz_kn\nkernel_mode\nboltzmann_fft\nboltzmann_fft!\nheat_capacity_ratio\nsound_speed","category":"page"},{"location":"api_theory/#KitBase.prim_conserve","page":"Theory","title":"KitBase.prim_conserve","text":"prim_conserve(prim::T, γ) where {T<:AbstractArray{<:Real,1}}\n\nprim_conserve(ρ, U, λ, γ)\n\nprim_conserve(ρ, U, V, λ, γ)\n\nprim_conserve(ρ, U, V, W, λ, γ)\n\nTransform primitive -> conservative variables\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.conserve_prim","page":"Theory","title":"KitBase.conserve_prim","text":"scalar: pseudo primitive vector for scalar conservation laws\nconserve_prim(u)\nconserve_prim(u, a)\nvector: primitive vector for Euler, Navier-Stokes and extended equations\nconserve_prim(W::T, γ) where {T<:AbstractArray{<:Real,1}}\nconserve_prim(ρ, M, E, γ)\nconserve_prim(ρ, MX, MY, E, γ)\n\nTransform conservative -> primitive variables\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_prim_conserve","page":"Theory","title":"KitBase.mixture_prim_conserve","text":"mixture_prim_conserve(prim::T, γ) where {T<:AbstractArray{<:Real,2}}\n\nTransform multi-component primitive -> conservative variables\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_conserve_prim","page":"Theory","title":"KitBase.mixture_conserve_prim","text":"mixture_conserve_prim(W::T, γ) where {T<:AbstractArray{<:Real,2}}\n\nTransform multi-component conservative -> primitive variables\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.em_coefficients","page":"Theory","title":"KitBase.em_coefficients","text":"em_coefficients(\n    prim::X,\n    E::Y,\n    B::Z,\n    mr,\n    lD,\n    rL,\n    dt,\n) where {X<:AbstractArray{<:Real,2},Y<:AbstractArray{<:Real,1},Z<:AbstractArray{<:Real,1}}\n\nCalculate electromagnetic coeffcients in hyperbolic Maxwell's equations\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.advection_flux","page":"Theory","title":"KitBase.advection_flux","text":"advection_flux(u, a)\n\nTheoretical flux of linear advection equation\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.burgers_flux","page":"Theory","title":"KitBase.burgers_flux","text":"burgers_flux(u)\n\nTheoretical flux of Burgers' equation\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.euler_flux","page":"Theory","title":"KitBase.euler_flux","text":"euler_flux(w::A, γ; frame = :cartesian::Symbol) where {A<:AbstractArray{<:Real,1}}\n\nTheoretical fluxes of Euler Equations\n\n@return: flux tuple\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.euler_jacobi","page":"Theory","title":"KitBase.euler_jacobi","text":"euler_jacobi(w::T, γ) where {T<:AbstractArray{<:Real,1}}\n\nFlux Jacobian of Euler Equations\n\n@return: Jacobian matrix A\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.gauss_moments","page":"Theory","title":"KitBase.gauss_moments","text":"Calculate moments of Gaussian distribution G = (λ / π)^(D / 2) * exp[-λ(c^2 + ξ^2)]\n\ninternality: gauss_moments(prim::T) where {T<:AbstractArray{<:Real,1}}\nno internality: gauss_moments(prim::T, inK) where {T<:AbstractArray{<:Real,1}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_gauss_moments","page":"Theory","title":"KitBase.mixture_gauss_moments","text":"mixture_gauss_moments(prim::T, inK) where {T<:AbstractArray{<:Real,2}}\n\nCalculate moments of Gaussian distribution in multi-component gas\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.moments_conserve","page":"Theory","title":"KitBase.moments_conserve","text":"moments_conserve(Mu::OffsetArray{<:AbstractFloat,1}, alpha::Integer)\n\nmoments_conserve(Mu::OffsetArray{<:Real,1}, Mxi::OffsetArray{<:Real,1},\n    alpha::Integer, delta::Integer)\n\nmoments_conserve(Mu::OffsetArray{<:Real,1}, Mv::OffsetArray{<:Real,1},\n    Mw::OffsetArray{<:Real,1}, alpha::Integer, beta::Integer, delta::Integer)\n\nCalculate conservative moments of particle distribution\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_moments_conserve","page":"Theory","title":"KitBase.mixture_moments_conserve","text":"mixture_moments_conserve(\n    Mu::T,\n    Mxi::T,\n    alpha::I,\n    delta::I,\n) where {T<:OffsetArray{<:AbstractFloat,2},I<:Int}\n\nfunction mixture_moments_conserve(\n    Mu::T,\n    Mv::T,\n    Mw::T,\n    alpha::I,\n    beta::I,\n    delta::I,\n) where {T<:OffsetArray{<:AbstractFloat,2},I<:Int}\n\nCalculate conservative moments of particle distribution in multi-component gas\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.pdf_slope","page":"Theory","title":"KitBase.pdf_slope","text":"pdf_slope(u, Δ)\n\npdf_slope(prim::A, sw::B, inK) where {A<:AbstractArray{<:Real,1},B<:AbstractArray{<:Real,1}}\n\nCalculate slope of particle distribution function a = a1 + u * a2 + 0.5 * u^2 * a3\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_pdf_slope","page":"Theory","title":"KitBase.mixture_pdf_slope","text":"mixture_pdf_slope(prim::X, sw::Y, inK) where {X<:AbstractArray{<:Real,2},Y<:AbstractArray{<:Real,2}}\n\nCalculate slope of multi-component particle distribution function a = a1 + u * a2 + 0.5 * u^2 * a3\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.moments_conserve_slope","page":"Theory","title":"KitBase.moments_conserve_slope","text":"Calculate slope-related conservative moments a = a1 + u * a2 + 0.5 * u^2 * a3\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_moments_conserve_slope","page":"Theory","title":"KitBase.mixture_moments_conserve_slope","text":"mixturemomentsconserve_slope(     a::X,     Mu::Y,     Mxi::Y,     alpha::I, ) where {X<:AbstractArray{<:Real,2},Y<:OffsetArray{<:Real,2},I<:Integer}\n\nmixturemomentsconserve_slope(     a::X,     Mu::Y,     Mv::Y,     Mxi::Y,     alpha::I,     beta::I, ) where {X<:AbstractArray{<:Real,2},Y<:OffsetArray{<:Real,2},I<:Integer}\n\nmixturemomentsconserve_slope(     a::X,     Mu::Y,     Mv::Y,     Mw::Y,     alpha::I,     beta::I,     delta::I, ) where {X<:AbstractArray{<:Real,2},Y<:OffsetArray{<:Real,2},I<:Integer}\n\nCalculate slope-related conservative moments under the assumption a = a1 + u * a2 + 0.5 * u^2 * a3\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.discrete_moments","page":"Theory","title":"KitBase.discrete_moments","text":"Discrete moments of particle distribution\n\ndiscrete_moments(f, ω): direct quadrature\ndiscrete_moments(f, u, ω, n): velocity moments\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.stress","page":"Theory","title":"KitBase.stress","text":"Calculate stress tensor from particle distribution function\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.heat_flux","page":"Theory","title":"KitBase.heat_flux","text":"Calculate heat flux from particle distribution function\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.maxwellian","page":"Theory","title":"KitBase.maxwellian","text":"maxwellian(u::T, ρ, U, λ) where {T<:AbstractArray{<:AbstractFloat,1}}\n\nmaxwellian(\n    u::X,\n    prim::Y,\n) where {X<:AbstractArray{<:AbstractFloat,1},Y<:AbstractArray{<:Real,1}}\n\nmaxwellian(u::T, v::T, ρ, U, V, λ) where {T<:AbstractArray{<:AbstractFloat,2}}\n\nmaxwellian(\n    u::X,\n    v::X,\n    prim::Y,\n) where {X<:AbstractArray{<:AbstractFloat,2},Y<:AbstractArray{<:Real,1}}\n\nmaxwellian(u::T, v::T, w::T, ρ, U, V, W, λ) where {T<:AbstractArray{<:AbstractFloat,3}}\n\nmaxwellian(\n    u::X,\n    v::X,\n    w::X,\n    prim::Y,\n) where {X<:AbstractArray{<:AbstractFloat,3},Y<:AbstractArray{<:Real,1}}\n\nMaxwellian in discrete form\n\n@args: particle velocity quadrature points\n@args: density, velocity and inverse of temperature\n@return: Maxwellian distribution function\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_maxwellian","page":"Theory","title":"KitBase.mixture_maxwellian","text":"mixture_maxwellian(u::X, prim::Y) where {X<:AbstractArray{<:AbstractFloat,2},Y<:AbstractArray{<:Real,2}}\n\nmixture_maxwellian(\n    u::X,\n    v::X,\n    prim::Y,\n) where {X<:AbstractArray{<:AbstractFloat,3},Y<:AbstractArray{<:Real,2}}\n\nmixture_maxwellian(\n    u::X,\n    v::X,\n    w::X,\n    prim::Y,\n) where {X<:AbstractArray{<:AbstractFloat,4},Y<:AbstractArray{<:Real,2}}\n\nMulti-component Maxwellian in discrete form\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.shakhov","page":"Theory","title":"KitBase.shakhov","text":"shakhov(\n    u::X,\n    M::Y,\n    q,\n    prim::Z,\n    Pr,\n) where {\n    X<:AbstractArray{<:AbstractFloat,1},\n    Y<:AbstractArray{<:AbstractFloat,1},\n    Z<:AbstractArray{<:Real,1},\n}\n\nshakhov(\n    u::T,\n    H::X,\n    B::X,\n    q,\n    prim::Y,\n    Pr,\n    K,\n) where {\n    T<:AbstractArray{<:AbstractFloat,1},\n    X<:AbstractArray{<:AbstractFloat,1},\n    Y<:AbstractArray{<:Real,1},\n}\n\nshakhov(\n    u::T,\n    v::T,\n    M::X,\n    q::Y,\n    prim::Z,\n    Pr,\n) where {\n    T<:AbstractArray{<:AbstractFloat,2},\n    X<:AbstractArray{<:AbstractFloat,2},\n    Y<:AbstractArray{<:AbstractFloat,1},\n    Z<:AbstractArray{<:Real,1},\n}\n\nshakhov(\n    u::T,\n    v::T,\n    H::X,\n    B::X,\n    q::Y,\n    prim::Z,\n    Pr,\n    K,\n) where {\n    T<:AbstractArray{<:AbstractFloat,2},\n    X<:AbstractArray{<:AbstractFloat,2},\n    Y<:AbstractArray{<:Real,1},\n    Z<:AbstractArray{<:Real,1},\n}\n\nshakhov(\n    u::T,\n    v::T,\n    w::T,\n    M::X,\n    q::Y,\n    prim::Z,\n    Pr,\n) where {\n    T<:AbstractArray{<:AbstractFloat,3},\n    X<:AbstractArray{<:AbstractFloat,3},\n    Y<:AbstractArray{<:Real,1},\n    Z<:AbstractArray{<:Real,1},\n}\n\nShakhov non-equilibrium part\n\n@arg: particle velocity quadrature points\n@arg: discrete Maxwellian\n@arg: primitive variables, Prandtl number, heat flux, inner degree of freedom\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.reduce_distribution","page":"Theory","title":"KitBase.reduce_distribution","text":"reduce_distribution(\n    f::X,\n    weights::Y,\n    dim = 1,\n) where {X<:AbstractArray{<:AbstractFloat,2},Y<:AbstractArray{<:AbstractFloat,1}}\n\nreduce_distribution(\n    f::X,\n    weights::Y,\n    dim = 1,\n) where {X<:AbstractArray{<:AbstractFloat,3},Y<:AbstractArray{<:AbstractFloat,2}}\n\nReduced distribution function\n\n@arg : particle distribution function with full velocity space\n@arg : quadrature weights with reduced velocity setting (v & w by default)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.full_distribution","page":"Theory","title":"KitBase.full_distribution","text":"full_distribution(\n    h::X,\n    b::X,\n    u::Y,\n    weights::Y,\n    v::Z,\n    w::Z,\n    ρ,\n    γ = 5 / 3,\n) where {\n    X<:AbstractArray{<:AbstractFloat,1},\n    Y<:AbstractArray{<:AbstractFloat,1},\n    Z<:AbstractArray{<:AbstractFloat,3},\n}\n\nfull_distribution(\n    h::X,\n    b::X,\n    u::Y,\n    weights::Y,\n    v::Z,\n    w::Z,\n    prim::A,\n    γ = 5 / 3,\n) where {\n    X<:AbstractArray{<:AbstractFloat,1},\n    Y<:AbstractArray{<:AbstractFloat,1},\n    Z<:AbstractArray{<:AbstractFloat,3},\n    A<:AbstractArray{<:Real,1},\n}\n\nRecover full distribution function from reduced ones\n\n@arg h & b : reduced particle distribution function with 1D velocity space\n@arg u : quadrature nodes in 1D velocity space\n@arg weights : quadrature weights in 1D velocity space\n@arg v & w : quadrature nodes in the rest velocity space (with 3D setting)\n@return f : particle distribution function with 3D velocity space\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.ref_vhs_vis","page":"Theory","title":"KitBase.ref_vhs_vis","text":"ref_vhs_vis(Kn, alpha, omega)\n\nCalculate reference viscosity with variable hard sphere (VHS) model\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.vhs_collision_time","page":"Theory","title":"KitBase.vhs_collision_time","text":"vhs_collision_time(prim::T, muRef, omega) where {T<:AbstractArray{<:Real,1}}\n\nCalculate collision time with variable hard sphere (VHS) model\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.aap_hs_collision_time","page":"Theory","title":"KitBase.aap_hs_collision_time","text":"aap_hs_collision_time(\n    prim::AbstractArray{<:Real,2},\n    mi::Real,\n    ni::Real,\n    me::Real,\n    ne::Real,\n    kn::Real,\n)\n\nCalculate mixture collision time from AAP model\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.aap_hs_prim","page":"Theory","title":"KitBase.aap_hs_prim","text":"aap_hs_prim(\n    prim::AbstractArray{<:Real,2},\n    tau::AbstractArray{<:Real,1},\n    mi::Real,\n    ni::Real,\n    me::Real,\n    ne::Real,\n    kn::Real,\n)\n\nCalculate mixture primitive variables from AAP model\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.aap_hs_diffeq!","page":"Theory","title":"KitBase.aap_hs_diffeq!","text":"aap_hs_diffeq!(du, u, p, t)\n\nSource term of AAP model in DifferentialEquations.jl\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.shift_pdf!","page":"Theory","title":"KitBase.shift_pdf!","text":"shift_pdf!(\n    f::T,\n    a,\n    du,\n    dt,\n) where {T<:AbstractArray{<:AbstractFloat,1}}\n\nshift_pdf!(\n    f::X,\n    a::Y,\n    du::Z,\n    dt,\n) where {X<:AbstractArray{<:AbstractFloat,2},Y<:AbstractArray{<:Real,1},Z<:AbstractArray{<:AbstractFloat,1}}\n\nShift distribution function by external force\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.hs_boltz_kn","page":"Theory","title":"KitBase.hs_boltz_kn","text":"hs_boltz_kn(mu_ref, alpha)\n\nCalculate effective Knudsen number for fast spectral method with hard sphere (HS) model\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.kernel_mode","page":"Theory","title":"KitBase.kernel_mode","text":"kernel_mode(\n    M::TI,\n    umax::TR,\n    vmax::TR,\n    du::TR,\n    dv::TR,\n    unum::TI,\n    vnum::TI;\n    quad_num = 64::TI,\n) where {TI<:Integer,TR<:Real}\n\nkernel_mode(\n    M::I,\n    umax::R,\n    vmax::R,\n    wmax::R,\n    du::R,\n    dv::R,\n    dw::R,\n    unum::I,\n    vnum::I,\n    wnum::I,\n    alpha::R;\n    quad_num = 64::I,\n) where {I<:Integer,R<:Real}\n\nCalculate collision kernel for fast spectral method\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.boltzmann_fft","page":"Theory","title":"KitBase.boltzmann_fft","text":"boltzmann_fft(\n    f::X,\n    Kn,\n    M::I,\n    ϕ::Y,\n    ψ::Y,\n    phipsi::Z,\n) where {\n    X<:AbstractArray{<:AbstractFloat,3},\n    Y<:AbstractArray{<:AbstractFloat,4},\n    Z<:AbstractArray{<:AbstractFloat,3},\n    I<:Integer,\n}\n\nCalculate collision operator with FFT-based fast spectral method\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.boltzmann_fft!","page":"Theory","title":"KitBase.boltzmann_fft!","text":"boltzmann_fft!(\n    Q::T1,\n    f::T2,\n    Kn::TR,\n    M::TI,\n    ϕ::TY,\n    ψ::TY,\n    phipsi::TZ,\n) where {\n    T1<:AbstractArray{<:AbstractFloat,3},\n    T2<:AbstractArray{<:AbstractFloat,3},\n    TR<:Real,\n    TI<:Integer,\n    TY<:AbstractArray{<:AbstractFloat,4},\n    TZ<:AbstractArray{<:AbstractFloat,3},\n}\n\nCalculate collision operator with FFT-based fast spectral method\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.heat_capacity_ratio","page":"Theory","title":"KitBase.heat_capacity_ratio","text":"heat_capacity_ratio(K, D::T) where {T<:Integer}\n\nCalculate heat capacity ratio\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.sound_speed","page":"Theory","title":"KitBase.sound_speed","text":"sound_speed(λ::Real, γ::Real)\nsound_speed(prim::T, γ) where {T<:AbstractArray{<:Real,1}}\nsound_speed(prim::T, γ) where {T<:AbstractArray{<:Real,2}}\n\nCalculate speed of sound\n\n\n\n\n\n","category":"function"},{"location":"api_io/#I-/-O","page":"I / O","title":"I / O","text":"","category":"section"},{"location":"api_io/","page":"I / O","title":"I / O","text":"read_dict","category":"page"},{"location":"api_io/#KitBase.read_dict","page":"I / O","title":"KitBase.read_dict","text":"read_dict(filename::T, allowed) where {T<:AbstractString}\nread_dict(filename::T) where {T<:AbstractString}\n\nRead text into dictionary\n\n@args filename: configuration text file\n@args allowed: keywords in range\n@return vars: dictionary with values of variables\n\n\n\n\n\n","category":"function"},{"location":"eg_advection/#Advection-diffusion","page":"Advection diffusion","title":"Advection diffusion","text":"","category":"section"},{"location":"eg_advection/","page":"Advection diffusion","title":"Advection diffusion","text":"The first example is the scalar advection-diffusion equation. It's a one dimensional problem in physical domain x. Let's first configure the solver setup.","category":"page"},{"location":"eg_advection/","page":"Advection diffusion","title":"Advection diffusion","text":"using ProgressMeter, OffsetArrays, Plots\nimport KitBase\n\nset = KitBase.Setup(\n    \"scalar\", # matter\n    \"advection\", # case\n    \"1d0f0v\", # space\n    \"gks\", # flux\n    \"\", # collision: for scalar conservation laws there are none\n    1, # species\n    2, # interpolation order\n    \"vanleer\", # limiter\n    \"period\", # boundary\n    0.5, # cfl\n    1.0, # simulation time\n)\n\npSpace = KitBase.PSpace1D(0.0, 1.0, 100, 1)\nvSpace = nothing\nproperty = KitBase.Scalar(1.0, 1e-6)\n\nw0 = 1.0\nprim0 = KitBase.conserve_prim(w0, property.a)\nib = KitBase.IB(w0, prim0, prim0, w0, prim0, prim0)\nfolder = @__DIR__\nks = KitBase.SolverSet(set, pSpace, vSpace, property, ib, folder)","category":"page"},{"location":"eg_advection/","page":"Advection diffusion","title":"Advection diffusion","text":"The we allocate the data structure needed.","category":"page"},{"location":"eg_advection/","page":"Advection diffusion","title":"Advection diffusion","text":"ctr = OffsetArray{KitBase.ControlVolume1D}(undef, eachindex(ks.pSpace.x))\nfor i in eachindex(ctr)\n    u = sin(2π * ks.pSpace.x[i])\n    ctr[i] = KitBase.ControlVolume1D(\n        ks.pSpace.x[i],\n        ks.pSpace.dx[i],\n        u,\n        KitBase.conserve_prim(u, ks.gas.a)\n    )\nend\n\nface = Array{KitBase.Interface1D}(undef, ks.pSpace.nx+1)\nfor i = 1:ks.pSpace.nx+1\n    face[i] = KitBase.Interface1D(0.0)\nend","category":"page"},{"location":"eg_advection/","page":"Advection diffusion","title":"Advection diffusion","text":"The solution algorithm can be processed together with visualization.","category":"page"},{"location":"eg_advection/","page":"Advection diffusion","title":"Advection diffusion","text":"t = 0.0\ndt = KitBase.timestep(ks, ctr, t)\nnt = ks.set.maxTime / dt |> Int\n\nanim = @animate for iter = 1:nt\n    KitBase.reconstruct!(ks, ctr)\n    \n    for i in eachindex(face)\n        face[i].fw = KitBase.flux_gks(\n            ctr[i-1].w,\n            ctr[i].w,\n            ks.gas.μᵣ,\n            dt,\n            0.5 * ctr[i-1].dx,\n            0.5 * ctr[i].dx,\n            ks.gas.a,\n            0.,\n            0.,\n        )\n    end\n\n    for i in 1:ks.pSpace.nx\n        ctr[i].w += (face[i].fw - face[i+1].fw) / ctr[i].dx\n        ctr[i].prim .= KitBase.conserve_prim(ctr[i].w, ks.gas.a)\n    end\n    ctr[0].w = ctr[ks.pSpace.nx].w\n    ctr[ks.pSpace.nx+1].w = ctr[1].w\n\n    sol = zeros(ks.pSpace.nx)\n    for i in 1:ks.pSpace.nx\n        sol[i] = ctr[i].w\n    end\n    plot(ks.pSpace.x[1:ks.pSpace.nx], sol, xlabel=\"x\", label=\"u\", ylims=[-1, 1])\nend\n\ngif(anim, \"advection.gif\", fps = 45)","category":"page"},{"location":"eg_advection/","page":"Advection diffusion","title":"Advection diffusion","text":"(Image: )","category":"page"},{"location":"para_cuda/#GPU-computing","page":"CUDA","title":"GPU computing","text":"","category":"section"},{"location":"para_cuda/","page":"CUDA","title":"CUDA","text":"The thriving development of GPUs provides an alternative choice for scientific computing. Kinetic enables computation on the graphical architecture on the basis of CUDA.jl. It provides the main programming interface for working with NVIDIA CUDA GPUs.  It features a user-friendly array abstraction, a compiler for writing CUDA kernels in Julia, and wrappers for various CUDA libraries. In the following, we present an illustrative test of kinetic flux vector splitting method to evaluate upwind flux of the Boltzmann equation. The test is conducted on a Tesla K80 GPU on nextjournal.com. We first load all the modules, and do a CPU-based computation.","category":"page"},{"location":"para_cuda/","page":"CUDA","title":"CUDA","text":"import Pkg\nPkg.add(\"Revise\")\nPkg.add(\"KitBase\")\nPkg.add(\"CUDA\")\nPkg.add(\"BenchmarkTools\")\n\nusing Revise, CUDA, BenchmarkTools, KitBase\n\ndt = 1e-3\n\nprimL = [1.0, 0.0, 0.5]\nprimR = [0.125, 0.0, 0.625]\n\nu = collect(-5.0:0.01:5.0)\nfL = maxwellian(u, primL)\nfR = maxwellian(u, primR)\nff = similar(fL)\nsfL = zero(fL)\nsfR = zero(fR)\n\n@btime flux_kfvs!(ff, fL, fR, u, dt, sfL, sfR)","category":"page"},{"location":"para_cuda/","page":"CUDA","title":"CUDA","text":"The benchmark result on a Intel NUC8i7BEH desktop is around 5.244 μs (3 allocations: 24.00 KiB). Then let's turn to GPU.","category":"page"},{"location":"para_cuda/","page":"CUDA","title":"CUDA","text":"u = collect(-5.0:0.01:5.0) |> CuArray\nfL = maxwellian(u, primL)\nfR = maxwellian(u, primR)\nff = similar(fL)\nsfL = zero(fL)\nsfR = zero(fR)\n\n@btime flux_kfvs!(ff, fL, fR, u, dt, sfL, sfR)","category":"page"},{"location":"para_cuda/","page":"CUDA","title":"CUDA","text":"The benchmark result is around 32.965 μs (187 allocations: 10.73 KiB). As can be seen, due to the relative small input size, the GPU threads aren't fully occupied, and therefore CPU is more efficient in this case.","category":"page"},{"location":"para_cuda/","page":"CUDA","title":"CUDA","text":"Then let's increase the input vector size, i.e. to consider more discrete particle velocity points for distribution functions.","category":"page"},{"location":"para_cuda/","page":"CUDA","title":"CUDA","text":"u = collect(-5.0:0.001:5.0)\nfL = maxwellian(u, primL)\nfR = maxwellian(u, primR)\nff = similar(fL)\nsfL = zero(fL)\nsfR = zero(fR)\n\n@btime flux_kfvs!(ff, fL, fR, u, dt, sfL, sfR)\n\nu = collect(-5.0:0.001:5.0) |> CuArray\nfL = maxwellian(u, primL)\nfR = maxwellian(u, primR)\nff = similar(fL)\nsfL = zero(fL)\nsfR = zero(fR)\n\n@btime flux_kfvs!(ff, fL, fR, u, dt, sfL, sfR)","category":"page"},{"location":"para_cuda/","page":"CUDA","title":"CUDA","text":"The results become around 50.011 μs (6 allocations: 234.80 KiB) for CPU and 33.640 μs (187 allocations: 10.73 KiB) for GPU.","category":"page"},{"location":"para_cuda/","page":"CUDA","title":"CUDA","text":"We could further increase the computation size.","category":"page"},{"location":"para_cuda/","page":"CUDA","title":"CUDA","text":"u = collect(-5.0:0.0001:5.0)\nfL = maxwellian(u, primL)\nfR = maxwellian(u, primR)\nff = similar(fL)\nsfL = zero(fL)\nsfR = zero(fR)\n\n@btime flux_kfvs!(ff, fL, fR, u, dt, sfL, sfR)\n\nu = collect(-5.0:0.0001:5.0) |> CuArray\nfL = maxwellian(u, primL)\nfR = maxwellian(u, primR)\nff = similar(fL)\nsfL = zero(fL)\nsfR = zero(fR)\n\n@btime flux_kfvs!(ff, fL, fR, u, dt, sfL, sfR)","category":"page"},{"location":"para_cuda/","page":"CUDA","title":"CUDA","text":"The results become around 507.960 μs (6 allocations: 2.29 MiB) for CPU and 32.021 μs (187 allocations: 10.73 KiB) for GPU. Under this size of computation, the GPU brings about 16x efficiency increment.","category":"page"},{"location":"install/#Installation-Instructions","page":"Installation","title":"Installation Instructions","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Kinetic is a registered Julia package in the official entry. We recommend installing it with the built-in Julia package manager. It automatically installs a currently stable and tagged release.  From the Julia REPL, you can add the package.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> ]\n(v1.6) pkg> add Kinetic","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This will automatically install Kinetic and all its dependencies, and it's not needed to build the package manually. You can also build the dependencies if some of them were removed by mistake.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> ]\n(v1.6) pkg> build Kinetic","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"After that, we can using or import the package. using will load the module and make its exported names available for direct use.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using Kinetic\njulia> linspace(0, 1, 5)\n5-element Vector{Float64}:\n 0.0\n 0.25\n 0.5\n 0.75\n 1.0","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Correspondingly, import only loads the module while the names needs to be accessed with dot syntax.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> import Kinetic\njulia> Kinetic.linspace(0, 1, 5)\n5-element Vector{Float64}:\n 0.0\n 0.25\n 0.5\n 0.75\n 1.0","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Kinetic can be updated to the latest tagged release from the package manager.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(v1.5) pkg> update Kinetic","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"tip: Use Julia 1.3 or newer\nKinetic matches perfectly with Julia 1.3 and newer versions. Installing it with an older version of Julia will locate incomplete functionality.","category":"page"},{"location":"function_index/#Index-of-Types-and-Methods","page":"Index","title":"Index of Types and Methods","text":"","category":"section"},{"location":"function_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"contribution/#Guide-for-Contributors","page":"Contribution","title":"Guide for Contributors","text":"","category":"section"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"Thank you for considering contributing to Kinetic! This short guide will give you ideas on how you can contribute and help you make a contribution. Please feel free to ask us questions and chat with us at any time if you're unsure about anything.","category":"page"},{"location":"contribution/#What-can-I-do?","page":"Contribution","title":"What can I do?","text":"","category":"section"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"Tackle an existing issue.\nTry to run Kinetic and play around with it to simulate your favorite fluid and kinetic physics. If you run into any problems or find it difficult to use or understand, please open an issue!\nWrite up an example or tutorial on how to do something useful with Kinetic, like how to set up a new physical configuration.\nImprove documentation or comments if you found something hard to use.\nImplement a new feature if you need it to use Kinetic.","category":"page"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"If you're interested in working on something, let us know by commenting on existing issues or by opening a new issue if. This is to make sure no one else is working on the same issue and so we can help and guide you in case there is anything you need to know beforehand.","category":"page"},{"location":"contribution/#Philosophy","page":"Contribution","title":"Philosophy","text":"","category":"section"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"Each pull request should consist of a logical collection of changes. You can include multiple bug fixes in a single pull request, but they should be related. For unrelated changes, please submit multiple pull requests.\nDo not commit changes to files that are irrelevant to your feature or bugfix (eg: .gitignore).\nBe willing to accept criticism and work on improving your code; we don't want to break other users' code, so care must be taken not to introduce bugs. We discuss pull requests and keep working on them until we believe we've done a good job.\nBe aware that the pull request review process is not immediate, and is generally proportional to the size of the pull request.","category":"page"},{"location":"contribution/#Reporting-a-bug","page":"Contribution","title":"Reporting a bug","text":"","category":"section"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"The easiest way to get involved is to report issues you encounter when using Kinetic or by requesting something you think is missing.","category":"page"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"Head over to the issues in KitBase or KitML page.\nSearch to see if your issue already exists or has even been solved previously.\nIf you indeed have a new issue or request, click the \"New Issue\" button.\nPlease be as specific as possible. Include the version of the code you were using, as well as what operating system you are running. The output of Julia's versioninfo() and ] status is helpful to include. If possible, include complete, minimal example code that reproduces the problem.","category":"page"},{"location":"contribution/#Setting-up-your-development-environment","page":"Contribution","title":"Setting up your development environment","text":"","category":"section"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"Install Julia on your system.\nInstall git on your system if it is not already there (install XCode command line tools on a Mac or git bash on Windows).\nLogin to your GitHub account and make a fork of the KitBase or KitML by clicking the \"Fork\" button.\nClone your fork of the Kinetic repository (in terminal on Mac/Linux or git shell/ GUI on Windows) in the location you'd like to keep it.\ngit clone https://github.com/your-user-name/KitBase.jl.git or https://github.com/your-user-name/KitML.jl.git\nNavigate to that folder in the terminal or in Anaconda Prompt if you're on Windows.\nConnect your repository to the upstream (main project). git remote add KitBase https://github.com/vavrines/KitBase.jl.git or  git remote add KitML https://github.com/vavrines/KitML.jl.git\nCreate the development environment by opening Julia via julia --project then typing in ] instantiate. This will install all the dependencies in the Project.toml file.\nYou can test to make sure Kinetic works by typing in ] test which will run all the tests (this can take a while).","category":"page"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"Your development environment is now ready!","category":"page"},{"location":"contribution/#Pull-requests","page":"Contribution","title":"Pull requests","text":"","category":"section"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"Changes and contributions should be made via GitHub pull requests against the master branch.","category":"page"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"When you're done making changes, commit the changes you made. Chris Beams has written a guide on how to write good commit messages.","category":"page"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"When you think your changes are ready to be merged into the main repository, push to your fork and submit a pull request in https://github.com/vavrines/KitBase.jl/compare/ and https://github.com/vavrines/KitML.jl/compare/.","category":"page"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"Working on your first Pull Request? You can learn how from the video series How to Contribute to an Open Source Project on GitHub, Aaron Meurer's tutorial on the git workflow, or the guide “How to Contribute to Open Source\".","category":"page"},{"location":"contribution/#Documentation","page":"Contribution","title":"Documentation","text":"","category":"section"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"Now that you've made your awesome contribution, it's time to tell the world how to use it. Writing documentation strings is really important to make sure others use your functionality properly. Didn't write new functions? That's fine, but be sure that the documentation for the code you touched is still in great shape. It is not uncommon to find some strange wording or clarification that you can take care of while you are here.","category":"page"},{"location":"contribution/#Credits","page":"Contribution","title":"Credits","text":"","category":"section"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"This contributor's guide is based on the MetPy contributor's guide and Oceananigans.","category":"page"},{"location":"kitml1/#KitML-and-scientific-machine-learning","page":"KitML","title":"KitML and scientific machine learning","text":"","category":"section"},{"location":"kitml1/","page":"KitML","title":"KitML","text":"Machine learning is building its momentum in scientific computing. Given the nonlinear structure of differential and integral equations, it is promising to incorporate the universal function approximator from machine learning models into the governing equations and achieve the balance between efficiency and accuracy. KitML is designed as a scientific machine learning toolbox, which devotes to fusing mechanical and neural models. For example, the Boltzmann collision operator can be divided into a combination of relaxation model and neural network, i.e. the so-called universal Boltzmann equation.","category":"page"},{"location":"kitml1/","page":"KitML","title":"KitML","text":"fracdfdt = int_mathcalR^3 int_mathcalS^2 mathcalB(cos beta g)leftfleft(mathbfu^primeright) fleft(mathbfu_*^primeright)-f(mathbfu) fleft(mathbfu_*right)right d mathbfOmega d mathbfu_* simeq nu(mathcalM-f)+mathrmNN_theta(mathcalM-f)","category":"page"},{"location":"kitml1/","page":"KitML","title":"KitML","text":"The UBE has the following benefits.  First, it automatically ensures the asymptotic limits.  Let's consider the Chapman-Enskog method for solving Boltzmann equation, where the distribution function is approximated with expansion series.","category":"page"},{"location":"kitml1/","page":"KitML","title":"KitML","text":"f simeq f^(0)+f^(1)+f^(2)+cdots quad f^(0)=mathcalM","category":"page"},{"location":"kitml1/","page":"KitML","title":"KitML","text":"Take the zeroth order truncation, and consider an illustrative multi-layer perceptron.","category":"page"},{"location":"kitml1/","page":"KitML","title":"KitML","text":"mathrmNN_theta(x)=operatornamelayer_nleft(ldots text  layer _2left(sigmaleft(text  layer _1(x)right)right)right) quad operatornamelayer(x)=w x","category":"page"},{"location":"kitml1/","page":"KitML","title":"KitML","text":"Given the zero input from M  f, the contribution from collision term is absent, and the moment equation naturally leads to the Euler equations.","category":"page"},{"location":"kitml1/","page":"KitML","title":"KitML","text":"fracpartialpartial tleft(beginarrayc\nrho \nrho mathbfU \nrho E\nendarrayright)+nabla_mathbfx cdotleft(beginarrayc\nrho mathbfU \nrho mathbfU otimes mathbfU \nmathbfU(rho E+p)\nendarrayright)=intleft(beginarrayc\n1 \nmathbfu \nfrac12 mathbfu^2\nendarrayright)left(mathcalM_t+mathbfu cdot nabla_mathbfx mathcalMright) d mathbfu=0","category":"page"},{"location":"kitml1/","page":"KitML","title":"KitML","text":"KitML provides two functions to construct universal Boltzmann equation, and it works seamlessly with any modern ODE solver in DifferentialEquations.jl.","category":"page"},{"location":"kitml1/","page":"KitML","title":"KitML","text":"ube_dfdt\nube_dfdt!","category":"page"},{"location":"kitml1/#KitML.ube_dfdt","page":"KitML","title":"KitML.ube_dfdt","text":"ube_dfdt(f, p, t)\n\nRight-hand side of universal Boltzmann equation\n\n@args f: particle distribution function in 1D formulation\n@args p: M, τ, ann (network & parameters)\n@args t: tspan\n\n\n\n\n\n","category":"function"},{"location":"kitml1/#KitML.ube_dfdt!","page":"KitML","title":"KitML.ube_dfdt!","text":"ube_dfdt!(df, f, p, t)\n\nRight-hand side of universal Boltzmann equation\n\n@args df: derivatives of particle distribution function\n@args f: particle distribution function in 1D formulation\n@args p: M, τ, ann (network & parameters)\n@args t: tspan\n\n\n\n\n\n","category":"function"},{"location":"kitml1/","page":"KitML","title":"KitML","text":"Besides, we provide an input convex neural network (ICNN) developed by Amos et al.","category":"page"},{"location":"kitml1/","page":"KitML","title":"KitML","text":"The neural network parameters are constrained such that the output of the network is a convex function of the inputs.  The structure of the ICNN is shown as follows, and it allows for efficient inference via optimization over some inputs to the network given others, and can be applied to settings including structured prediction, data imputation, reinforcement learning, and others.  It is important for entropy-based modelling, since the minimization principle works exclusively with convex function.","category":"page"},{"location":"kitml1/","page":"KitML","title":"KitML","text":"(Image: )","category":"page"},{"location":"kitml1/","page":"KitML","title":"KitML","text":"ICNNLayer\nICNNChain","category":"page"},{"location":"kitml1/#KitML.ICNNLayer","page":"KitML","title":"KitML.ICNNLayer","text":"struct ICNNLayer{T1<:AbstractArray,T2<:Union{Flux.Zeros, AbstractVector},T3}\n    W::T1\n    U::T1\n    b::T2\n    σ::T3\nend\n\nInput Convex Neural Network (ICNN) Layer by Amos et al.\n\n\n\n\n\n","category":"type"},{"location":"kitml1/#KitML.ICNNChain","page":"KitML","title":"KitML.ICNNChain","text":"struct ICNNChain{T1,T2}\n    InLayer::T1\n    HLayer::T2\nend\n\nInput Convex Neural Network (ICNN) Layer by Amos et al.\n\n\n\n\n\n","category":"type"},{"location":"kitml1/","page":"KitML","title":"KitML","text":"Besides, we also provide scientific machine learning training interfaces and I/O methods. They are consistent with both Flux.jl and DiffEqFlux.jl ecosystem.","category":"page"},{"location":"kitml1/","page":"KitML","title":"KitML","text":"sci_train\nsci_train!\nload_data\nsave_model","category":"page"},{"location":"kitml1/#KitML.sci_train","page":"KitML","title":"KitML.sci_train","text":"sci_train(\n    ann::T,\n    data,\n    θ = initial_params(ann),\n    opt = ADAM(),\n    adtype = GalacticOptim.AutoZygote(),\n    args...;\n    maxiters = 200::Integer,\n    kwargs...,\n) where {T<:DiffEqFlux.FastLayer}\n\nsci_train(loss::Function, θ, opt, adtype = GalacticOptim.AutoZygote(), args...; kwargs...)\n\nScientific machine learning training function\n\n@args ann: neural network model\n@args data: tuple (X, Y) of dataset\n@args θ: parameters of neural network\n@args opt: optimizer\n@args adtype: automatical differentiation type\n@args args: rest arguments\n@args device: cpu / gpu\n@args maxiters: maximal iteration number\n@args kwargs: keyword arguments\n\n\n\n\n\n","category":"function"},{"location":"kitml1/#KitML.sci_train!","page":"KitML","title":"KitML.sci_train!","text":"sci_train!(ann, data::Tuple, opt = ADAM(); device = cpu, epoch = 1, batch = 1)\nsci_train!(ann, dl::Flux.Data.DataLoader, opt = ADAM(); device = cpu, epoch = 1)\n\nScientific machine learning training function\n\n@args ann: neural network model\n@args data: tuple (X, Y) of dataset\n@args opt: optimizer \n@args epoch: epoch number\n@args batch: batch size\n@args device: cpu / gpu\n\n\n\n\n\n","category":"function"},{"location":"kitml1/#KitML.load_data","page":"KitML","title":"KitML.load_data","text":"load_data(file; mode = :csv, dlm = \" \")\n\nLoad dataset from file\n\n\n\n\n\n","category":"function"},{"location":"kitml1/#KitML.save_model","page":"KitML","title":"KitML.save_model","text":"save_model(nn; mode = :jld)\n\nSave the trained machine learning model\n\n\n\n\n\n","category":"function"},{"location":"type_velocity/#Particle-velocity-space","page":"Velocity","title":"Particle velocity space","text":"","category":"section"},{"location":"type_velocity/","page":"Velocity","title":"Velocity","text":"A struct vSpace <: AbstractSetup defines the particle velocity setup of a simulation. Structs for 1-3 dimensional particle velocity space are built.","category":"page"},{"location":"type_velocity/","page":"Velocity","title":"Velocity","text":"VSpace1D\nVSpace2D\nVSpace3D","category":"page"},{"location":"type_velocity/#KitBase.VSpace1D","page":"Velocity","title":"KitBase.VSpace1D","text":"struct VSpace1D{TR<:Real,TI<:Integer,TA<:AbstractArray,TB<:AbstractArray{<:Real,1}} <: AbstractVelocitySpace\n    u0::TR\n    u1::TR\n    nu::TI\n    u::TA\n    du::TA\n    weights::TB\nend\n\n1D velocity space\n\n\n\n\n\n","category":"type"},{"location":"type_velocity/#KitBase.VSpace2D","page":"Velocity","title":"KitBase.VSpace2D","text":"struct VSpace2D{TR<:Real,TI<:Integer,TA<:AbstractArray{<:Real,2}} <: AbstractVelocitySpace\n    u0::TR\n    u1::TR\n    nu::TI\n    v0::TR\n    v1::TR\n    nv::TI\n    u::TA\n    v::TA\n    du::TA\n    dv::TA\n    weights::TA\nend\n\n2D velocity space\n\n\n\n\n\n","category":"type"},{"location":"type_velocity/#KitBase.VSpace3D","page":"Velocity","title":"KitBase.VSpace3D","text":"struct VSpace3D{TR<:Real,TI<:Integer,TA<:AbstractArray{<:Real,3}} <: AbstractVelocitySpace\n    u0::TR\n    u1::TR\n    nu::TI\n    v0::TR\n    v1::TR\n    nv::TI\n    w0::TR\n    w1::TR\n    nw::TI\n    u::TA\n    v::TA\n    w::TA\n    du::TA\n    dv::TA\n    dw::TA\n    weights::TA\nend\n\n3D velocity space\n\n\n\n\n\n","category":"type"},{"location":"type_velocity/","page":"Velocity","title":"Velocity","text":"It contains","category":"page"},{"location":"type_velocity/","page":"Velocity","title":"Velocity","text":"u0 (v0, w0): location of starting point\nu1 (v1, w1): location of ending point\nnu (nv, nw): number of cells in one direction\nu (v, w): locations of middle points of all cells\ndu (dv, dw): intervals of all cell points\nweights: quadrature weights for numerical integral","category":"page"},{"location":"type_velocity/","page":"Velocity","title":"Velocity","text":"Note that the one-dimensional velocity space can be used to handle 1-3 dimensional unstructured topology as well. In addition, velocity space structs for multi-component substance are implemented.","category":"page"},{"location":"type_velocity/","page":"Velocity","title":"Velocity","text":"MVSpace1D\nMVSpace2D\nMVSpace3D","category":"page"},{"location":"type_velocity/#KitBase.MVSpace1D","page":"Velocity","title":"KitBase.MVSpace1D","text":"struct MVSpace1D{TR<:AbstractArray{<:Real,1},TI<:Integer,TA<:AbstractArray{<:Real,2}} <: AbstractVelocitySpace\n    u0::TR\n    u1::TR\n    nu::TI\n    u::TA\n    du::TA\n    weights::TA\nend\n\n1D multi-component velocity space\n\n\n\n\n\n","category":"type"},{"location":"type_velocity/#KitBase.MVSpace2D","page":"Velocity","title":"KitBase.MVSpace2D","text":"struct MVSpace2D{TR<:AbstractArray{<:Real,1},TI<:Integer,TA<:AbstractArray{Float64,3}} <: AbstractVelocitySpace\n    u0::TR\n    u1::TR\n    nu::TI\n    v0::TR\n    v1::TR\n    nv::TI\n    u::TA\n    v::TA\n    du::TA\n    dv::TA\n    weights::TA\nend\n\n2D multi-component velocity space\n\n\n\n\n\n","category":"type"},{"location":"type_velocity/#KitBase.MVSpace3D","page":"Velocity","title":"KitBase.MVSpace3D","text":"struct MVSpace3D{TR<:AbstractArray{<:Real,1},TI<:Integer,TA<:AbstractArray{<:Real,4}} <: AbstractVelocitySpace\n    u0::TR\n    u1::TR\n    nu::TI\n    v0::TR\n    v1::TR\n    nv::TI\n    w0::TR\n    w1::TR\n    nw::TI\n    u::TA\n    v::TA\n    w::TA\n    du::TA\n    dv::TA\n    dw::TA\n    weights::TA\nend\n\n3D multi-component velocity space\n\n\n\n\n\n","category":"type"},{"location":"type_velocity/","page":"Velocity","title":"Velocity","text":"For the simulation cases where no phase-space evolution is involved, vSpace can be set as nothing directly.","category":"page"},{"location":"type_velocity/","page":"Velocity","title":"Velocity","text":"vSpace = nothing","category":"page"},{"location":"type_ib/#Initial-and-boundary-conditions","page":"Condition","title":"Initial and boundary conditions","text":"","category":"section"},{"location":"type_ib/","page":"Condition","title":"Condition","text":"A struct ib <: AbstractCondition defines the initial and boundary conditions of a simulation. It contains the values of conservative and primitive variables, and particle distribution functions at left and right (up and down) domain for both initial and boundary conditions. It is set this way to easily deal with discontinuous initial conditions.","category":"page"},{"location":"type_ib/","page":"Condition","title":"Condition","text":"IB\nIB1F\nIB2F\nIB3F\nIB4F","category":"page"},{"location":"type_ib/#KitBase.IB","page":"Condition","title":"KitBase.IB","text":"mutable struct IB{A,B,C} <: AbstractCondition\n    wL::A\n    primL::B\n    bcL::B\n\n    wR::A\n    primR::B\n    bcR::B\n\n    bcU::B\n    bcD::B\n\n    vL::C\n    vR::C\nend\n\nInitial & boundary condition with no distribution function\n\n\n\n\n\n","category":"type"},{"location":"type_ib/#KitBase.IB1F","page":"Condition","title":"KitBase.IB1F","text":"mutable struct IB1F{A,B} <: AbstractCondition\n    wL::A\n    primL::A\n    fL::B\n    bcL::A\n\n    wR::A\n    primR::A\n    fR::B\n    bcR::A\n\n    bcU::A\n    bcD::A\nend\n\nInitial & boundary condition with 1 distribution function\n\n\n\n\n\n","category":"type"},{"location":"type_ib/#KitBase.IB2F","page":"Condition","title":"KitBase.IB2F","text":"mutable struct IB2F{A,B} <: AbstractCondition\n    wL::A\n    primL::A\n    hL::B\n    bL::B\n    bcL::A\n\n    wR::A\n    primR::A\n    hR::B\n    bR::B\n    bcR::A\n\n    bcU::A\n    bcD::A\nend\n\nInitial & boundary condition with 2 distribution functions\n\n\n\n\n\n","category":"type"},{"location":"type_ib/#KitBase.IB3F","page":"Condition","title":"KitBase.IB3F","text":"mutable struct IB3F{A,B,C,D} <: AbstractCondition\n    wL::A\n    primL::A\n    h0L::B\n    h1L::B\n    h2L::B\n    bcL::A\n    EL::C\n    BL::C\n    lorenzL::D\n\n    wR::A\n    primR::A\n    h0R::B\n    h1R::B\n    h2R::B\n    bcR::A\n    ER::C\n    BR::C\n    lorenzR::D\n\n    bcU::A\n    bcD::A\nend\n\nInitial & boundary condition with 3 distribution functions\n\n\n\n\n\n","category":"type"},{"location":"type_ib/#KitBase.IB4F","page":"Condition","title":"KitBase.IB4F","text":"mutable struct IB4F{A,B,C,D} <: AbstractCondition\n    wL::A\n    primL::A\n    h0L::B\n    h1L::B\n    h2L::B\n    h3L::B\n    bcL::A\n    EL::C\n    BL::C\n    lorenzL::D\n\n    wR::A\n    primR::A\n    h0R::B\n    h1R::B\n    h2R::B\n    h3R::B\n    bcR::A\n    ER::C\n    BR::C\n    lorenzR::D\n\n    bcU::A\n    bcD::A\nend\n\nInitial & boundary condition with 4 distribution functions\n\n\n\n\n\n","category":"type"},{"location":"para_thread/#Multiple-threading","page":"Threading","title":"Multiple threading","text":"","category":"section"},{"location":"para_thread/","page":"Threading","title":"Threading","text":"The multi-threading computation is built upon Julia's @threads macro.","category":"page"},{"location":"para_thread/","page":"Threading","title":"Threading","text":"Base.Threads.@threads for ... end","category":"page"},{"location":"para_thread/","page":"Threading","title":"Threading","text":"It provides an OpenMP type parallelization. The iteration space is splitted among multiple tasks and those tasks are parallelized on threads according to a scheduling policy. A barrier is placed at the end of the loop which waits for all tasks to finish execution.","category":"page"},{"location":"para_thread/","page":"Threading","title":"Threading","text":"In Kinetic, @threads is set in front of the loops for reconstruction, evolution and update. For example, the evaluation of fluxes is conducted as follows.","category":"page"},{"location":"para_thread/","page":"Threading","title":"Threading","text":"@inbounds Threads.@threads for i = idx0:idx1\n    flux_gks!(\n        face[i].fw,\n        ctr[i-1].w .+ 0.5 .* ctr[i-1].dx .* ctr[i-1].sw,\n        ctr[i].w .- 0.5 .* ctr[i].dx .* ctr[i].sw,\n        KS.gas.γ,\n        KS.gas.K,\n        KS.gas.μᵣ,\n        KS.gas.ω,\n        dt,\n        0.5 * ctr[i-1].dx,\n        0.5 * ctr[i].dx,\n        ctr[i-1].sw,\n        ctr[i].sw,\n    )\nend","category":"page"},{"location":"para_thread/","page":"Threading","title":"Threading","text":"It automatically makes use of multiple threading if Julia is initialized with","category":"page"},{"location":"para_thread/","page":"Threading","title":"Threading","text":"julia -t n","category":"page"},{"location":"para_thread/","page":"Threading","title":"Threading","text":"Besides of @threads, finer dispatch can be made with @spawn macro.","category":"page"},{"location":"para_thread/","page":"Threading","title":"Threading","text":"Base.Threads.@spawn","category":"page"},{"location":"para_thread/","page":"Threading","title":"Threading","text":"It creates and runs a task on any available thread. To wait for the task to finish, call wait on the result of this macro, or call fetch to wait and then obtain its return value. Values can be interpolated into @spawn via $, which copies the value directly into the constructed underlying closure. It allows user to insert the value of a variable, isolating the aysnchronous code from changes to the variable's value in the current task. This can be conduct with the low-level reconstruction, flux and step functions.","category":"page"},{"location":"eg_burgers/#Burgers","page":"Burgers","title":"Burgers","text":"","category":"section"},{"location":"eg_burgers/","page":"Burgers","title":"Burgers","text":"Now we could turn to the Burgers equation. It's a typical hyperbolic conservation law, where discontinuous solution can emerge in a self-evolving system. Let's consider the same initial configuration as advection-diffusion example.","category":"page"},{"location":"eg_burgers/","page":"Burgers","title":"Burgers","text":"using ProgressMeter, OffsetArrays, Plots\nimport KitBase\n\nset = KitBase.Setup(\n    \"scalar\", # matter\n    \"advection\", # case\n    \"1d0f0v\", # space\n    \"gks\", # flux\n    \"\", # collision: for scalar conservation laws there are none\n    1, # species\n    2, # interpolation order\n    \"vanleer\", # limiter\n    \"period\", # boundary\n    0.5, # cfl\n    1.0, # simulation time\n)\n\npSpace = KitBase.PSpace1D(0.0, 1.0, 100, 1)\nvSpace = nothing\nproperty = KitBase.Scalar(0, 1e-6)\n\nw0 = 1.0\nprim0 = KitBase.conserve_prim(w0)\nib = KitBase.IB(w0, prim0, prim0, w0, prim0, prim0)\nks = KitBase.SolverSet(set, pSpace, vSpace, property, ib, @__DIR__)","category":"page"},{"location":"eg_burgers/","page":"Burgers","title":"Burgers","text":"The we allocate the data structure needed.","category":"page"},{"location":"eg_burgers/","page":"Burgers","title":"Burgers","text":"ctr = OffsetArray{KitBase.ControlVolume1D}(undef, eachindex(ks.pSpace.x))\nfor i in eachindex(ctr)\n    u = sin(2π * ks.pSpace.x[i])\n    ctr[i] = KitBase.ControlVolume1D(\n        ks.pSpace.x[i],\n        ks.pSpace.dx[i],\n        u,\n        KitBase.conserve_prim(u)\n    )\nend\n\nface = Array{KitBase.Interface1D}(undef, ks.pSpace.nx+1)\nfor i = 1:ks.pSpace.nx+1\n    face[i] = KitBase.Interface1D(0.0)\nend","category":"page"},{"location":"eg_burgers/","page":"Burgers","title":"Burgers","text":"The solution algorithm can be processed together with visualization.","category":"page"},{"location":"eg_burgers/","page":"Burgers","title":"Burgers","text":"t = 0.0\ndt = KitBase.timestep(ks, ctr, t)\nnt = ks.set.maxTime÷dt |> Int\n\nanim = @animate for iter = 1:nt\n    KitBase.reconstruct!(ks, ctr)\n    \n    for i in eachindex(face)\n        face[i].fw = KitBase.flux_gks(\n            ctr[i-1].w,\n            ctr[i].w,\n            ks.gas.μᵣ,\n            dt,\n            0.5 * ctr[i-1].dx,\n            0.5 * ctr[i].dx,\n        )\n    end\n\n    for i in 1:ks.pSpace.nx\n        ctr[i].w += (face[i].fw - face[i+1].fw) / ctr[i].dx\n        ctr[i].prim .= KitBase.conserve_prim(ctr[i].w)\n    end\n    ctr[0].w = ctr[ks.pSpace.nx].w\n    ctr[ks.pSpace.nx+1].w = ctr[1].w\n\n    sol = zeros(ks.pSpace.nx)\n    for i in 1:ks.pSpace.nx\n        sol[i] = ctr[i].w\n    end\n    plot(ks.pSpace.x[1:ks.pSpace.nx], sol, xlabel=\"x\", label=\"u\", ylims=[-1, 1])\nend\n\ngif(anim, \"burgers.gif\", fps = 45)","category":"page"},{"location":"eg_burgers/","page":"Burgers","title":"Burgers","text":"(Image: )","category":"page"},{"location":"api_config/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"api_config/","page":"Configuration","title":"Configuration","text":"ib_rh\nib_sod\nib_briowu\nib_cavity","category":"page"},{"location":"api_config/#KitBase.ib_rh","page":"Configuration","title":"KitBase.ib_rh","text":"1d1f1v: ib_rh(MaL, gam, u::T) where {T<:AbstractArray{<:AbstractFloat,1}}\n1d2f1v: ib_rh(MaL, gam, u::T, K) where {T<:AbstractArray{<:AbstractFloat,1}}\n1d1f3v: ib_rh(MaL, gam, u::T, v::T, w::T) where {T<:AbstractArray{<:AbstractFloat,3}}\n\nInitialize Rankine-Hugoniot relation\n\n\n\n\n\n","category":"function"},{"location":"api_config/#KitBase.ib_sod","page":"Configuration","title":"KitBase.ib_sod","text":"1d0f0v: ib_sod(γ)\n1d1f1v: ib_sod(γ, u::T) where {T<:AbstractArray{<:AbstractFloat,1}}\n1d1f3v: ib_sod(γ, u::T, v::T, w::T) where {T<:AbstractArray{<:AbstractFloat,3}}\n1d2f1v: ib_sod(γ, u::T, K) where {T<:AbstractArray{<:AbstractFloat,1}}\n\nInitialize Sod shock tube\n\n\n\n\n\n","category":"function"},{"location":"api_config/#KitBase.ib_briowu","page":"Configuration","title":"KitBase.ib_briowu","text":"ib_briowu(gam, uspace::T, mi, me) where {T<:AbstractArray{<:AbstractFloat,2}}\n\nInitialize Brio-Wu MHD shock tube\n\n\n\n\n\n","category":"function"},{"location":"api_config/#KitBase.ib_cavity","page":"Configuration","title":"KitBase.ib_cavity","text":"2d1f2v: ib_cavity(gam, Um, Vm, Tm, u::T, v::T) where {T<:AbstractArray{<:AbstractFloat,2}}\n2d2f2v: ib_cavity(gam, Um, Vm, Tm, u::T, v::T, K) where {T<:AbstractArray{<:AbstractFloat,2}}\n\nInitialize lid-driven cavity\n\n\n\n\n\n","category":"function"},{"location":"parallel/#Parallel-computing","page":"General","title":"Parallel computing","text":"","category":"section"},{"location":"parallel/","page":"General","title":"General","text":"Julia supports different categories of parallel programming natively:","category":"page"},{"location":"parallel/","page":"General","title":"General","text":"Asynchronous \"tasks\", or coroutines\nMulti-threading\nDistributed computing","category":"page"},{"location":"parallel/","page":"General","title":"General","text":"Kinetic integrates the the latter two mechanism along with the CUDA-based GPU computing. An initialization function is built in Kinetic.","category":"page"},{"location":"parallel/","page":"General","title":"General","text":"function __init__()\n    np = nworkers()\n    nt = Threads.nthreads()\n    if nt > 1 || np > 1\n        @info \"Kinetic will run with $np processors and $nt threads\"\n    else\n        @info \"Kinetic will run serially\"\n    end\n\n    if has_cuda()\n        @info \"Kinetic will run with CUDA\"\n        for (i, dev) in enumerate(CUDA.devices())\n            @info \"$i: $(CUDA.name(dev))\"\n        end\n        @info \"Scalar operation is disabled in CUDA\"\n        CUDA.allowscalar(false)\n    end\nend","category":"page"},{"location":"parallel/","page":"General","title":"General","text":"As the package is imported, it will report the computational resources (processors, threads and CUDA devices) that are going to be utilized.","category":"page"},{"location":"api_geo/#Physical-Space","page":"Physical space","title":"Physical Space","text":"","category":"section"},{"location":"api_geo/","page":"Physical space","title":"Physical space","text":"global_frame\nlocal_frame\nuniform_mesh\nmeshgrid\nmesh_connectivity_2D\nmesh_center_2D\nmesh_area_2D","category":"page"},{"location":"api_geo/#KitBase.global_frame","page":"Physical space","title":"KitBase.global_frame","text":"2D: global_frame(w::AbstractArray{<:Real,1}, cosa, sina)\n3D: global_frame(w::AbstractArray{<:Real,1}, dirccos::AbstractArray{<:Real,2})\n\nTransform local flow variables to global frame\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.local_frame","page":"Physical space","title":"KitBase.local_frame","text":"2D: local_frame(w::AbstractArray{<:Real,1}, cosa, sina)\n3D: local_frame(w::AbstractArray{<:Real,1}, dirccos::AbstractArray{<:Real,2})\n\nTransform global flow variables to local frame\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.uniform_mesh","page":"Physical space","title":"KitBase.uniform_mesh","text":"uniform_mesh(x0::Real, xnum::Int, dx::Real)\n\nGenerate uniform mesh\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.meshgrid","page":"Physical space","title":"KitBase.meshgrid","text":"2D: meshgrid(x::AbstractArray{<:Real,1}, y::AbstractArray{<:Real,1})\n3D: meshgrid(x::AbstractArray{<:Real,1}, y::AbstractArray{<:Real,1}, z::AbstractArray{<:Real,1})\n\nEquivalent structured mesh generator as matlab\n\n\n\n\n\n","category":"function"},{"location":"api_phase/#Phase-Space","page":"Phase space","title":"Phase Space","text":"","category":"section"},{"location":"api_phase/","page":"Phase space","title":"Phase space","text":"newton_cotes\nlegendre_quadrature\nocta_quadrature\nquadrature_weights","category":"page"},{"location":"api_phase/#KitBase.newton_cotes","page":"Phase space","title":"KitBase.newton_cotes","text":"newton_cotes(idx::T, num::T) where {T<:Integer}\n\nEvaluate quadrature weight from Newton-Cotes rule\n\n\n\n\n\n","category":"function"},{"location":"api_phase/#KitBase.legendre_quadrature","page":"Phase space","title":"KitBase.legendre_quadrature","text":"legendre_quadrature(n::T) where {T<:Integer}\n\nGauss-Legendre quadrature\n\n@args n : quadrature order (MUST be even)\n@return points : quadrature points in 3D coordinate\n@return weights : quadrature weights\n\n\n\n\n\n","category":"function"},{"location":"api_phase/#KitBase.octa_quadrature","page":"Phase space","title":"KitBase.octa_quadrature","text":"octa_quadrature(n::T, slerpflag = true::Bool) where {T<:Integer}\n\nOctaeder quadrature\n\n@args n : quadrature order\n@args slerpflag : flag of spherical linear interpolation\n@return points\n@return triangulation\n\n\n\n\n\n","category":"function"},{"location":"api_phase/#KitBase.quadrature_weights","page":"Phase space","title":"KitBase.quadrature_weights","text":"quadrature_weights(\n    xyz::X,\n    triangles::Y,\n) where {X<:AbstractArray{<:Real,2},Y<:AbstractArray{<:Integer,2}}\n\nCreate quadrature weights from points and triangulation\n\n@arg xyz : quadrature points\n@arg triangles : triangulation\n@return weights : quadrature weights\n\n\n\n\n\n","category":"function"},{"location":"api_step/#Stepper","page":"Stepper","title":"Stepper","text":"","category":"section"},{"location":"api_step/","page":"Stepper","title":"Stepper","text":"KitBase.step!","category":"page"},{"location":"api_step/#KitBase.step!","page":"Stepper","title":"KitBase.step!","text":"wrapper: step!(ks, faceL, cell, faceR, dt, res, avg, collision=:bgk, isMHD=:true)\n\n1d0f: step!(fwL, w, prim, fwR, γ, dx, RES, AVG)\n\n1d1f1v: step!(fwL, ffL, w, prim, f, fwR, ffR, u, weights,\nγ, μᵣ, ω, Pr, dx, dt, RES, AVG, collision=:bgk)\n\n1d1f3v: step!(fwL, ffL, w, prim, f, fwR, ffR, uVelo, vVelo, wVelo, weights,\nγ, μᵣ, ω, Pr, dx, dt, RES, AVG, collision=:bgk)\n\n1d2f1v: step!(fwL, fhL, fbL, w, prim, h, b, fwR, fhR, fbR, u, weights,\nK, γ, μᵣ, ω, Pr, dx, dt, RES, AVG, collision=:bgk)\n\n1d2f1v2s: step!(fwL, fhL, fbL, w, prim, h, b, fwR, fhR, fbR, u, weights, K, γ, mi, ni, me, ne,\nKn, Pr, dx, dt, RES, AVG, collision=:bgk)\n\nUpdate flow variables with finite volume formulation\n\n\n\n\n\n","category":"function"},{"location":"solver/#General-framework","page":"Framework","title":"General framework","text":"","category":"section"},{"location":"solver/","page":"Framework","title":"Framework","text":"Kinetic employs the finite volume method (FVM) for modeling and simulation.  The general solution algorithm can be conclude as follows, where both explicit and implicit methods are implemented.","category":"page"},{"location":"solver/","page":"Framework","title":"Framework","text":"(Image: )","category":"page"},{"location":"solver/","page":"Framework","title":"Framework","text":"The high-level solver function is ","category":"page"},{"location":"solver/","page":"Framework","title":"Framework","text":"solve!","category":"page"},{"location":"solver/#KitBase.solve!","page":"Framework","title":"KitBase.solve!","text":"solve!(\n    KS::X,\n    ctr::Y,\n    face::Z,\n    simTime,\n) where {\n    X<:AbstractSolverSet,\n    Y<:AbstractArray{<:AbstractControlVolume,1},\n    Z<:AbstractArray{<:AbstractInterface1D,1},\n}\n\nsolve!(\n    KS::X,\n    ctr::Y,\n    a1face::Z,\n    a2face::Z,\n    simTime,\n) where {\n    X<:AbstractSolverSet,\n    Y<:AbstractArray{<:AbstractControlVolume,2},\n    Z<:AbstractArray{<:AbstractInterface2D,2},\n}\n\nSolution algorithm\n\n@args: solver setup\n@args: array of control volumes\n@args: array of interfaces\n@args & return: time instant\n\n\n\n\n\n","category":"function"},{"location":"solver/","page":"Framework","title":"Framework","text":"The detailed solution procedures can be concluded as follows","category":"page"},{"location":"solver/","page":"Framework","title":"Framework","text":"pre-process\ntimestep calculation\nreconstruction\nevolution\nupdate\npost-process","category":"page"},{"location":"type_setup/#Parameter-Settings","page":"Setup","title":"Parameter Settings","text":"","category":"section"},{"location":"type_setup/","page":"Setup","title":"Setup","text":"A struct set <: AbstractSetup defines the general setup of a simulation.","category":"page"},{"location":"type_setup/","page":"Setup","title":"Setup","text":"Setup","category":"page"},{"location":"type_setup/#KitBase.Setup","page":"Setup","title":"KitBase.Setup","text":"struct Setup{S<:AbstractString,I<:Integer,E<:Real,F<:Real} <: AbstractSetup\n    case::S\n    space::S\n    flux::S\n    collision::S\n    nSpecies::I\n    interpOrder::I\n    limiter::S\n    boundary::S\n    cfl::E\n    maxTime::F\nend\n\nComputational setup\n\n\n\n\n\n","category":"type"},{"location":"type_setup/","page":"Setup","title":"Setup","text":"It contains","category":"page"},{"location":"type_setup/","page":"Setup","title":"Setup","text":"matter: fluid substance\ncase: simulation case name\nspace: n_1 d n_2 f n_3 v, which denotes the physical dimensionality, numbers of particle distribution functions and velocity dimensionality\nflux: numerical flux function name\ncollision: collision operator of kinetic equation\nnSpecies: number of species\ninterpOrder: order of accuracy for reconstruction\nlimiter: limiter function name\nboundary: boundary condition\ncfl: Courant-Friedrichs-Lewy number for determining time step\nmaxTime: maximum simulation time","category":"page"},{"location":"fortran1/#KitFort-and-high-performance-computing","page":"KitFort","title":"KitFort and high performance computing","text":"","category":"section"},{"location":"fortran1/","page":"KitFort","title":"KitFort","text":"Numerical simulations of nonlinear models and differential equations are essentially connected with supercomputers and high-performance computing (HPC). The performance of a supercomputer or a software program is commonly measured in floating-point operations per second (FLOPS). Through the milestone astronomy research of Celeste, Julia has entered the PetaFLOPS club (together with C/C++ and Fortran) since 2017. Julia is experiencing a dramatic Rise in HPC and elsewhere, and that is why we use Julia to organize the Kinetic. However, compared with the mature C/C++ ecosystem, the equivalent execution efficiency isn't going to happen in all time and situations. Some existing hardware architecture, e.g. Sunway TaihuLight, the previou fastest supercomputer in TOP500 list, is built upon 40,960 Chinese-designed SW26010 manycore 64-bit RISC processors, which is not specifically optimized for Julia. Therefore, we've develop an accompanying package KitFort.jl. The Fortran codes have been linked to the Julia syntax with the built-in ccall function. It's not a default submodule of Kinetic since we believe the Julia codes are sufficient for general users and developers and encounter no two-language problem. However, it can be manually imported when the executing efficiency becomes the first priority by executing","category":"page"},{"location":"fortran1/","page":"KitFort","title":"KitFort","text":"julia> ]\n(v1.5) pkg> add KitFort","category":"page"},{"location":"fortran1/","page":"KitFort","title":"KitFort","text":"After that, using/import the package.","category":"page"},{"location":"fortran1/","page":"KitFort","title":"KitFort","text":"julia> using KitFort","category":"page"},{"location":"fortran1/","page":"KitFort","title":"KitFort","text":"It can be updated to the latest tagged release from the package manager by executing","category":"page"},{"location":"fortran1/","page":"KitFort","title":"KitFort","text":"(v1.5) pkg> update KitFort","category":"page"},{"location":"solver_flux/#Evolution","page":"Flux","title":"Evolution","text":"","category":"section"},{"location":"solver_flux/","page":"Flux","title":"Flux","text":"evolve!","category":"page"},{"location":"solver_flux/#KitBase.evolve!","page":"Flux","title":"KitBase.evolve!","text":"evolve!(\n    KS::SolverSet,\n    ctr::T1,\n    face::T2,\n    dt;\n    mode = Symbol(KS.set.flux)::Symbol,\n    bc = :fix::Symbol,\n) where {\n    T1<:AbstractArray{<:AbstractControlVolume1D,1},\n    T2<:AbstractArray{<:AbstractInterface1D,1},\n}\n\nevolve!(\n    KS::SolverSet,\n    ctr::T1,\n    a1face::T2,\n    a2face::T2,\n    dt;\n    mode = Symbol(KS.set.flux)::Symbol,\n    bc = :fix::Symbol,\n) where {\n    T1<:AbstractArray{<:AbstractControlVolume2D,2},\n    T2<:AbstractArray{<:AbstractInterface2D,2},\n}\n\nEvolution of boundary fluxes\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/","page":"Flux","title":"Flux","text":"The evolution solver calculate the interface numerical fluxes based on two neighbor cells. Different flux functions can be used with the option model.","category":"page"},{"location":"solver_flux/","page":"Flux","title":"Flux","text":"macroscopic: Godunov, Lax, Roe, HLL, wave-propagation\nmesoscopic: upwind, central-upwind, gas-kinetic scheme","category":"page"},{"location":"solver_flux/","page":"Flux","title":"Flux","text":"The available flux solvers are listed as follows.","category":"page"},{"location":"solver_flux/","page":"Flux","title":"Flux","text":"flux_lax!\nflux_hll!\nflux_roe!\nflux_gks\nflux_gks!\nflux_kfvs!\nflux_kcu!\nflux_ugks!\nflux_boundary_maxwell!\nflux_boundary_specular!\nflux_em!\nflux_emx!\nflux_emy!","category":"page"},{"location":"solver_flux/#KitBase.flux_lax!","page":"Flux","title":"KitBase.flux_lax!","text":"flux_lax!(fw::AbstractArray{<:Real,1}, wL::AbstractArray{<:Real,1}, wR::AbstractArray{<:Real,1}, γ::Real, dt::Real, dx::Real)\n\nLax-Friedrichs flux\n\nP. D. Lax, Weak Solutions of Nonlinear Hyperbolic Equations and Their Numerical Computation, Commun. Pure and Applied Mathematics, 7, 159-193, 1954.\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_hll!","page":"Flux","title":"KitBase.flux_hll!","text":"flux_hll!(fw::AbstractArray{<:Real,1}, wL::AbstractArray{<:Real,1}, wR::AbstractArray{<:Real,1}, γ::Real, dt::Real)\n\nHLL flux for the Euler equations\n\n@args: variables at left & right sides of interface\n@args: specific heat ratio\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_roe!","page":"Flux","title":"KitBase.flux_roe!","text":"flux_roe!(fw::AbstractArray{<:Real,1}, wL::AbstractArray{<:Real,1}, wR::AbstractArray{<:Real,1},\nγ::Real, dt::Real, n = [1.0, 0.0]::AbstractArray{<:Real,1})\n\nRoe's flux with entropy fix    \n\nP. L. Roe, Approximate Riemann Solvers, Parameter Vectors and Difference Schemes, Journal of Computational Physics, 43, pp. 357-372. (cf. http://cfdbooks.com/cfdcodes.html)\n\n@args primL[1:4] = left state (rhoL, uL, vL, pL)\n@args primR[1:4] = right state (rhoR, uR, vR, pR)\n@args γ: specific heat ratio\n@args n[2]: unit face normal (L -> R)\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_gks","page":"Flux","title":"KitBase.flux_gks","text":"flux_gks(u, μ, dt, a = 0::T, su = 0.0) where {T<:Real}\nflux_gks(uL::T, uR::T, μ, dt, dxL, dxR, a = 0, suL = 0.0, suR = 0.0) where {T<:Real}\n\nGas kinetic scalar flux\n\n@args: conservative scalars and their slopes\n@args: viscosity\n@args: time step and cell size\n@return: scalar flux\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_gks!","page":"Flux","title":"KitBase.flux_gks!","text":"Gas kinetic Navier-Stokes flux\n\n@args: conservative variables and their left/right slopes\n@args: molecular and thermodynamic parameters\n@args: time step and cell size\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_kfvs!","page":"Flux","title":"KitBase.flux_kfvs!","text":"DOM: flux_kfvs!(ff, fL, fR, u, dt, sfL, sfR)\n1D1F1V: flux_kfvs!(fw, ff, fL, fR, u, ω, dt, sfL, sfR)\n1D1F3V: flux_kfvs!(fw, ff, fL, fR, u, v, w, ω, dt, sfL, sfR)\n1D2F1V: flux_kfvs!(fw, fh, fb, hL, bL, hR, bR, u, ω, dt, shL, sbL, shR, sbR)\n1D4F1V: flux_kfvs!(fw, fh0, fh1, fh2, fh3, h0L, h1L, h2L, h3L, h0R, h1R, h2R, h3R, u, ω, dt, sh0L, sh1L, sh2L, sh3L, sh0R, sh1R, sh2R, sh3R)\n2D1F2V: flux_kfvs!(fw, ff, fL, fR, u, v, ω, dt, len, sfL, sfR)\n2D2F2V: flux_kfvs!(fw, fh, fb, hL, bL, hR, bR, u, v, ω, dt, len, shL, sbL, shR, sbR)\n\nKinetic flux vector splitting (KFVS) flux\n\n@args: particle distribution functions and their left/right slopes\n@args: particle velocity quadrature points and weights\n@args: time step and cell size\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_kcu!","page":"Flux","title":"KitBase.flux_kcu!","text":"1D1F1V: flux_kcu!(fw, ff, wL, fL, wR, fR, u, ω, inK, γ, visRef, visIdx, Pr, dt)\n1D2F1V: flux_kcu!(fw, fh, fb, wL, hL, bL, wR, hR, bR, u, ω, inK, γ, visRef, visIdx, Pr, dt)\n1D4F1V: flux_kcu!(fw, fh0, fh1, fh2, fh3, wL, h0L, h1L, h2L, h3L, wR, h0R, h1R, h2R, h3R, u, ω, inK, γ, visRef, visIdx, Pr, dt)\n2D1F2V: flux_kcu!(fw, ff, wL, fL, wR, fR, u, v, ω, inK, γ, visRef, visIdx, Pr, dt, len)\n2D2F2V: flux_kcu!(fw, fh, fb, wL, hL, bL, wR, hR, bR, u, v, ω, inK, γ, visRef, visIdx, Pr, dt, len)\n2D3F2V: flux_kcu!(fw, fh0, fh1, fh2, wL, h0L, h1L, h2L, wR, h0R, h1R, h2R, u, v, ω, inK, γ, visRef, visIdx, Pr, dt, len)\n\nKinetic central-upwind (KCU) method\n\n@args: particle distribution functions and their slopes at left/right sides of interface\n@args: particle velocity quadrature points and weights\n@args: time step and cell size\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_ugks!","page":"Flux","title":"KitBase.flux_ugks!","text":"flux_ugks!(\n    fw::T1,\n    fh::T2,\n    fb::T2,\n    wL::T3,\n    hL::T4,\n    bL::T4,\n    wR::T3,\n    hR::T4,\n    bR::T4,\n    u::T5,\n    ω::T5,\n    inK,\n    γ,\n    visRef,\n    visIdx,\n    pr,\n    dt,\n    dxL,\n    dxR,\n    shL = zeros(eltype(hL), axes(hL))::T4,\n    sbL = zeros(eltype(bL), axes(bL))::T4,\n    shR = zeros(eltype(hR), axes(hR))::T4,\n    sbR = zeros(eltype(bR), axes(bR))::T4,\n) where {\n    T1<:AbstractArray{<:AbstractFloat,1},\n    T2<:AbstractArray{<:AbstractFloat,1},\n    T3<:AbstractArray{<:Real,1},\n    T4<:AbstractArray{<:AbstractFloat,1},\n    T5<:AbstractArray{<:AbstractFloat,1},\n}\n\nflux_ugks!(\n    fw::T1,\n    fh::T2,\n    fb::T2,\n    wL::T3,\n    hL::T4,\n    bL::T4,\n    wR::T3,\n    hR::T4,\n    bR::T4,\n    u::T5,\n    v::T5,\n    ω::T5,\n    inK,\n    γ,\n    visRef,\n    visIdx,\n    pr,\n    dt,\n    dxL,\n    dxR,\n    len,\n    shL = zeros(eltype(hL), axes(hL))::T4,\n    sbL = zeros(eltype(bL), axes(bL))::T4,\n    shR = zeros(eltype(hR), axes(hR))::T4,\n    sbR = zeros(eltype(bR), axes(bR))::T4,\n) where {\n    T1<:AbstractArray{<:AbstractFloat,1},\n    T2<:AbstractArray{<:AbstractFloat,2},\n    T3<:AbstractArray{<:Real,1},\n    T4<:AbstractArray{<:AbstractFloat,2},\n    T5<:AbstractArray{<:AbstractFloat,2},\n}\n\nflux_ugks!(\n    fw::T1,\n    fh0::T2,\n    fh1::T2,\n    fh2::T2,\n    wL::T3,\n    h0L::T4,\n    h1L::T4,\n    h2L::T4,\n    wR::T3,\n    h0R::T4,\n    h1R::T4,\n    h2R::T4,\n    u::T5,\n    v::T5,\n    ω::T5,\n    inK,\n    γ,\n    mi,\n    ni,\n    me,\n    ne,\n    Kn,\n    dt,\n    dxL,\n    dxR,\n    len,\n    sh0L = zeros(eltype(h0L), axes(h0L))::T4,\n    sh1L = zeros(eltype(h1L), axes(h1L))::T4,\n    sh2L = zeros(eltype(h2L), axes(h2L))::T4,\n    sh0R = zeros(eltype(h0R), axes(h0R))::T4,\n    sh1R = zeros(eltype(h1R), axes(h1R))::T4,\n    sh2R = zeros(eltype(h2R), axes(h2R))::T4,\n) where {\n    T1<:AbstractArray{<:AbstractFloat,2},\n    T2<:AbstractArray{<:AbstractFloat,3},\n    T3<:AbstractArray{<:Real,2},\n    T4<:AbstractArray{<:AbstractFloat,3},\n    T5<:AbstractArray{<:AbstractFloat,3},\n}\n\nUnified gas kinetic scheme (UGKS)\n\n@args: particle distribution functions and their slopes at left/right sides of interface\n@args: particle velocity quadrature points and weights\n@args: time step\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_boundary_maxwell!","page":"Flux","title":"KitBase.flux_boundary_maxwell!","text":"flux_boundary_maxwell!(\n    fw::T1,\n    fh::T2,\n    fb::T2,\n    bc::T3,\n    h::T4,\n    b::T4,\n    u::T5,\n    ω::T5,\n    inK,\n    dt,\n    rot = 1,\n) where {\n    T1<:AbstractArray{<:AbstractFloat,1},\n    T2<:AbstractArray{<:AbstractFloat,1},\n    T3<:Array{<:Real,1},\n    T4<:AbstractArray{<:AbstractFloat,1},\n    T5<:AbstractArray{<:AbstractFloat,1},\n}\n\nflux_boundary_maxwell!(\n    fw::T1,\n    fh::T2,\n    fb::T2,\n    bc::T3,\n    h::T4,\n    b::T4,\n    u::T5,\n    v::T5,\n    ω::T5,\n    inK,\n    dt,\n    len,\n    rot = 1,\n) where {\n    T1<:AbstractArray{<:AbstractFloat,1},\n    T2<:AbstractArray{<:AbstractFloat,2},\n    T3<:Array{<:Real,1},\n    T4<:AbstractArray{<:AbstractFloat,2},\n    T5<:AbstractArray{<:AbstractFloat,2},\n}\n\nMaxwell's diffusive boundary flux\n\n@args: particle distribution functions and their slopes at left/right sides of interface\n@args: particle velocity quadrature points and weights\n@args: time step\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_boundary_specular!","page":"Flux","title":"KitBase.flux_boundary_specular!","text":"flux_boundary_specular!(\n    fw::T1,\n    ff::T2,\n    f::T3,\n    u::T4,\n    ω::T4,\n    dt,\n) where {\n    T1<:AbstractArray{<:Real,1},\n    T2<:AbstractArray{<:AbstractFloat,1},\n    T3<:AbstractArray{<:AbstractFloat,1},\n    T4<:AbstractArray{<:AbstractFloat,1},\n}\n\nflux_boundary_specular!(\n    fw::T1,\n    fh::T2,\n    fb::T2,\n    h::T3,\n    b::T3,\n    u::T4,\n    ω::T4,\n    dt,\n) where {\n    T1<:AbstractArray{<:Real,1},\n    T2<:AbstractArray{<:AbstractFloat,1},\n    T3<:AbstractArray{<:AbstractFloat,1},\n    T4<:AbstractArray{<:AbstractFloat,1},\n}\n\nSpecular reflection boundary flux\n\n@args: particle distribution functions and their slopes at left/right sides of interface\n@args: particle velocity quadrature points and weights\n@args: time step\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_em!","page":"Flux","title":"KitBase.flux_em!","text":"flux_em!(femL, femR, ELL, BLL, EL, BL, ER, BR, ERR, BRR, ϕL, ϕR, ψL, ψR, dxL, dxR, Ap, An, D, sol, χ, ν, dt)\n\nWave propagation method for Maxwell's equations\n\n@args: {E, B, ϕ, ψ} in left-left, left, right, and right-right cells\n@args: eigenmatrix (A -> A+ & A-), eigenvalue (D)\n@args: full size of left & right cells\n@args: speed of light (sol)\n@args: auxiliary parameters (χₑ, νᵦ)\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_emx!","page":"Flux","title":"KitBase.flux_emx!","text":"flux_emx!(femL, femR, femLU, femLD, femRU, femRD,\nELL, BLL, EL, BL, ER, BR, ERR, BRR, ϕL, ϕR, ψL, ψR,\ndxL, dxR, A1p, A1n, A2p, A2n, D, sol, χ, ν, dt)\n\nWave propagation method for 2D Maxwell's equations\n\n@args: {E, B, ϕ, ψ} in left-left, left, right, and right-right cells\n@args: eigenmatrix (A -> A+ & A-), eigenvalue (D)\n@args: full size of left & right cells\n@args: speed of light (sol)\n@args: auxiliary parameters (χₑ, νᵦ)\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_emy!","page":"Flux","title":"KitBase.flux_emy!","text":"flux_emx!(femL, femR, femLU, femLD, femRU, femRD,\nELL, BLL, EL, BL, ER, BR, ERR, BRR, ϕL, ϕR, ψL, ψR,\ndxL, dxR, A1p, A1n, A2p, A2n, D, sol, χ, ν, dt)\n\nWave propagation method for 2D Maxwell's equations\n\n@args: {E, B, ϕ, ψ} in left-left, left, right, and right-right cells\n@args: eigenmatrix (A -> A+ & A-), eigenvalue (D)\n@args: full size of left & right cells\n@args: speed of light (sol)\n@args: auxiliary parameters (χₑ, νᵦ)\n\n\n\n\n\n","category":"function"},{"location":"type_property/#Particle-properties","page":"Property","title":"Particle properties","text":"","category":"section"},{"location":"type_property/","page":"Property","title":"Property","text":"A struct gas <: AbstractProperty defines the properties of particle model. It currently supports the following models:","category":"page"},{"location":"type_property/","page":"Property","title":"Property","text":"scalar\ngas-type molecule\nplasma","category":"page"},{"location":"type_property/","page":"Property","title":"Property","text":"Scalar\nGas\nMixture\nPlasma1D\nPlasma2D","category":"page"},{"location":"type_property/#KitBase.Scalar","page":"Property","title":"KitBase.Scalar","text":"mutable struct Scalar{TA,TB} <: AbstractProperty\n    a::TA\n    μᵣ::TB\nend\n\nFluid property for scalar conservation laws\n\n\n\n\n\n","category":"type"},{"location":"type_property/#KitBase.Gas","page":"Property","title":"KitBase.Gas","text":"mutable struct Gas{A,B,C,D,E,F,G,H,I,J,K<:Integer} <: AbstractProperty\n    Kn::A\n    Ma::B\n    Pr::C\n    K::D\n    γ::E\n    ω::F\n    αᵣ::G\n    ωᵣ::H\n    μᵣ::I\n    m::J\n    np::K\nend\n\nGas property\n\n\n\n\n\n","category":"type"},{"location":"type_property/#KitBase.Mixture","page":"Property","title":"KitBase.Mixture","text":"struct Mixture{A,B,C,D,E,F,G,H,I} <: AbstractProperty\n    Kn::A\n    Ma::B\n    Pr::C\n    K::D\n    γ::E\n    mi::F\n    ni::G\n    me::H\n    ne::I\nend\n\nMulti-component gas property\n\n\n\n\n\n","category":"type"},{"location":"type_property/#KitBase.Plasma1D","page":"Property","title":"KitBase.Plasma1D","text":"struct Plasma1D{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P} <: AbstractProperty\n\n    Kn::A\n    Ma::B\n    Pr::C\n    K::D\n    γ::E\n\n    mi::F\n    ni::G\n    me::H\n    ne::I\n    lD::J\n    rL::K\n\n    sol::L\n    χ::M\n    ν::N\n    Ap::O\n    An::O\n    D::P\nend\n\n1D plasma property\n\n\n\n\n\n","category":"type"},{"location":"type_property/#KitBase.Plasma2D","page":"Property","title":"KitBase.Plasma2D","text":"struct Plasma2D{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P} <: AbstractProperty\n    Kn::A\n    Ma::B\n    Pr::C\n    K::D\n    γ::E\n\n    mi::F\n    ni::G\n    me::H\n    ne::I\n    lD::J\n    rL::K\n\n    sol::L\n    χ::M\n    ν::N\n    A1p::O\n    A1n::O\n    A2p::O\n    A2n::O\n    D1::P\n    D2::P\nend\n\n2D plasma property\n\n\n\n\n\n","category":"type"},{"location":"type_property/","page":"Property","title":"Property","text":"The fields denote, for example:","category":"page"},{"location":"type_property/","page":"Property","title":"Property","text":"Kn: reference Knudsen number\nMa: reference Mach number\nPr: reference Prandtl number\nK: internal degree of freedom of molecule\nγ: adiabatic index\nω: viscosity index\nαᵣ: reference alpha in viscosity evaluation\nωᵣ: reference omega in viscosity evaluation\nμᵣ: reference viscosity\nm: mass of each particle\nnp: number of particles","category":"page"},{"location":"type_property/","page":"Property","title":"Property","text":"The viscosity is evaluated the following hard-sphere model.","category":"page"},{"location":"type_property/","page":"Property","title":"Property","text":"mu = mu_ref left(fracTT_refright)^omega","category":"page"},{"location":"type_property/","page":"Property","title":"Property","text":"mu_ref=frac5(alpha+1)(alpha+2) sqrtpi4 alpha(5-2 omega)(7-2 omega) Kn_ref","category":"page"},{"location":"solver_timestep/#Timestep","page":"Timestep","title":"Timestep","text":"","category":"section"},{"location":"solver_timestep/","page":"Timestep","title":"Timestep","text":"timestep","category":"page"},{"location":"solver_timestep/#KitBase.timestep","page":"Timestep","title":"KitBase.timestep","text":"timestep(KS, ctr, simTime)\n\nCalculate timestep\n\n@return: Δt\n\n\n\n\n\n","category":"function"},{"location":"solver_timestep/","page":"Timestep","title":"Timestep","text":"The timestep solver returns the time interval used for the upcoming solution loop based on the current variables.","category":"page"},{"location":"type_domain/#Physical-space","page":"Domain","title":"Physical space","text":"","category":"section"},{"location":"type_domain/","page":"Domain","title":"Domain","text":"A struct set <: AbstractPhysicalSpace defines the geometric setup of a simulation. For the structured topology, structs for 1 and 2 dimensional physical space are built.","category":"page"},{"location":"type_domain/","page":"Domain","title":"Domain","text":"PSpace1D\nPSpace2D","category":"page"},{"location":"type_domain/#KitBase.PSpace1D","page":"Domain","title":"KitBase.PSpace1D","text":"struct PSpace1D{TR,TI<:Integer,TA<:AbstractArray} <: AbstractPhysicalSpace\n    x0::TR\n    x1::TR\n    nx::TI\n    x::TA\n    dx::TA\nend\n\n1D physical space with structured mesh\n\n\n\n\n\n","category":"type"},{"location":"type_domain/#KitBase.PSpace2D","page":"Domain","title":"KitBase.PSpace2D","text":"struct PSpace2D{TR<:Real,TI<:Integer,TA<:AbstractArray{<:Real,2}} <: AbstractPhysicalSpace\n    x0::TR\n    x1::TR\n    nx::TI\n    y0::TR\n    y1::TR\n    ny::TI\n    x::TA\n    y::TA\n    dx::TA\n    dy::TA\nend\n\n2D Physical space with structured mesh\n\n\n\n\n\n","category":"type"},{"location":"type_domain/","page":"Domain","title":"Domain","text":"It contains:","category":"page"},{"location":"type_domain/","page":"Domain","title":"Domain","text":"x0 (y0): location of starting point\nx1 (y1): location of ending point\nnx (ny): number of cells in one direction\nx (y): locations of middle points of all cells\ndx (dy): intervals of all cell points","category":"page"},{"location":"type_domain/","page":"Domain","title":"Domain","text":"Besides, a unstrctured mesh struct is built, which supports 1-3 dimensional geometries.","category":"page"},{"location":"type_domain/","page":"Domain","title":"Domain","text":"UnstructPSpace","category":"page"},{"location":"type_domain/#KitBase.UnstructPSpace","page":"Domain","title":"KitBase.UnstructPSpace","text":"struct UnstructPSpace{A,B,C,D,E,F,G,H,I,J,K,L} <: AbstractPhysicalSpace\n    cells::A # all information: cell, line, vertex\n    points::B # locations of vertex points\n    cellid::C # node indices of elements\n    cellType::D # inner/boundary cell\n    cellNeighbors::E # neighboring cells id\n    cellFaces::F # cell edges id\n    cellCenter::G # cell center location\n    cellArea::H # cell size\n    facePoints::I # ids of two points at edge\n    faceCells::J # ids of two cells around edge\n    faceCenter::K # edge center location\n    faceType::L\nend\n\nPhysical space with unstructured mesh\n\n\n\n\n\n","category":"type"},{"location":"type_domain/","page":"Domain","title":"Domain","text":"It can be created by the built-in mesh reader.","category":"page"},{"location":"type_domain/","page":"Domain","title":"Domain","text":"read_mesh","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Bezanson, J., Edelman, A., Karpinski, S., & Shah, V. B. (2017). Julia: A fresh approach to numerical computing. SIAM review, 59(1), 65-98.\nChapman, S., Cowling, T. G., & Burnett, D. (1990). The mathematical theory of non-uniform gases: an account of the kinetic theory of viscosity, thermal conduction and diffusion in gases. Cambridge University Press.\nLandau, L.D., & Lifshitz E. M. (1959). Fluid mechanics, London: Pergamon Press.\nBlazek, J. (2015). Computational fluid dynamics: principles and applications. Butterworth-Heinemann.\nXu, K., & Huang, J. C. (2010). A unified gas-kinetic scheme for continuum and rarefied flows. Journal of Computational Physics, 229(20), 7747-7764.\nBird, G. A. (1994). Molecular gas dynamics and the direct simulation of gas flows. Molecular gas dynamics and the direct simulation of gas flows.\nXiao, T., Cai, Q., & Xu, K. (2017). A well-balanced unified gas-kinetic scheme for multiscale flow transport under gravitational field. Journal of Computational Physics, 332, 475-491.\nXiao, T., Xu, K., & Cai, Q. (2019). A unified gas-kinetic scheme for multiscale and multicomponent flow transport. Applied Mathematics and Mechanics, 40(3), 355-372.\nXiao, T., Liu, C., Xu, K., & Cai, Q. (2020). A velocity-space adaptive unified gas kinetic scheme for continuum and rarefied flows. Journal of Computational Physics, 415, 109535.\nXiao, T., & Frank, M. (2020). Using neural networks to accelerate the solution of the Boltzmann equation. arXiv:2010.13649.\nAmos, B., Xu, L., & Kolter, J. Z. (2017, July). Input convex neural networks. In International Conference on Machine Learning (pp. 146-155). PMLR.","category":"page"},{"location":"api_math/#Math","page":"Math","title":"Math","text":"","category":"section"},{"location":"api_math/","page":"Math","title":"Math","text":"linspace\nheaviside\nfortsign\nmat_split\ncentral_diff\ncentral_diff!\nupwind_diff\nupwind_diff!\nunstruct_diff\nKitBase.lgwt\nKitBase.extract_last","category":"page"},{"location":"api_math/#KitBase.linspace","page":"Math","title":"KitBase.linspace","text":"linspace(start, stop, n::T) where {T<:Integer}\n\nPython linspace function\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.heaviside","page":"Math","title":"KitBase.heaviside","text":"heaviside(x::Real)\n\nHeaviside step function\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.fortsign","page":"Math","title":"KitBase.fortsign","text":"fortsign(x::Real, y::Real)\n\nFortran sign function\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.mat_split","page":"Math","title":"KitBase.mat_split","text":"mat_split(m::AbstractArray)\n\nSplit matrix into row vectors\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.central_diff","page":"Math","title":"KitBase.central_diff","text":"central_diff(y::AbstractArray{<:Any,1}, x::AbstractArray{<:Any,1})\ncentral_diff(y::AbstractArray{<:Any,1}, dx::Any)\n\nCentral difference\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.central_diff!","page":"Math","title":"KitBase.central_diff!","text":"central_diff!(dy::AbstractArray{<:Any,1}, y::AbstractArray{<:Any,1}, x::AbstractArray{<:Any,1})\ncentral_diff!(dy::AbstractArray{<:Any,1}, y::AbstractArray{<:Any,1}, dx::Any)\n\nCentral difference\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.upwind_diff","page":"Math","title":"KitBase.upwind_diff","text":"upwind_diff(\n    y::AbstractArray{<:Any,1},\n    x::AbstractArray{<:Any,1};\n    stream = :right::Symbol,\n)\n\nupwind_diff(y::AbstractArray{<:Any,1}, dx::Any; stream = :right::Symbol)\n\nUpwind difference\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.upwind_diff!","page":"Math","title":"KitBase.upwind_diff!","text":"upwind_diff!(\n    dy::AbstractArray{<:Any,1},\n    y::AbstractArray{<:Any,1},\n    x::AbstractArray{<:Any,1};\n    stream = :right::Symbol,\n)\n\nupwind_diff!(\n    dy::AbstractArray{<:Any,1},\n    y::AbstractArray{<:Any,1},\n    dx::Any;\n    stream = :right::Symbol,\n)\n\nUpwind difference\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.unstruct_diff","page":"Math","title":"KitBase.unstruct_diff","text":"unstruct_diff(u::AbstractArray{<:Any,1}, x::AbstractArray{<:Any,1}, nx::Integer; mode = :central::Symbol)\nunstruct_diff(u::Function, x::AbstractArray{<:Any,2}, nx::Integer, dim::Integer; mode = :central::Symbol)\n\nFinite difference for pseudo-unstructured mesh\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.lgwt","page":"Math","title":"KitBase.lgwt","text":"lgwt(N::Integer, a::Real, b::Real)\n\nGauss Legendre integral for fast spectral method\n\n@args: number of quadrature points N, integral range [a, b]\n@args: quadrature points x & weights w\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.extract_last","page":"Math","title":"KitBase.extract_last","text":"extract_last(a::AbstractArray, idx::Integer; mode=:view::Symbol)\n\nExtract subarray except the last column\n\n\n\n\n\n","category":"function"},{"location":"type_fvm/#Finite-volume-data","page":"FVM","title":"Finite volume data","text":"","category":"section"},{"location":"type_fvm/","page":"FVM","title":"FVM","text":"In the finite volume method, the data is stored separately throughout the cells. Therefore, we provide AbstractControlVolume and AbstractInterface structs for processing in-cell and edge information, which are used as arrays of structs (AoS) in numerical simulations. Considering one-dimensional physical space x, we provide the following control volume structs. The structs differs from the number of particle distribution functions.","category":"page"},{"location":"type_fvm/","page":"FVM","title":"FVM","text":"ControlVolume1D\nControlVolume1D1F\nControlVolume1D2F\nControlVolume1D3F\nControlVolume1D4F","category":"page"},{"location":"type_fvm/#KitBase.ControlVolume1D","page":"FVM","title":"KitBase.ControlVolume1D","text":"mutable struct ControlVolume1D{F,A,B} <: AbstractControlVolume1D\n    x::F\n    dx::F\n\n    w::A\n    prim::B\n    sw::A\nend\n\n1D control volume with no distribution function\n\n\n\n\n\n","category":"type"},{"location":"type_fvm/#KitBase.ControlVolume1D1F","page":"FVM","title":"KitBase.ControlVolume1D1F","text":"mutable struct ControlVolume1D1F{F,A,B} <: AbstractControlVolume1D\n    x::F\n    dx::F\n\n    w::A\n    prim::A\n    sw::A\n\n    f::B\n    sf::B\nend\n\n1D control volume with 1 distribution function\n\n\n\n\n\n","category":"type"},{"location":"type_fvm/#KitBase.ControlVolume1D2F","page":"FVM","title":"KitBase.ControlVolume1D2F","text":"mutable struct ControlVolume1D2F{F,A,B} <: AbstractControlVolume1D\n    x::F\n    dx::F\n\n    w::A\n    prim::A\n    sw::A\n\n    h::B\n    b::B\n    sh::B\n    sb::B\nend\n\n1D control volume with 2 distribution functions\n\n\n\n\n\n","category":"type"},{"location":"type_fvm/#KitBase.ControlVolume1D3F","page":"FVM","title":"KitBase.ControlVolume1D3F","text":"mutable struct ControlVolume1D3F{F,A,B,C,D,E} <: AbstractControlVolume1D\n    x::F\n    dx::F\n\n    w::A\n    prim::A\n    sw::A\n\n    h0::B\n    h1::B\n    h2::B\n    sh0::B\n    sh1::B\n    sh2::B\n\n    E::C\n    B::C\n    ϕ::D\n    ψ::D\n    lorenz::E\nend\n\n1D control volume with 3 distribution functions\n\n\n\n\n\n","category":"type"},{"location":"type_fvm/#KitBase.ControlVolume1D4F","page":"FVM","title":"KitBase.ControlVolume1D4F","text":"mutable struct ControlVolume1D4F{F,A,B,C,D,E} <: AbstractControlVolume1D\n    x::F\n    dx::F\n\n    w::A\n    prim::A\n    sw::A\n\n    h0::B\n    h1::B\n    h2::B\n    h3::B\n    sh0::B\n    sh1::B\n    sh2::B\n    sh3::B\n\n    E::C\n    B::C\n    ϕ::D\n    ψ::D\n    lorenz::E\nend\n\n1D control volume with 4 distribution functions\n\n\n\n\n\n","category":"type"},{"location":"type_fvm/","page":"FVM","title":"FVM","text":"Within each cell, different numbers of particle distribution function can be tracked. The interface data is stored correspondingly.","category":"page"},{"location":"type_fvm/","page":"FVM","title":"FVM","text":"Interface1D\nInterface1D1F\nInterface1D2F\nInterface1D3F\nInterface1D4F","category":"page"},{"location":"type_fvm/#KitBase.Interface1D","page":"FVM","title":"KitBase.Interface1D","text":"mutable struct Interface1D{A<:Union{Real,AbstractArray}} <: AbstractInterface1D\n    fw::A\nend\n\n1D cell interface with no distribution function Note that deepcopy constructor is needed to work with StructArrays\n\n\n\n\n\n","category":"type"},{"location":"type_fvm/#KitBase.Interface1D1F","page":"FVM","title":"KitBase.Interface1D1F","text":"mutable struct Interface1D1F{A,B} <: AbstractInterface1D\n    fw::A\n    ff::B\nend\n\n1D cell interface with 1 distribution function Note that deepcopy constructor is needed to work with StructArrays\n\n\n\n\n\n","category":"type"},{"location":"type_fvm/#KitBase.Interface1D2F","page":"FVM","title":"KitBase.Interface1D2F","text":"mutable struct Interface1D2F{A,B} <: AbstractInterface1D\n    fw::A\n    fh::B\n    fb::B\n\n    function Interface1D2F(w::AbstractArray, f::AbstractArray)\n        fw = zero(w)\n        fh = zero(f)\n        fb = zero(f)\n\n        new{typeof(fw),typeof(fh)}(fw, fh, fb)\n    end\nend\n\n1D cell interface with 2 distribution functions\n\n\n\n\n\n","category":"type"},{"location":"type_fvm/#KitBase.Interface1D3F","page":"FVM","title":"KitBase.Interface1D3F","text":"mutable struct Interface1D3F{A,B,C} <: AbstractInterface1D\n    fw::A\n    fh0::B\n    fh1::B\n    fh2::B\n    femL::C\n    femR::C\nend\n\n1D cell interface with 3 distribution functions\n\n\n\n\n\n","category":"type"},{"location":"type_fvm/#KitBase.Interface1D4F","page":"FVM","title":"KitBase.Interface1D4F","text":"mutable struct Interface1D4F{A,B,C} <: AbstractInterface1D\n    fw::A\n    fh0::B\n    fh1::B\n    fh2::B\n    fh3::B\n    femL::C\n    femR::C\nend\n\n1D cell interface with 4 distribution functions\n\n\n\n\n\n","category":"type"},{"location":"type_fvm/","page":"FVM","title":"FVM","text":"The 2D control volume structs are implemented as well.","category":"page"},{"location":"type_fvm/","page":"FVM","title":"FVM","text":"ControlVolume2D\nControlVolume2D1F\nControlVolume2D2F\nControlVolume2D3F","category":"page"},{"location":"type_fvm/#KitBase.ControlVolume2D","page":"FVM","title":"KitBase.ControlVolume2D","text":"mutable struct ControlVolume2D{F,A,B} <: AbstractControlVolume2D\n    x::F\n    y::F\n    dx::F\n    dy::F\n\n    w::A\n    prim::A\n    sw::B\nend\n\n2D control volume with no distribution function\n\n\n\n\n\n","category":"type"},{"location":"type_fvm/#KitBase.ControlVolume2D1F","page":"FVM","title":"KitBase.ControlVolume2D1F","text":"mutable struct ControlVolume2D1F{F,A,B,C,D} <: AbstractControlVolume2D\n    x::F\n    y::F\n    dx::F\n    dy::F\n\n    w::A\n    prim::A\n    sw::B\n\n    f::C\n    sf::D\nend\n\n2D control volume with 1 distribution function\n\n\n\n\n\n","category":"type"},{"location":"type_fvm/#KitBase.ControlVolume2D2F","page":"FVM","title":"KitBase.ControlVolume2D2F","text":"mutable struct ControlVolume2D2F{F,A,B,C,D} <: AbstractControlVolume2D\n    x::F\n    y::F\n    dx::F\n    dy::F\n\n    w::A\n    prim::A\n    sw::B\n\n    h::C\n    b::C\n    sh::D\n    sb::D\nend\n\n2D control volume with 2 distribution functions\n\n\n\n\n\n","category":"type"},{"location":"type_fvm/#KitBase.ControlVolume2D3F","page":"FVM","title":"KitBase.ControlVolume2D3F","text":"mutable struct ControlVolume2D3F{T1,T2,T3,T4,T5,T6,T7,T8} <: AbstractControlVolume2D\n    x::T1\n    y::T1\n    dx::T1\n    dy::T1\n\n    w::T2\n    prim::T2\n    sw::T3\n\n    h0::T4\n    h1::T4\n    h2::T4\n    sh0::T5\n    sh1::T5\n    sh2::T5\n\n    E::T6\n    B::T6\n    ϕ::T7\n    ψ::T7\n    lorenz::T8\nend\n\n2D control volume with 3 distribution functions\n\n\n\n\n\n","category":"type"},{"location":"type_fvm/","page":"FVM","title":"FVM","text":"The numerical fluxes are evaluated through AbstractInterface structs.","category":"page"},{"location":"type_fvm/","page":"FVM","title":"FVM","text":"Interface2D\nInterface2D1F\nInterface2D2F","category":"page"},{"location":"type_fvm/#KitBase.Interface2D","page":"FVM","title":"KitBase.Interface2D","text":"mutable struct Interface2D{A,B,C} <: AbstractInterface2D\n    len::A\n    n::B\n    fw::C\n\n    function Interface2D(L::Real, C::Real, S::Real, w::AbstractArray)\n        len = L\n        n = [C, S]\n\n        fw = zero(w)\n\n        new{typeof(len),typeof(n),typeof(fw)}(len, n, fw)\n    end\nend\n\n2D cell interface with no distribution function\n\n\n\n\n\n","category":"type"},{"location":"type_fvm/#KitBase.Interface2D1F","page":"FVM","title":"KitBase.Interface2D1F","text":"mutable struct Interface2D1F{A,B,C,D} <: AbstractInterface2D\n    len::A\n    n::B\n    fw::C\n    ff::D\n\n    function Interface2D1F(L::Real, C::Real, S::Real, w::AbstractArray, f::AbstractArray)\n        len = L\n        n = [C, S]\n\n        fw = zero(w)\n        ff = zero(f)\n\n        new{typeof(len),typeof(n),typeof(fw),typeof(ff)}(len, n, fw, ff)\n    end\nend\n\n2D cell interface with 1 distribution function\n\n\n\n\n\n","category":"type"},{"location":"type_fvm/#KitBase.Interface2D2F","page":"FVM","title":"KitBase.Interface2D2F","text":"mutable struct Interface2D2F{A,B,C,D} <: AbstractInterface2D\n    len::A\n    n::B\n    fw::C\n    fh::D\n    fb::D\n\n    function Interface2D2F(L::Real, C::Real, S::Real, w::AbstractArray, f::AbstractArray)\n        len = L\n        n = [C, S]\n\n        fw = zeros(eltype(w), axes(w))\n        fh = zeros(eltype(f), axes(f))\n        fb = zeros(eltype(f), axes(f))\n\n        new{typeof(len),typeof(n),typeof(fw),typeof(fh)}(len, n, fw, fh, fb)\n    end\nend\n\n2D cell interface with 2 distribution functions\n\n\n\n\n\n","category":"type"},{"location":"type_config/#Configuration-of-solver","page":"Configuration","title":"Configuration of solver","text":"","category":"section"},{"location":"type_config/","page":"Configuration","title":"Configuration","text":"Kinetic is organized with the data structures and methods of both generality and convenience.  While the low-level methods can be applied to multi-dimensional arrays directly, we provide a set of domain-specific structs that handles multiple dispatch in an elegant way.","category":"page"},{"location":"type_config/","page":"Configuration","title":"Configuration","text":"For a solver pending for execution, its configurations can be handled in a SolverSet <: AbstractSolverSet struct.","category":"page"},{"location":"type_config/","page":"Configuration","title":"Configuration","text":"SolverSet","category":"page"},{"location":"type_config/#KitBase.SolverSet","page":"Configuration","title":"KitBase.SolverSet","text":"struct SolverSet{\n    TS<:AbstractSetup,\n    TP<:AbstractPhysicalSpace,\n    TV<:Union{AbstractVelocitySpace,Nothing},\n    TG<:AbstractProperty,\n    TI<:Union{AbstractCondition,Nothing},\n    TO<:AbstractString,\n} <: AbstractSolverSet\n    # setup\n    set::TS\n    # physical space\n    pSpace::TP\n    # velocity space\n    vSpace::TV\n    # gas property\n    gas::TG\n    # initial and boundary condition\n    ib::TI\n    # file system\n    outputFolder::TO\nend\n\nStructure of solver setup\n\n\n\n\n\n","category":"type"},{"location":"type_config/","page":"Configuration","title":"Configuration","text":"It contains six fields:","category":"page"},{"location":"type_config/","page":"Configuration","title":"Configuration","text":"set: general setup of a simulation\npSpace: physical space settings\nvSpace: particle velocity space settings\ngas: properties of the simulated substance\nib: initial and boundary conditions\noutputFolder: file directory for the output results","category":"page"},{"location":"type_config/","page":"Configuration","title":"Configuration","text":"This struct plays an key role in the solution algorithm.","category":"page"},{"location":"solver_post/#Postprocess","page":"Postprocess","title":"Postprocess","text":"","category":"section"},{"location":"solver_post/","page":"Postprocess","title":"Postprocess","text":"The post-process solver handles the simulation data and visualization.","category":"page"},{"location":"solver_post/","page":"Postprocess","title":"Postprocess","text":"plot_line\nplot_contour\nwrite_jld","category":"page"},{"location":"solver_post/#KitBase.plot_line","page":"Postprocess","title":"KitBase.plot_line","text":"plot_line(KS, ctr; backend = :plots)\n\nPlot solution profiles\n\n\n\n\n\n","category":"function"},{"location":"solver_post/#KitBase.plot_contour","page":"Postprocess","title":"KitBase.plot_contour","text":"plot_contour(KS, ctr; backend = :plots)\n\nPlot solution contours\n\n\n\n\n\n","category":"function"},{"location":"solver_post/#KitBase.write_jld","page":"Postprocess","title":"KitBase.write_jld","text":"write_jld(KS, ctr, t)\n\nWrite data into JLD2\n\n\n\n\n\n","category":"function"},{"location":"physics/#Basic-Physics","page":"Physics","title":"Basic Physics","text":"","category":"section"},{"location":"physics/#Microscopic-formulation","page":"Physics","title":"Microscopic formulation","text":"","category":"section"},{"location":"physics/","page":"Physics","title":"Physics","text":"The physical world shows a diverse set of behaviors on different characteristic scales. Consider the molecular motion of gases as an example. Down to the finest scale of a many-particle system, the Newton's second law depicts particle motions via","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"mathbfF = m mathbfa","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"As a first order system it reads","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"fracd mathbf xdt = mathbf v  fracd mathbf vdt = fracmathbf Fm","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"where mathbf F is external force and m is particle mass.","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"An intuitive numerical algorithm is to get the numerous particles on board and track the trajectories of them. A typical example is the Molecular Dynamics. This is not going to be efficient since there are more than 2e25 molecules per cubic meter in normal atmosphere, and things get even more complicated when you count on the N-body interactions all the time. Some methods have been proposed to simplify the computation. As an example, the Direct simulation Monte Carlo employs certain molecular models and conduct the intermolecular collisions in a stochastic manner. It significantly reduces the computational cost, while the trade-off is the artificial fluctuations. Many realizations must be simulated successively to average the solutions and reduce the errors.","category":"page"},{"location":"physics/#Mesoscopic-formulation","page":"Physics","title":"Mesoscopic formulation","text":"","category":"section"},{"location":"physics/","page":"Physics","title":"Physics","text":"An alternative strategy is made from ensemble averaging, where the coarse-grained modeling is used to provide a bottom-up view. At the mean free path and collision time scale of molecules, particles travel freely during most of time with mild intermolecular collisions. Such dynamics can be described with an operator splitting approach, i.e. the kinetic transport equation","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"fracpartial fpartial t+ mathbf v cdot nabla_mathbf x f + mathbf a cdot nabla_mathbf v f = Q(f)","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"where f denotes the probability of finding a particle at certain location in phase space. The left-hand side of the equation above model the transport phenomena due to the inhomogeneous distribution of particles and external force field, while the right-hand side depicts intermolecular collision. Different collision models can be inserted into such equation. If the particles only collide with a background material one obtains linear Boltzmann collision operator","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"Q(f)=int_mathbb R^3 mathcal B(mathbf v_* mathbf v) left f(mathbf v_*)-f(mathbf v)right dmathbf v_*","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"where the collision kernel mathcal B models the strength of collisions at different velocities.  If the interactions among particles are considered, the collision operator becomes nonlinear.  For example, the two-body collision results in nonlinear Boltzmann equation","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"Q(f)=int_mathbb R^3 int_mathcal S^2 mathcal B(cos beta mathbfv-mathbfv_*) left f(mathbf v)f(mathbf v_*)-f(mathbf v)f(mathbf v_*)right dmathbf Omega dmathbf v_*","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"To solve the Boltzmann equation, a discretized phase space needs to be introduced and the solution algorithm is called discrete ordinates method or discrete velocity method. Due to the complicated fivefold integral in the nonlinear Boltzmann collision operator, sometimes it is replaced by the simplified models in the discrete velocity method, e.g. the relaxation model","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"Q(f) = nu (mathcal M - f)","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"From the H-theorem, we learn that an isolated system evolves in the direction with entropy increment. The maximal entropy status corresponds to the well-known Maxwellian distribution","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"mathcal M = nleft(fracm2pi k Tright)^D2exp left( -fracm2kT (mathbf v - mathbf V)^2 right)","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"where k is the Boltzmann constant, mathbf V and T are the bulk velocity and temperature. The Boltzmann dynamics can be projected onto lower dimensionality. For example, with one-dimensional velocity space formulation, the high-dimensional particle distribution can be integrated with respect to the rest coordinates as","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"h_0 = int_-infty^infty int_-infty^infty f d v dw  h_1 = int_-infty^infty int_-infty^infty (v^2+w^2) f dv dw","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"where h_0 and h_1 are called reduced distribution functions and form a so-called 1d2f1v system.","category":"page"},{"location":"physics/#Macroscopic-formulation","page":"Physics","title":"Macroscopic formulation","text":"","category":"section"},{"location":"physics/","page":"Physics","title":"Physics","text":"Meanwhile, with the enlargement of modeling scale to a macroscopic hydrodynamic level, the accumulating effect of particle collisions results in an equalization of local temperature and velocity, where the moderate non-equilibrium effects can be well described by viscous transport, heat conduction and mass diffusion, i.e., the so called transport phenomena.  Large-scale dynamics presents the property of waves, and the macroscopic transport equations can be constructed to describe the bulk behaviors of fluids. Typical examples are the Euler and Navier-Stokes equations","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"fracpartial mathbf Wpartial t + nabla_mathbf x cdot mathbf F = mathbf S","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"From microscopic particle transport to macroscopic fluid motion, there is a continuous variation of flow dynamics.  We pay special attentions to Hilbert's sixth problem, i.e. building the numerical passage between the kinetic theory of gases and continuum mechanics. ","category":"page"},{"location":"fortran2/#Benchmark","page":"Benchmark","title":"Benchmark","text":"","category":"section"},{"location":"fortran2/","page":"Benchmark","title":"Benchmark","text":"Here we provide a benchmark to identity the performance variation between Julia and Fortran implementations. For brevity, we direct make use of the dynamic library kitmod.so by ccall function in Julia, and compare the efficiency of computing numerical fluxes by BenchmarkTools.jl.","category":"page"},{"location":"fortran2/","page":"Benchmark","title":"Benchmark","text":"using Kinetic, BenchmarkTools\n\nbegin\n    u = collect(-5.0:0.1:5.0)\n    nu = length(u)\n    weights = ones(nu) .* 0.5\n\n    fw = zeros(3)\n    fh = zeros(nu)\n    fb = zeros(nu)\n\n    inK = 2\n    γ = 5.0 / 3.0\n    primL = [1., 0., 1.]\n    wL = prim_conserve(primL, γ)\n    hL = maxwellian(u, primL) |> Array;\n    bL = hL .* 2 ./ (2.)\n    shL = zeros(nu)\n    sbL = zeros(nu)\n    lenL = 0.1\n\n    primR = [0.5, 0., 1.]\n    wR = prim_conserve(primR, γ)\n    hR = maxwellian(u, primR) |> Array;\n    bR = hR .* 2 ./ (2.)\n    shR = zeros(nu)\n    sbR = zeros(nu)\n    lenR = 0.1\n\n    muref = 0.001\n    omega = 0.72\n    prandtl = 1.0\n    dt = 1e-4\nend\n\n#--- kfvs ---#\n@btime ccall(\n    (:__kinetic_MOD_flux_kfvs_2f1v, \"kitmod.so\"),\n    Nothing,\n    (\n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64},\n        Ref{Float64}, \n        Ref{Int}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64},\n        Ref{Float64},\n    ),\n    fw,\n    fh,\n    fb,\n    hL,\n    bL,\n    hR,\n    bR,\n    u,\n    weights,\n    nu,\n    dt,\n    shL,\n    sbL,\n    shR,\n    sbR,\n)\n\n@btime flux_kfvs!(fw, fh, fb, hL, bL, hR, bR, u, weights, dt, shL, sbL, shR, sbR)\n\n#--- ugks ---#\n@btime ccall(\n    (:__kinetic_MOD_flux_ugks_2f1v, \"kitmod.so\"),\n    Nothing,\n    (\n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64},\n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Int}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64},\n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64}, \n        Ref{Float64},\n    ),\n    fw,\n    fh,\n    fb,\n    wL,\n    hL,\n    bL,\n    wR,\n    hR,\n    bR,\n    u,\n    weights,\n    nu,\n    inK,\n    γ,\n    muref,\n    omega,\n    prandtl,\n    dt,\n    lenL,\n    lenR,\n    shL,\n    sbL,\n    shR,\n    sbR,\n)\n\n@btime flux_ugks!(fw, fh, fb, wL, hL, bL, wR, hR, bR, u, weights, inK, γ, muref, omega, prandtl, dt, lenL, lenR, shL, sbL, shR, sbR)\n","category":"page"},{"location":"fortran2/","page":"Benchmark","title":"Benchmark","text":"The results on a intel NUC8i7BEH with i7-8559U with 101 velocity points is as follows","category":"page"},{"location":"fortran2/","page":"Benchmark","title":"Benchmark","text":"Kinetic.jl","category":"page"},{"location":"fortran2/","page":"Benchmark","title":"Benchmark","text":"KFVS flux ~ 6.747 μs (13 allocations: 11.38 KiB)\nUGKS flux ~ 13.344 μs (123 allocations: 20.94 KiB)","category":"page"},{"location":"fortran2/","page":"Benchmark","title":"Benchmark","text":"KitFort.jl","category":"page"},{"location":"fortran2/","page":"Benchmark","title":"Benchmark","text":"KFVS flux ~ 5.421 μs (37 allocations: 800 bytes)\nUGKS flux ~ 11.413 μs (55 allocations: 1.09 KiB)","category":"page"},{"location":"fortran2/","page":"Benchmark","title":"Benchmark","text":"As presented, there is an improvement on efficiency by around 15%.","category":"page"},{"location":"eg_shock/#Shock-tube-problem","page":"Shock tube","title":"Shock tube problem","text":"","category":"section"},{"location":"eg_shock/","page":"Shock tube","title":"Shock tube","text":"We then use the Boltzmann equation to solve the shock tube problem in gas dynamics. It's a two dimensional problem, with one in physical domain x and another in particle velocity domain u. First let us prepare the configuration file as","category":"page"},{"location":"eg_shock/","page":"Shock tube","title":"Shock tube","text":"# case\nmatter = gas\ncase = sod\nspace = 1d2f1v\nnSpecies = 1\nflux = kfvs\ncollision = bgk\ninterpOrder = 2\nlimiter = vanleer\nboundary = fix\ncfl = 0.5\nmaxTime = 0.2\n\n# physical space\nx0 = 0\nx1 = 1\nnx = 200\npMeshType = uniform\nnxg = 1\n\n# velocity space\nvMeshType = rectangle\numin = -5\numax = 5\nnu = 28\nnug = 0\n\n# gas\nknudsen = 0.0001\nmach = 0.0\nprandtl = 1\ninK = 2\nomega = 0.81\nalphaRef = 1.0\nomegaRef = 0.5","category":"page"},{"location":"eg_shock/","page":"Shock tube","title":"Shock tube","text":"The configuration file can be understood as follows:","category":"page"},{"location":"eg_shock/","page":"Shock tube","title":"Shock tube","text":"The simulation case is the standard Sod shock tube\nA phase space in 1D physical and 1D velocity space is created with two particle distribution functions inside\nThe numerical flux function is the kinetic flux vector splitting method and the collision term uses the BGK relaxation\nThe reconstruction step employs van Leer limiter to create 2nd-order interpolation\nThe two boundaries are fixed with Dirichlet boundary condition\nThe timestep is determined with a CFL number of 0.5\nThe maximum simulation time is 0.2\nThe physical space spans in [0, 1] with 200 uniform cells\nThe velocity space spans in [-5, 5] with 28 uniform cells\nThe reference Knudsen number is set as 1e-4\nThe reference Mach number is absent\nThe reference Prandtl number is 1\nThe gas molecule contains two internal degrees of freedom\nThe viscosity is evaluated with the following formulas","category":"page"},{"location":"eg_shock/","page":"Shock tube","title":"Shock tube","text":"mu = mu_ref left(fracTT_refright)^omega","category":"page"},{"location":"eg_shock/","page":"Shock tube","title":"Shock tube","text":"mu_ref=frac5(alpha+1)(alpha+2) sqrtpi4 alpha(5-2 omega)(7-2 omega) Kn_ref","category":"page"},{"location":"eg_shock/","page":"Shock tube","title":"Shock tube","text":"The configuration file directly generate variables during runtime via meta-programming in Julia, and it can be stored in any text format (txt, toml, cfg, etc.).  For example, if config.txt is created,  we then execute the following codes to conduct a simulation","category":"page"},{"location":"eg_shock/","page":"Shock tube","title":"Shock tube","text":"using Kinetic\nset, ctr, face, t = initialize(\"config.txt\")\nt = solve!(set, ctr, face, t)","category":"page"},{"location":"eg_shock/","page":"Shock tube","title":"Shock tube","text":"The computational setup is stored in set and the control volume solutions are stored in ctr and face.  The high-level solver solve! is equivalent as the following low-level procedures","category":"page"},{"location":"eg_shock/","page":"Shock tube","title":"Shock tube","text":"dt = timestep(ks, ctr, t)\nnt = Int(floor(ks.set.maxTime / dt))\nres = zeros(3)\nfor iter = 1:nt\n    reconstruct!(ks, ctr)\n    evolve!(ks, ctr, face, dt)\n    update!(ks, ctr, face, dt, res)\nend","category":"page"},{"location":"eg_shock/","page":"Shock tube","title":"Shock tube","text":"The result can be visualized with built-in function plot_line, which presents the profiles of gas density, velocity and temperature inside the tube.","category":"page"},{"location":"eg_shock/","page":"Shock tube","title":"Shock tube","text":"plot_line(set, ctr)","category":"page"},{"location":"eg_shock/","page":"Shock tube","title":"Shock tube","text":"(Image: )","category":"page"},{"location":"kitml2/#Universal-Boltzmann-equation","page":"UBE","title":"Universal Boltzmann equation","text":"","category":"section"},{"location":"kitml2/","page":"UBE","title":"UBE","text":"In the following, we present a universal differential equation strategy to construct the neural network enhanced Boltzmann equation. The complicated fivefold integral operator is replaced by a combination of relaxation and neural models. It promises a completely differential structure and thus the neural ODE type training and computing becomes possible. The approach reduces the computational cost up to three orders of magnitude and preserves the perfect accuracy. The detailed theory and implementation can be found in Tianbai Xiao and Martin Frank, Using neural networks to accelerate the solution of the Boltzmann equation.","category":"page"},{"location":"kitml2/","page":"UBE","title":"UBE","text":"First we load all the packages needed and set up the configurations.","category":"page"},{"location":"kitml2/","page":"UBE","title":"UBE","text":"using OrdinaryDiffEq, Flux, DiffEqFlux, Plots\nusing KitBase, KitML\n\nbegin\n    case = \"homogeneous\"\n    maxTime = 3\n    tlen = 16\n    u0 = -5\n    u1 = 5\n    nu = 80\n    nug = 0\n    v0 = -5\n    v1 = 5\n    nv = 28\n    nvg = 0\n    w0 = -5\n    w1 = 5\n    nw = 28\n    nwg = 0\n    vMeshType = \"rectangle\"\n    nm = 5\n    knudsen = 1\n    inK = 0\n    alpha = 1.0\n    omega = 0.5\n    nh = 8\nend","category":"page"},{"location":"kitml2/","page":"UBE","title":"UBE","text":"The dataset is produced by the fast spectral method, which solves the nonlinear Boltzmann integral with fast Fourier transformation.","category":"page"},{"location":"kitml2/","page":"UBE","title":"UBE","text":"begin\n    tspan = (0.0, maxTime)\n    tran = linspace(tspan[1], tspan[2], tlen)\n    γ = heat_capacity_ratio(inK, 3)\n    vSpace = VSpace3D(u0, u1, nu, v0, v1, nv, w0, w1, nw, vMeshType)\n\n    f0 =\n        Float32.(\n            0.5 * (1 / π)^1.5 .*\n            (exp.(-(vSpace.u .- 0.99) .^ 2) .+ exp.(-(vSpace.u .+ 0.99) .^ 2)) .*\n            exp.(-vSpace.v .^ 2) .* exp.(-vSpace.w .^ 2),\n        ) |> Array\n    prim0 =\n        conserve_prim(moments_conserve(f0, vSpace.u, vSpace.v, vSpace.w, vSpace.weights), γ)\n    M0 = Float32.(maxwellian(vSpace.u, vSpace.v, vSpace.w, prim0)) |> Array\n\n    mu_ref = ref_vhs_vis(knudsen, alpha, omega)\n    kn_bzm = hs_boltz_kn(mu_ref, 1.0)\n    τ0 = mu_ref * 2.0 * prim0[end]^(0.5) / prim0[1]\n\n    phi, psi, phipsi = kernel_mode(\n        nm,\n        vSpace.u1,\n        vSpace.v1,\n        vSpace.w1,\n        vSpace.du[1, 1, 1],\n        vSpace.dv[1, 1, 1],\n        vSpace.dw[1, 1, 1],\n        vSpace.nu,\n        vSpace.nv,\n        vSpace.nw,\n        alpha,\n    )\n\n    # Boltzmann\n    prob = ODEProblem(boltzmann_ode!, f0, tspan, [kn_bzm, nm, phi, psi, phipsi])\n    data_boltz = solve(prob, Tsit5(), saveat = tran) |> Array\n\n    # BGK\n    prob1 = ODEProblem(bgk_ode!, f0, tspan, [M0, τ0])\n    data_bgk = solve(prob1, Tsit5(), saveat = tran) |> Array\n\n\n    data_boltz_1D = zeros(Float32, axes(data_boltz, 1), axes(data_boltz, 4))\n    data_bgk_1D = zeros(Float32, axes(data_bgk, 1), axes(data_bgk, 4))\n    for j in axes(data_boltz_1D, 2)\n        data_boltz_1D[:, j] .=\n            reduce_distribution(data_boltz[:, :, :, j], vSpace.weights[1, :, :])\n        data_bgk_1D[:, j] .=\n            reduce_distribution(data_bgk[:, :, :, j], vSpace.weights[1, :, :])\n    end\n    f0_1D = reduce_distribution(f0, vSpace.weights[1, :, :])\n    M0_1D = reduce_distribution(M0, vSpace.weights[1, :, :])\n\n    X = Array{Float32}(undef, vSpace.nu, 1)\n    for i in axes(X, 2)\n        X[:, i] .= f0_1D\n    end\n    Y = Array{Float32}(undef, vSpace.nu, 1, tlen)\n    for i in axes(Y, 2)\n        Y[:, i, :] .= data_boltz_1D\n    end\n    M = Array{Float32}(undef, nu, size(X, 2))\n    for i in axes(M, 2)\n        M[:, i] .= M0_1D\n    end\n    τ = Array{Float32}(undef, 1, size(X, 2))\n    for i in axes(τ, 2)\n        τ[1, i] = τ0\n    end\nend","category":"page"},{"location":"kitml2/","page":"UBE","title":"UBE","text":"Then we define the neural network and construct the unified model with mechanical and neural parts. The training is conducted by DiffEqFlux.jl with ADAM optimizer.","category":"page"},{"location":"kitml2/","page":"UBE","title":"UBE","text":"begin\n    model_univ = DiffEqFlux.FastChain(\n        DiffEqFlux.FastDense(nu, nu * nh, tanh),\n        DiffEqFlux.FastDense(nu * nh, nu),\n    )\n    p_model = DiffEqFlux.initial_params(model_univ)\n\n    function dfdt(f, p, t)\n        df = (M .- f) ./ τ .+ model_univ(M .- f, p)\n    end\n    prob_ube = ODEProblem(dfdt, X, tspan, p_model)\n\n    function loss(p)\n        sol_ube = solve(prob_ube, Midpoint(), u0 = X, p = p, saveat = tran)\n        loss = sum(abs2, Array(sol_ube) .- Y)\n\n        return loss\n    end\n\n    his = []\n    cb = function (p, l)\n        display(l)\n        push!(his, l)\n        return false\n    end\nend\n\nres = DiffEqFlux.sciml_train(loss, p_model, ADAM(), cb = cb, maxiters = 200)\nres = DiffEqFlux.sciml_train(loss, res.minimizer, ADAM(), cb = cb, maxiters = 200)","category":"page"},{"location":"kitml2/","page":"UBE","title":"UBE","text":"Once we have trained a hybrid Boltzmann collision term, we could solve it as a normal differential equation with any desirable solvers. Consider the Midpoint rule as an example, the solution algorithm and visualization can be organized.","category":"page"},{"location":"kitml2/","page":"UBE","title":"UBE","text":"ube = ODEProblem(KitML.ube_dfdt, f0_1D, tspan, [M0_1D, τ0, (model_univ, res.minimizer)]);\nsol = solve(\n    ube,\n    Midpoint(),\n    u0 = f0_1D,\n    p = [M0_1D, τ0, (model_univ, res.minimizer)],\n    saveat = tran,\n);\n\nplot(\n    vSpace.u[:, vSpace.nv÷2, vSpace.nw÷2],\n    data_boltz_1D[:, 1],\n    lw = 2,\n    label = \"Initial\",\n    color = :gray32,\n    xlabel = \"u\",\n    ylabel = \"particle distribution\",\n)\nplot!(\n    vSpace.u[:, vSpace.nv÷2, vSpace.nw÷2],\n    data_boltz_1D[:, 2],\n    lw = 2,\n    label = \"Boltzmann\",\n    color = 1,\n)\nplot!(\n    vSpace.u[:, vSpace.nv÷2, vSpace.nw÷2],\n    data_bgk_1D[:, 2],\n    lw = 2,\n    line = :dash,\n    label = \"BGK\",\n    color = 2,\n)\nplot!(\n    vSpace.u[:, vSpace.nv÷2, vSpace.nw÷2],\n    M0_1D,\n    lw = 2,\n    label = \"Maxwellian\",\n    color = 10,\n)\nscatter!(vSpace.u[:, vSpace.nv÷2, vSpace.nw÷2], sol.u[2], lw = 2, label = \"UBE\", color = 3)","category":"page"},{"location":"kitml2/","page":"UBE","title":"UBE","text":"(Image: )","category":"page"},{"location":"solver_pre/#Preprocess","page":"Preprocess","title":"Preprocess","text":"","category":"section"},{"location":"solver_pre/","page":"Preprocess","title":"Preprocess","text":"initialize","category":"page"},{"location":"solver_pre/#KitBase.initialize","page":"Preprocess","title":"KitBase.initialize","text":"initialize(configfilename::T) where {T<:AbstractString}\ninitialize(config::T) where {T<:AbstractDict}\n\nInitialize solver from input file or dictionary. This can also be done from a Julia script directly.\n\n\n\n\n\n","category":"function"},{"location":"solver_pre/","page":"Preprocess","title":"Preprocess","text":"The pre-process solver initializes the simulation that returns solver set, control volumes, interfaces, and current time. It could be a new simulation or restart of an interrupted one.","category":"page"},{"location":"solver_pre/","page":"Preprocess","title":"Preprocess","text":"new run: .txt / .cfg / .toml / etc.\nrestart: .jld2","category":"page"},{"location":"eg_cavity/#Lid-driven-cavity","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"","category":"section"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"We then show the lid-driven cavity. It's a four dimensional problem, with two in physical domain (xy) and another in particle velocity domain (uv). Similarly, we prepare the configuration file as","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"# setup\nmatter = gas\ncase = cavity\nspace = 2d2f2v\nflux = kfvs\ncollision = bgk\nnSpecies = 1\ninterpOrder = 2\nlimiter = vanleer\nboundary = maxwell\ncfl = 0.8\nmaxTime = 5.0\n\n# phase space\nx0 = 0.0\nx1 = 1.0\nnx = 45\ny0 = 0.0\ny1 = 1.0\nny = 45\npMeshType = uniform\nnxg = 0\nnyg = 0\n\n# velocity space\numin = -5.0\numax = 5.0\nnu = 28\nvmin = -5.0\nvmax = 5.0\nnv = 28\nvMeshType = rectangle\nnug = 0\nnvg = 0\n\n# gas\nknudsen = 0.075\nmach = 0.0\nprandtl = 1.0\ninK = 1.0\nomega = 0.72\nalphaRef = 1.0\nomegaRef = 0.5\n\n# boundary\nuLid = 0.15\nvLid = 0.0\ntLid = 1.0","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"We then execute the following codes to conduct a simulation","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"using Kinetic\nks, ctr, a1face, a2face, t = initialize(\"config.txt\")\nt = solve!(ks, ctr, a1face, a2face, t)","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"The high-level solver solve! is equivalent as the following low-level procedures","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"using ProgressMeter\nres = zeros(4)\ndt = timestep(ks, ctr, t)\nnt = floor(ks.set.maxTime / dt) |> Int\n@showprogress for iter = 1:nt\n    reconstruct!(ks, ctr)\n    evolve!(ks, ctr, a1face, a2face, dt; mode = Symbol(ks.set.flux), bc = Symbol(ks.set.boundary))\n    update!(ks, ctr, a1face, a2face, dt, res; coll = Symbol(ks.set.collision), bc = Symbol(ks.set.boundary))\nend","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"It can be further expanded into the lower-level backend.","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"# lower-level backend \n@showprogress for iter = 1:nt\n    # horizontal flux\n    @inbounds Threads.@threads for j = 1:ks.pSpace.ny\n        for i = 2:ks.pSpace.nx\n            KitBase.flux_kfvs!(\n                a1face[i, j].fw,\n                a1face[i, j].fh,\n                a1face[i, j].fb,\n                ctr[i-1, j].h,\n                ctr[i-1, j].b,\n                ctr[i, j].h,\n                ctr[i, j].b,\n                ks.vSpace.u,\n                ks.vSpace.v,\n                ks.vSpace.weights,\n                dt,\n                a1face[i, j].len,\n            )\n        end\n    end\n    \n    # vertical flux\n    vn = ks.vSpace.v\n    vt = -ks.vSpace.u\n    @inbounds Threads.@threads for j = 2:ks.pSpace.ny\n        for i = 1:ks.pSpace.nx\n            KitBase.flux_kfvs!(\n                a2face[i, j].fw,\n                a2face[i, j].fh,\n                a2face[i, j].fb,\n                ctr[i, j-1].h,\n                ctr[i, j-1].b,\n                ctr[i, j].h,\n                ctr[i, j].b,\n                vn,\n                vt,\n                ks.vSpace.weights,\n                dt,\n                a2face[i, j].len,\n            )\n            a2face[i, j].fw .= KitBase.global_frame(a2face[i, j].fw, 0., 1.)\n        end\n    end\n    \n    # boundary flux\n    @inbounds Threads.@threads for j = 1:ks.pSpace.ny\n        KitBase.flux_boundary_maxwell!(\n            a1face[1, j].fw,\n            a1face[1, j].fh,\n            a1face[1, j].fb,\n            ks.ib.bcL,\n            ctr[1, j].h,\n            ctr[1, j].b,\n            ks.vSpace.u,\n            ks.vSpace.v,\n            ks.vSpace.weights,\n            ks.gas.K,\n            dt,\n            ctr[1, j].dy,\n            1.,\n        )\n\n        KitBase.flux_boundary_maxwell!(\n            a1face[ks.pSpace.nx+1, j].fw,\n            a1face[ks.pSpace.nx+1, j].fh,\n            a1face[ks.pSpace.nx+1, j].fb,\n            ks.ib.bcR,\n            ctr[ks.pSpace.nx, j].h,\n            ctr[ks.pSpace.nx, j].b,\n            ks.vSpace.u,\n            ks.vSpace.v,\n            ks.vSpace.weights,\n            ks.gas.K,\n            dt,\n            ctr[ks.pSpace.nx, j].dy,\n            -1.,\n        )\n    end\n    \n    @inbounds Threads.@threads for i = 1:ks.pSpace.nx\n        KitBase.flux_boundary_maxwell!(\n            a2face[i, 1].fw,\n            a2face[i, 1].fh,\n            a2face[i, 1].fb,\n            ks.ib.bcD,\n            ctr[i, 1].h,\n            ctr[i, 1].b,\n            vn,\n            vt,\n            ks.vSpace.weights,\n            ks.gas.K,\n            dt,\n            ctr[i, 1].dx,\n            1,\n        )\n        a2face[i, 1].fw .= KitBase.global_frame(a2face[i, 1].fw, 0., 1.)\n        \n        KitBase.flux_boundary_maxwell!(\n            a2face[i, ks.pSpace.ny+1].fw,\n            a2face[i, ks.pSpace.ny+1].fh,\n            a2face[i, ks.pSpace.ny+1].fb,\n            [1., 0.0, -0.15, 1.0],\n            ctr[i, ks.pSpace.ny].h,\n            ctr[i, ks.pSpace.ny].b,\n            vn,\n            vt,\n            ks.vSpace.weights,\n            ks.gas.K,\n            dt,\n            ctr[i, ks.pSpace.ny].dy,\n            -1,\n        )\n        a2face[i, ks.pSpace.ny+1].fw .= KitBase.global_frame(\n            a2face[i, ks.pSpace.ny+1].fw,\n            0.,\n            1.,\n        )\n    end\n\n    # update\n    @inbounds for j = 1:ks.pSpace.ny\n        for i = 1:ks.pSpace.nx\n            KitBase.step!(\n                ctr[i, j].w,\n                ctr[i, j].prim,\n                ctr[i, j].h,\n                ctr[i, j].b,\n                a1face[i, j].fw,\n                a1face[i, j].fh,\n                a1face[i, j].fb,\n                a1face[i+1, j].fw,\n                a1face[i+1, j].fh,\n                a1face[i+1, j].fb,\n                a2face[i, j].fw,\n                a2face[i, j].fh,\n                a2face[i, j].fb,\n                a2face[i, j+1].fw,\n                a2face[i, j+1].fh,\n                a2face[i, j+1].fb,\n                ks.vSpace.u,\n                ks.vSpace.v,\n                ks.vSpace.weights,\n                ks.gas.K,\n                ks.gas.γ,\n                ks.gas.μᵣ,\n                ks.gas.ω,\n                ks.gas.Pr,\n                ctr[i, j].dx * ctr[i, j].dy,\n                dt,\n                zeros(4),\n                zeros(4),\n                :bgk,\n            )\n        end\n    end\nend","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"The result can be visualized with built-in function plot_contour, which presents the contours of gas density, U-velocity, V-velocity and temperature inside the cavity.","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"KitBase.plot_contour(ks, ctr)","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"(Image: )","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"It is equivalent as the following low-level backend.","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"begin\n    using Plots\n    sol = zeros(4, ks.pSpace.nx, ks.pSpace.ny)\n    for i in axes(sol, 2)\n        for j in axes(sol, 3)\n            sol[1:3, i, j] .= ctr[i, j].prim[1:3]\n            sol[4, i, j] = 1.0 / ctr[i, j].prim[4]\n        end\n    end\n    contourf(ks.pSpace.x[1:ks.pSpace.nx, 1], ks.pSpace.y[1, 1:ks.pSpace.ny], sol[3, :, :]')\nend","category":"page"},{"location":"python/#Calling-from-Python","page":"Python","title":"Calling from Python","text":"","category":"section"},{"location":"python/","page":"Python","title":"Python","text":"For maximum convenience, a wrapper kineticpy has been built to locate all the methods from Python.","category":"page"},{"location":"python/#How-to-use?","page":"Python","title":"How to use?","text":"","category":"section"},{"location":"python/","page":"Python","title":"Python","text":"Let's start by cloning the repository and changing into the directory.","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"git clone https://github.com/vavrines/kineticpy.git\ncd kineticpy","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"Next, we start python. The Julia main module can be installed and initialized by","category":"page"},{"location":"python/","page":"Python","title":"Python","text":">>> import kineticpy\n>>> kineticpy.install()","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"The basic structs and methods are stored in the base module, and can be imported via","category":"page"},{"location":"python/","page":"Python","title":"Python","text":">>> from kineticpy import base","category":"page"},{"location":"python/#Example","page":"Python","title":"Example","text":"","category":"section"},{"location":"python/","page":"Python","title":"Python","text":"We provide some quick tutorial here for kineticpy.","category":"page"},{"location":"python/","page":"Python","title":"Python","text":">>> from kineticpy import base\n>>> import numpy as np\n\n>>> u = np.linspace(-5, 5, 28) # velocity space\n>>> prim_var = np.array([1.0, 0.0, 1.0]) # primitive flow variables\n>>> M = base.maxwellian(u, prim_var) # compute Maxwellian distribution\n>>> M.view()\n\narray([7.83543327e-12, 2.77323769e-10, 7.46041809e-09, 1.52542631e-07,\n       2.37067103e-06, 2.80029217e-05, 2.51412806e-04, 1.71562923e-03,\n       8.89839075e-03, 3.50793472e-02, 1.05109877e-01, 2.39379825e-01,\n       4.14365469e-01, 5.45169515e-01, 5.45169515e-01, 4.14365469e-01,\n       2.39379825e-01, 1.05109877e-01, 3.50793472e-02, 8.89839075e-03,\n       1.71562923e-03, 2.51412806e-04, 2.80029217e-05, 2.37067103e-06,\n       1.52542631e-07, 7.46041809e-09, 2.77323769e-10, 7.83543327e-12])","category":"page"},{"location":"#Kinetic.jl","page":"Home","title":"Kinetic.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetic is a portable Julia toolbox for the study of computational fluid dynamics and scientific machine learning. The default module consists of KitBase.jl with basic physics and KitML.jl with neural dynamics.  The high-performance Fortran library KitFort.jl can be manually imported when the ultimate efficiency is pursued. Besides, a wrapper kineticpy is built to locate the data hierarchies and methods in Python.","category":"page"},{"location":"#Scope-of-application","page":"Home","title":"Scope of application","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetic is interested in the evolution of many-particle systems, e.g. gases, photons, plasmas, neutrons, electrons, etc. Based on the finite volume method (FVM), it provides an efficient tool where 1-3 dimensional theoretical modeling and numerical simulation can be conducted. Any advection-diffusion type equation can be hooked within the framework. Special attention has been paid to the kinetic theory and the Boltzmann-type equations, which depicts the time-space evolution of particles via ensemble averaging at the mesoscopic level. A partial list of current supported models and equations is as follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"linear Boltzmann equation\nnonlinear Boltzmann equation\nmulti-component Boltzmann equation\nFokker-Planck-Landau equation\ndirect simulation Monte Carlo\nadvection-diffusion equation\nBurgers' equation\nEuler equations\nNavier-Stokes equations\nExtended hydrodynamical equations from asymptotic expansion\nMagnetohydrodynamical equations\nMaxwell's equations","category":"page"},{"location":"#Design-philosophy","page":"Home","title":"Design philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The code hierarchy is designed as intuitive and neat as possible. It's dedicated to providing a friendly interface for educational usage in kinetic theory and rich functionality for scientific research. Benefiting from the brilliant expressiveness and low-overhead abstraction provided by the Julia programming language,  we provide different levels of APIs to allow the users to focus on physics and to cooperate with the existing packages in the Julia ecosystem.","category":"page"},{"location":"#What-is-new?","page":"Home","title":"What is new?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Finite volume method is a proven approach for simulating conservation laws. Compared with the existing open-source softwares, e.g. OpenFOAM, SU2 and Clawpack,  Kinetic holds the novelty through the following points:","category":"page"},{"location":"","page":"Home","title":"Home","text":"100% Julia stack that encounters no two-language problem\nComprehensive support for kinetic theory and phase-space equations\nLightweight design to ensure the flexibility for secondary development\nClosely coupling with scientific machine learning","category":"page"},{"location":"#How-to-get-help?","page":"Home","title":"How to get help?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are interested in using Kinetic.jl or are trying to figure out how to use it, please feel free to get in touch and raise questions. Do open an issue or pull request if you have questions, suggestions or solutions.","category":"page"},{"location":"solver_reconstruction/#Reconstruction","page":"Reconstruction","title":"Reconstruction","text":"","category":"section"},{"location":"solver_reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"reconstruct!","category":"page"},{"location":"solver_reconstruction/#KitBase.reconstruct!","page":"Reconstruction","title":"KitBase.reconstruct!","text":"reconstruct!(KS::SolverSet, ctr::AbstractArray)\n\nReconstruct solutions in cells\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"The reconstruction solver interpolates piecewise solutions with the desirable order of accuracy. The reconstruction stencils can be based on 2 or 3 cells","category":"page"},{"location":"solver_reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"reconstruct2\nreconstruct2!\nreconstruct3\nreconstruct3!","category":"page"},{"location":"solver_reconstruction/#KitBase.reconstruct2","page":"Reconstruction","title":"KitBase.reconstruct2","text":"reconstruct2(wL, wR, Δx)\nreconstruct2(wL::T, wR::T, Δx) where {T<:AbstractArray{<:Real,1}}\nreconstruct2(wL::T, wR::T, Δx) where {T<:AbstractArray{<:Real,2}}\nreconstruct2(wL::T, wR::T, Δx) where {T<:AbstractArray{<:Real,3}}\n\nTwo-cell reconstruction\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.reconstruct2!","page":"Reconstruction","title":"KitBase.reconstruct2!","text":"reconstruct2!(\n    sw::X,\n    wL::Y,\n    wR::Y,\n    Δx,\n) where {X<:AbstractArray{<:AbstractFloat,1},Y<:AbstractArray{<:Real,1}}\n\nreconstruct2!(\n    sw::X,\n    wL::Y,\n    wR::Y,\n    Δx,\n) where {X<:AbstractArray{<:AbstractFloat,2},Y<:AbstractArray{<:Real,2}}\n\nreconstruct2!(\n    sw::X,\n    wL::Y,\n    wR::Y,\n    Δx,\n) where {X<:AbstractArray{<:AbstractFloat,3},Y<:AbstractArray{<:Real,3}}\n\nTwo-cell reconstruction\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.reconstruct3","page":"Reconstruction","title":"KitBase.reconstruct3","text":"reconstruct3(\n    wL::T,\n    wN::T,\n    wR::T,\n    ΔxL::T,\n    ΔxR::T,\n    limiter = :vanleer::Symbol,\n) where {T}\n\nreconstruct3(\n    wL::T,\n    wN::T,\n    wR::T,\n    ΔxL,\n    ΔxR,\n    limiter = :vanleer::Symbol,\n) where {T<:AbstractArray{<:Real,1}}\n\nreconstruct3(\n    wL::T,\n    wN::T,\n    wR::T,\n    ΔxL,\n    ΔxR,\n    limiter = :vanleer::Symbol,\n) where {T<:AbstractArray{<:Real,2}}\n\nfunction reconstruct3(\n    wL::T,\n    wN::T,\n    wR::T,\n    ΔxL,\n    ΔxR,\n    limiter = :vanleer::Symbol,\n) where {T<:AbstractArray{<:Real,3}}\n\nThree-cell reconstruction\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.reconstruct3!","page":"Reconstruction","title":"KitBase.reconstruct3!","text":"reconstruct3!(\n    sw::X,\n    wL::Y,\n    wN::Y,\n    wR::Y,\n    ΔxL,\n    ΔxR,\n    limiter = :vanleer::Symbol,\n) where {X<:AbstractArray{<:AbstractFloat,1},Y<:AbstractArray{<:Real,1}}\n\nreconstruct3!(\n    sw::X,\n    wL::Y,\n    wN::Y,\n    wR::Y,\n    ΔxL,\n    ΔxR,\n    limiter = :vanleer::Symbol,\n) where {X<:AbstractArray{<:AbstractFloat,2},Y<:AbstractArray{<:Real,2}}\n\nreconstruct3!(\n    sw::X,\n    wL::Y,\n    wN::Y,\n    wR::Y,\n    ΔxL,\n    ΔxR,\n    limiter = :vanleer::Symbol,\n) where {X<:AbstractArray{<:AbstractFloat,3},Y<:AbstractArray{<:Real,3}}\n\nreconstruct3!(\n    sw::X,\n    wL::Y,\n    wN::Y,\n    wR::Y,\n    ΔxL,\n    ΔxR,\n    limiter = :vanleer::Symbol,\n) where {X<:AbstractArray{<:AbstractFloat,4},Y<:AbstractArray{<:Real,4}}\n\nThree-cell reconstruction\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"The available schemes are","category":"page"},{"location":"solver_reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"vanleer\nminmod\nsuperbee\nvanalbaba\nweno5","category":"page"},{"location":"solver_reconstruction/#KitBase.vanleer","page":"Reconstruction","title":"KitBase.vanleer","text":"vanleer(sL::Real, sR::Real)\n\nvan Leer limiter\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.minmod","page":"Reconstruction","title":"KitBase.minmod","text":"minmod(sL::Real, sR::Real)\n\nMinMod limiter\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.superbee","page":"Reconstruction","title":"KitBase.superbee","text":"superbee(sL::Real, sR::Real)\n\nSuperBee limiter\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.vanalbaba","page":"Reconstruction","title":"KitBase.vanalbaba","text":"vanalbaba(sL::Real, sR::Real)\n\nvan Albaba limiter\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.weno5","page":"Reconstruction","title":"KitBase.weno5","text":"weno5(wL2::T, wL1::T, wN::T, wR1::T, wR2::T) where {T}\n\n5th-order WENO-JS interpolation\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#Illustrative-examples","page":"Examples","title":"Illustrative examples","text":"","category":"section"},{"location":"tutorial/","page":"Examples","title":"Examples","text":"Thanks to the brilliant expressiveness and low-overhead abstraction in Julia, we provide different levels of solution algorithm for modeling and simulating advection-diffusion dynamics. The high-level solver is able to solve complex physics in a few lines, while the low-level APIs keep all the detailed implementations and benefit the secondary development. The low-level methods are easy to be called from Python and C. In the following, we present some quick tutorials to illustrate the usage of Kinetic. For more examples, please refer the example directories in Kinetic.jl, KitBase.jl and KitML.jl.","category":"page"}]
}
