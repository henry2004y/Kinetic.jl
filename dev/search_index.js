var documenterSearchIndex = {"docs":
[{"location":"api_theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"api_theory/","page":"Theory","title":"Theory","text":"prim_conserve\nconserve_prim\nmixture_prim_conserve\nmixture_conserve_prim\nem_coefficients\nadvection_flux\nburgers_flux\neuler_flux\neuler_jacobi\ngauss_moments\nmixture_gauss_moments\nmoments_conserve\nmixture_moments_conserve\npdf_slope\nmixture_pdf_slope\nmoments_conserve_slope\nmixture_moments_conserve_slope\ndiscrete_moments\nstress\nheat_flux\nmaxwellian\nmixture_maxwellian\nshakhov\nreduce_distribution\nfull_distribution\nref_vhs_vis\nvhs_collision_time\naap_hs_collision_time\naap_hs_prim\naap_hs_diffeq!\nshift_pdf!\nhs_boltz_kn\nkernel_mode\nboltzmann_fft\nboltzmann_fft!\nheat_capacity_ratio\nsound_speed","category":"page"},{"location":"api_theory/#KitBase.prim_conserve","page":"Theory","title":"KitBase.prim_conserve","text":"Transform primitive -> conservative variables\n\nprim_conserve(prim::T, γ) where {T<:AbstractArray{<:Real,1}}\n\nprim_conserve(ρ, U, λ, γ)\n\nprim_conserve(ρ, U, V, λ, γ)\n\nprim_conserve(ρ, U, V, W, λ, γ)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.conserve_prim","page":"Theory","title":"KitBase.conserve_prim","text":"Transform conservative -> primitive variables\n\nscalar: pseudo primitive vector for scalar conservation laws\nconserve_prim(u)\nconserve_prim(u, a)\nvector: primitive vector for Euler, Navier-Stokes and extended equations\nconserve_prim(W::T, γ) where {T<:AbstractArray{<:Real,1}}\nconserve_prim(ρ, M, E, γ)\nconserve_prim(ρ, MX, MY, E, γ)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_prim_conserve","page":"Theory","title":"KitBase.mixture_prim_conserve","text":"Transform multi-component primitive -> conservative variables\n\nmixture_prim_conserve(prim::T, γ) where {T<:AbstractArray{<:Real,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_conserve_prim","page":"Theory","title":"KitBase.mixture_conserve_prim","text":"Transform multi-component conservative -> primitive variables\n\nmixture_conserve_prim(W::T, γ) where {T<:AbstractArray{<:Real,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.em_coefficients","page":"Theory","title":"KitBase.em_coefficients","text":"Calculate electromagnetic coeffcients in hyperbolic Maxwell's equations\n\nem_coefficients(\n    prim::X,\n    E::Y,\n    B::Z,\n    mr,\n    lD,\n    rL,\n    dt,\n) where {X<:AbstractArray{<:Real,2},Y<:AbstractArray{<:Real,1},Z<:AbstractArray{<:Real,1}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.advection_flux","page":"Theory","title":"KitBase.advection_flux","text":"Theoretical flux of linear advection equation\n\nadvection_flux(u, a)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.burgers_flux","page":"Theory","title":"KitBase.burgers_flux","text":"Theoretical flux of Burgers' equation\n\nburgers_flux(u)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.euler_flux","page":"Theory","title":"KitBase.euler_flux","text":"Theoretical fluxes of Euler Equations\n\neuler_flux(w::A, γ; frame = :cartesian::Symbol) where {A<:AbstractArray{<:Real,1}}\n\n@return: flux tuple\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.euler_jacobi","page":"Theory","title":"KitBase.euler_jacobi","text":"Flux Jacobian of Euler Equations\n\neuler_jacobi(w::T, γ) where {T<:AbstractArray{<:Real,1}}\n\n@return: Jacobian matrix A\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.gauss_moments","page":"Theory","title":"KitBase.gauss_moments","text":"Calculate moments of Gaussian distribution G = (λ / π)^(D / 2) * exp[-λ(c^2 + ξ^2)]\n\ninternality: gauss_moments(prim::T) where {T<:AbstractArray{<:Real,1}}\nno internality: gauss_moments(prim::T, inK) where {T<:AbstractArray{<:Real,1}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_gauss_moments","page":"Theory","title":"KitBase.mixture_gauss_moments","text":"Calculate moments of Gaussian distribution in multi-component gas\n\nmixture_gauss_moments(prim::T, inK) where {T<:AbstractArray{<:Real,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.moments_conserve","page":"Theory","title":"KitBase.moments_conserve","text":"Calculate conservative moments of particle distribution\n\nmoments_conserve(Mu::OffsetArray{<:AbstractFloat,1}, alpha::Int)\n\nmoments_conserve(Mu::OffsetArray{<:Real,1}, Mxi::OffsetArray{<:Real,1},     alpha::Int, delta::Int)\n\nmoments_conserve(Mu::OffsetArray{<:Real,1}, Mv::OffsetArray{<:Real,1},     Mw::OffsetArray{<:Real,1}, alpha::Int, beta::Int, delta::Int)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_moments_conserve","page":"Theory","title":"KitBase.mixture_moments_conserve","text":"Calculate conservative moments of particle distribution in multi-component gas\n\nmixture_moments_conserve(\n    Mu::T,\n    Mxi::T,\n    alpha::I,\n    delta::I,\n) where {T<:OffsetArray{<:AbstractFloat,2},I<:Int}\n\nfunction mixture_moments_conserve(\n    Mu::T,\n    Mv::T,\n    Mw::T,\n    alpha::I,\n    beta::I,\n    delta::I,\n) where {T<:OffsetArray{<:AbstractFloat,2},I<:Int}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.pdf_slope","page":"Theory","title":"KitBase.pdf_slope","text":"Calculate slope of particle distribution function a = a1 + u * a2 + 0.5 * u^2 * a3\n\npdf_slope(u, Δ)\n\npdf_slope(prim::A, sw::B, inK) where {A<:AbstractArray{<:Real,1},B<:AbstractArray{<:Real,1}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_pdf_slope","page":"Theory","title":"KitBase.mixture_pdf_slope","text":"Calculate slope of multi-component particle distribution function a = a1 + u * a2 + 0.5 * u^2 * a3\n\nmixture_pdf_slope(prim::X, sw::Y, inK) where {X<:AbstractArray{<:Real,2},Y<:AbstractArray{<:Real,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.moments_conserve_slope","page":"Theory","title":"KitBase.moments_conserve_slope","text":"Calculate slope-related conservative moments a = a1 + u * a2 + 0.5 * u^2 * a3\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_moments_conserve_slope","page":"Theory","title":"KitBase.mixture_moments_conserve_slope","text":"Calculate slope-related conservative moments a = a1 + u * a2 + 0.5 * u^2 * a3\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.discrete_moments","page":"Theory","title":"KitBase.discrete_moments","text":"Discrete moments of particle distribution\n\ndiscrete_moments(f, ω): direct quadrature\ndiscrete_moments(f, u, ω, n): velocity moments\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.stress","page":"Theory","title":"KitBase.stress","text":"Calculate stress tensor from particle distribution function\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.heat_flux","page":"Theory","title":"KitBase.heat_flux","text":"Calculate heat flux from particle distribution function\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.maxwellian","page":"Theory","title":"KitBase.maxwellian","text":"Maxwellian in discrete form\n\n@args: particle velocity quadrature points\n@args: density, velocity and inverse of temperature\n@return: Maxwellian distribution function\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_maxwellian","page":"Theory","title":"KitBase.mixture_maxwellian","text":"Multi-component Maxwellian in discrete form\n\nmixture_maxwellian(u::X, prim::Y) where {X<:AbstractArray{<:AbstractFloat,2},Y<:AbstractArray{<:Real,2}}\n\nmixture_maxwellian(\n    u::X,\n    v::X,\n    prim::Y,\n) where {X<:AbstractArray{<:AbstractFloat,3},Y<:AbstractArray{<:Real,2}}\n\nmixture_maxwellian(\n    u::X,\n    v::X,\n    w::X,\n    prim::Y,\n) where {X<:AbstractArray{<:AbstractFloat,4},Y<:AbstractArray{<:Real,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.shakhov","page":"Theory","title":"KitBase.shakhov","text":"Shakhov non-equilibrium part\n\n@arg: particle velocity quadrature points\n@arg: discrete Maxwellian\n@arg: primitive variables, Prandtl number, heat flux, inner degree of freedom\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.reduce_distribution","page":"Theory","title":"KitBase.reduce_distribution","text":"Reduced distribution function\n\n@arg : particle distribution function with full velocity space\n@arg : quadrature weights with reduced velocity setting (v & w by default)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.full_distribution","page":"Theory","title":"KitBase.full_distribution","text":"Recover full distribution function from reduced ones\n\n@arg h & b : reduced particle distribution function with 1D velocity space\n@arg u : quadrature nodes in 1D velocity space\n@arg weights : quadrature weights in 1D velocity space\n@arg v & w : quadrature nodes in the rest velocity space (with 3D setting)\n@return f : particle distribution function with 3D velocity space\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.ref_vhs_vis","page":"Theory","title":"KitBase.ref_vhs_vis","text":"ref_vhs_vis(Kn, alpha, omega)\n\nCalculate reference viscosity with variable hard sphere (VHS) model\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.vhs_collision_time","page":"Theory","title":"KitBase.vhs_collision_time","text":"vhs_collision_time(prim::T, muRef, omega) where {T<:AbstractArray{<:Real,1}}\n\nCalculate collision time with variable hard sphere (VHS) model\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.aap_hs_collision_time","page":"Theory","title":"KitBase.aap_hs_collision_time","text":"Calculate mixture collision time from AAP model\n\naap_hs_collision_time(     prim::AbstractArray{<:Real,2},     mi::Real,     ni::Real,     me::Real,     ne::Real,     kn::Real, )\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.aap_hs_prim","page":"Theory","title":"KitBase.aap_hs_prim","text":"Calculate mixture primitive variables from AAP model\n\ntested √\n\naap_hs_prim(     prim::AbstractArray{<:Real,2},     tau::AbstractArray{<:Real,1},     mi::Real,     ni::Real,     me::Real,     ne::Real,     kn::Real, )\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.aap_hs_diffeq!","page":"Theory","title":"KitBase.aap_hs_diffeq!","text":"Source term of AAP model in DifferentialEquations.jl\n\naap_hs_diffeq!(du, u, p, t)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.shift_pdf!","page":"Theory","title":"KitBase.shift_pdf!","text":"Shift distribution function by external force\n\nshift_pdf!(\n    f::T,\n    a,\n    du,\n    dt,\n) where {T<:AbstractArray{<:AbstractFloat,1}}\n\nshift_pdf!(\n    f::X,\n    a::Y,\n    du::Z,\n    dt,\n) where {X<:AbstractArray{<:AbstractFloat,2},Y<:AbstractArray{<:Real,1},Z<:AbstractArray{<:AbstractFloat,1}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.hs_boltz_kn","page":"Theory","title":"KitBase.hs_boltz_kn","text":"Calculate effective Knudsen number for fast spectral method with hard sphere (HS) model\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.kernel_mode","page":"Theory","title":"KitBase.kernel_mode","text":"Calculate collision kernel for fast spectral method\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.boltzmann_fft","page":"Theory","title":"KitBase.boltzmann_fft","text":"Calculate collision operator with FFT-based fast spectral method\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.boltzmann_fft!","page":"Theory","title":"KitBase.boltzmann_fft!","text":"Calculate collision operator with FFT-based fast spectral method\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.heat_capacity_ratio","page":"Theory","title":"KitBase.heat_capacity_ratio","text":"Calculate heat capacity ratio\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.sound_speed","page":"Theory","title":"KitBase.sound_speed","text":"Calculate speed of sound\n\n\n\n\n\n","category":"function"},{"location":"api_io/#I-/-O","page":"I / O","title":"I / O","text":"","category":"section"},{"location":"api_io/","page":"I / O","title":"I / O","text":"read_dict\nwrite_jld\nplot_line","category":"page"},{"location":"api_io/#KitBase.read_dict","page":"I / O","title":"KitBase.read_dict","text":"Read text into dictionary\n\nread_dict(filename::String, allowed)\nread_dict(filename::String)\n\n@args filename: configuration text file\n@args allowed: keywords\n@return vars: dictionary with values of variables\n\n\n\n\n\n","category":"function"},{"location":"api_io/#KitBase.write_jld","page":"I / O","title":"KitBase.write_jld","text":"Write data into JLD2\n\nwrite_jld(KS, ctr, t)\n\n\n\n\n\n","category":"function"},{"location":"api_io/#KitBase.plot_line","page":"I / O","title":"KitBase.plot_line","text":"Plot 1D profile\n\nplot_line(KS, ctr; backend)\n\n\n\n\n\n","category":"function"},{"location":"basics/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"The real world is built upon physics, which show a diverse set of behaviors on different characteristic scales. Consider the molecular motion of gases as an example. Down to finest scale of characteristic motion, the Newton's second law depicts particle motions","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"mathbfF = m mathbfa","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"As a first order system this reads","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"fracd mathbf xdt = mathbf v fracd mathbf vdt = fracmathbf Fm","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"There are more than 2e25 molecules per cubic meter in normal atmosphere. As a result, it is despairing to track all the individual motions every moment. Instead, ensemble averaging is needed to provide a bottom-up view, from which the coarse-grained modeling happens. At the mean free path and collision time scale of molecules, particles travel freely during most of time with mild intermolecular collisions. Such dynamics can be described with an operator splitting approach, i.e. the Boltzmann equation","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"fracpartial fpartial t+ mathbf u cdot nabla_mathbf x f + mathbf a cdot nabla_mathbf u f = int_mathcal R^3 int_mathcal S^2 B (f(mathbf u_*)f(mathbf u)-f(mathbf u_*) f(mathbf u)) dOmega dmathbf u_*","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Meanwhile, with the enlargement of modeling scale to a macroscopic hydrodynamic level, the accumulating effect of particle collisions results in an equalization of local temperature and velocity, where the moderate non-equilibrium effects can be well described by viscous transport, heat conduction and mass diffusion, i.e., the so called transport phenomena.  From microscopic particle transport to macroscopic fluid motion, there is a continuous variation of flow dynamics.  In the comtinuum limit, the Euler and Navier-Stokes equations can be routinely used to describe macroscopic fluid evolutions.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"fracpartial mathbf Wpartial t + nabla_mathbf x cdot mathbf F = mathbf S","category":"page"},{"location":"install/#Installation-Instructions","page":"Installation","title":"Installation Instructions","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Kinetic.jl is a registered Julialang package in the official entry. You can install the latest version using the built-in package manager (accessed by pressing ] in the Julia command prompt) to add the package and instantiate/build all dependencies.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> ]\n(v1.5) pkg> add Kinetic\n(v1.5) pkg> build Kinetic","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This will install Kinetic and all its dependencies. After that, load the package,","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using Kinetic","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Kinetic.jl can be updated to the latest tagged release from the package manager by typing","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(v1.5) pkg> update Kinetic","category":"page"},{"location":"api_config/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"api_config/","page":"Configuration","title":"Configuration","text":"ib_rh\nib_sod\nib_briowu\nib_cavity","category":"page"},{"location":"api_config/#KitBase.ib_rh","page":"Configuration","title":"KitBase.ib_rh","text":"Initialize Rankine-Hugoniot relation\n\n1d1f1v: ib_rh(MaL, gam, u::T) where {T<:AbstractArray{<:AbstractFloat,1}}\n1d2f1v: ib_rh(MaL, gam, u::T, K) where {T<:AbstractArray{<:AbstractFloat,1}}\n1d1f3v: ib_rh(MaL, gam, u::T, v::T, w::T) where {T<:AbstractArray{<:AbstractFloat,3}}\n\n\n\n\n\n","category":"function"},{"location":"api_config/#KitBase.ib_sod","page":"Configuration","title":"KitBase.ib_sod","text":"Initialize Sod shock tube\n\n1d1f1v: ib_sod(γ, u::T) where {T<:AbstractArray{<:AbstractFloat,1}}\n1d1f3v: ib_sod(γ, u::T, v::T, w::T) where {T<:AbstractArray{<:AbstractFloat,3}}\n1d2f1v: ib_sod(γ, u::T, K) where {T<:AbstractArray{<:AbstractFloat,1}}\n\n\n\n\n\n","category":"function"},{"location":"api_config/#KitBase.ib_briowu","page":"Configuration","title":"KitBase.ib_briowu","text":"Initialize Brio-Wu MHD shock\n\nib_briowu(gam, uspace::T, mi, me) where {T<:AbstractArray{<:AbstractFloat,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_config/#KitBase.ib_cavity","page":"Configuration","title":"KitBase.ib_cavity","text":"Initialize lid-driven cavity\n\n2d1f2v: ib_cavity(gam, Um, Vm, Tm, u::T, v::T) where {T<:AbstractArray{<:AbstractFloat,2}}\n2d2f2v: ib_cavity(gam, Um, Vm, Tm, u::T, v::T, K) where {T<:AbstractArray{<:AbstractFloat,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#Physical-Space","page":"Physical Space","title":"Physical Space","text":"","category":"section"},{"location":"api_geo/","page":"Physical Space","title":"Physical Space","text":"global_frame\nlocal_frame\nPSpace1D\nPSpace2D\nuniform_mesh\nmeshgrid\nUnstructMesh \nread_mesh\nmesh_connectivity_2D\nmesh_center_2D\nmesh_area_2D","category":"page"},{"location":"api_geo/#KitBase.global_frame","page":"Physical Space","title":"KitBase.global_frame","text":"Transform local flow variables to global frame\n\n2D: global_frame(w::AbstractArray{<:Real,1}, cosa, sina)\n3D: global_frame(w::AbstractArray{<:Real,1}, dirccos::AbstractArray{<:Real,2})\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.local_frame","page":"Physical Space","title":"KitBase.local_frame","text":"Transform global flow variables to local frame\n\n2D: local_frame(w::AbstractArray{<:Real,1}, cosa, sina)\n3D: local_frame(w::AbstractArray{<:Real,1}, dirccos::AbstractArray{<:Real,2})\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.PSpace1D","page":"Physical Space","title":"KitBase.PSpace1D","text":"1D physical space with structured mesh\n\n@consts: x0, x1, nx, x, dx\n\n\n\n\n\n","category":"type"},{"location":"api_geo/#KitBase.PSpace2D","page":"Physical Space","title":"KitBase.PSpace2D","text":"2D Physical space with structured mesh\n\n@consts: x0, x1, nx, y0, y1, ny, x, y, dx, dy\n\n\n\n\n\n","category":"type"},{"location":"api_geo/#KitBase.uniform_mesh","page":"Physical Space","title":"KitBase.uniform_mesh","text":"uniform_mesh(x0::Real, xnum::Int, dx::Real)\n\nGenerate uniform mesh\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.meshgrid","page":"Physical Space","title":"KitBase.meshgrid","text":"Equivalent structured mesh generator as matlab\n\n2D: meshgrid(x::AbstractArray{<:Real,1}, y::AbstractArray{<:Real,1})\n3D: meshgrid(x::AbstractArray{<:Real,1}, y::AbstractArray{<:Real,1}, z::AbstractArray{<:Real,1})\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.UnstructMesh","page":"Physical Space","title":"KitBase.UnstructMesh","text":"Physical space with unstructured mesh\n\n@consts: nodes, cells\n\n\n\n\n\n","category":"type"},{"location":"api_geo/#KitBase.read_mesh","page":"Physical Space","title":"KitBase.read_mesh","text":"Read mesh file\n\nread_mesh(file)\n\n@return nodes : are saved with 3D coordinates (z=0 for 2D case)\n@return cells : node ids inside cells\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.mesh_connectivity_2D","page":"Physical Space","title":"KitBase.mesh_connectivity_2D","text":"Compute connectivity of 2D unstructured mesh\n\nmesh_connectivity_2D(cells::AbstractArray{<:Int,2})\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.mesh_center_2D","page":"Physical Space","title":"KitBase.mesh_center_2D","text":"Compute central points of 2D elements\n\nmesh_center_2D(nodes::AbstractArray{<:AbstractFloat,2}, cells::AbstractArray{<:Int,2})\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.mesh_area_2D","page":"Physical Space","title":"KitBase.mesh_area_2D","text":"Compute areas of 2D elements\n\nmesh_area_2D(nodes::AbstractArray{<:AbstractFloat,2}, cells::AbstractArray{<:Int,2})\n\n\n\n\n\n","category":"function"},{"location":"api_phase/#Phase-Space","page":"Phase Space","title":"Phase Space","text":"","category":"section"},{"location":"api_phase/","page":"Phase Space","title":"Phase Space","text":"VSpace1D\nVSpace2D\nVSpace3D\nMVSpace1D\nMVSpace2D\nMVSpace3D\nnewton_cotes\nlegendre_quadrature\nocta_quadrature\nquadrature_weights","category":"page"},{"location":"api_phase/#KitBase.VSpace1D","page":"Phase Space","title":"KitBase.VSpace1D","text":"1D velocity space\n\n@consts: u0, u1, nu, u, du, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.VSpace2D","page":"Phase Space","title":"KitBase.VSpace2D","text":"2D velocity space\n\n@consts: u0, u1, nu, v0, v1, nv, u, v, du, dv, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.VSpace3D","page":"Phase Space","title":"KitBase.VSpace3D","text":"3D velocity space\n\n@consts: u0, u1, nu, v0, v1, nv, w0, w1, nw, u, v, w, du, dv, dw, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.MVSpace1D","page":"Phase Space","title":"KitBase.MVSpace1D","text":"1D multi-component velocity space\n\n@consts: u0, u1, nu, u, du, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.MVSpace2D","page":"Phase Space","title":"KitBase.MVSpace2D","text":"2D multi-component velocity space\n\n@consts: u0, u1, nu, v0, v1, nv, u, v, du, dv, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.MVSpace3D","page":"Phase Space","title":"KitBase.MVSpace3D","text":"3D multi-component velocity space\n\n@consts: u0, u1, nu, v0, v1, nv, w0, w1, nw, u, v, w, du, dv, dw, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.newton_cotes","page":"Phase Space","title":"KitBase.newton_cotes","text":"newton_cotes(idx::T, num::T) where {T<:Integer}\n\nEvaluate quadrature weight from Newton-Cotes rule\n\n\n\n\n\n","category":"function"},{"location":"api_phase/#KitBase.legendre_quadrature","page":"Phase Space","title":"KitBase.legendre_quadrature","text":"Gauss-Legendre quadrature\n\nlegendre_quadrature(n::Int)\n\n@arg n : quadrature order (MUST be even)\n@return points : quadrature points in 3D coordinate\n@return weights : quadrature weights\n\n\n\n\n\n","category":"function"},{"location":"api_phase/#KitBase.octa_quadrature","page":"Phase Space","title":"KitBase.octa_quadrature","text":"Octaeder quadrature\n\nocta_quadrature(n::Int, slerpflag = true::Bool)\n\n@arg n : quadrature order\n@arg slerpflag : flag of spherical linear interpolation\n@return points\n@return triangulation\n\n\n\n\n\n","category":"function"},{"location":"api_phase/#KitBase.quadrature_weights","page":"Phase Space","title":"KitBase.quadrature_weights","text":"Create quadrature weights from points and triangulation\n\ncreate_weights(n::Int, xyz::AbstractArray{<:Real,2}, triangles::AbstractArray{Int,2})\n\n@arg xyz : quadrature points\n@arg triangles : triangulation\n@return weights : quadrature weights\n\n\n\n\n\n","category":"function"},{"location":"api_reconstruct/#Reconstruction","page":"Reconstruction","title":"Reconstruction","text":"","category":"section"},{"location":"api_reconstruct/","page":"Reconstruction","title":"Reconstruction","text":"vanleer\nminmod\nsuperbee\nvanalbaba\nreconstruct2\nreconstruct2!\nreconstruct3\nreconstruct3!\nweno5","category":"page"},{"location":"api_reconstruct/#KitBase.vanleer","page":"Reconstruction","title":"KitBase.vanleer","text":"van Leer limiter\n\nvanleer(sL::Real, sR::Real)\n\n\n\n\n\n","category":"function"},{"location":"api_reconstruct/#KitBase.minmod","page":"Reconstruction","title":"KitBase.minmod","text":"minmod limiter\n\nminmod(sL::Real, sR::Real)\n\n\n\n\n\n","category":"function"},{"location":"api_reconstruct/#KitBase.superbee","page":"Reconstruction","title":"KitBase.superbee","text":"superbee limiter\n\nsuperbee(sL::Real, sR::Real)\n\n\n\n\n\n","category":"function"},{"location":"api_reconstruct/#KitBase.vanalbaba","page":"Reconstruction","title":"KitBase.vanalbaba","text":"van Albaba limiter\n\nvanalbaba(sL::Real, sR::Real)\n\n\n\n\n\n","category":"function"},{"location":"api_reconstruct/#KitBase.reconstruct2","page":"Reconstruction","title":"KitBase.reconstruct2","text":"Two-cell reconstruction\n\n\n\n\n\n","category":"function"},{"location":"api_reconstruct/#KitBase.reconstruct2!","page":"Reconstruction","title":"KitBase.reconstruct2!","text":"Two-cell reconstruction\n\n\n\n\n\n","category":"function"},{"location":"api_reconstruct/#KitBase.reconstruct3","page":"Reconstruction","title":"KitBase.reconstruct3","text":"Three-cell reconstruction\n\n\n\n\n\n","category":"function"},{"location":"api_reconstruct/#KitBase.reconstruct3!","page":"Reconstruction","title":"KitBase.reconstruct3!","text":"Three-cell reconstruction\n\n\n\n\n\n","category":"function"},{"location":"api_reconstruct/#KitBase.weno5","page":"Reconstruction","title":"KitBase.weno5","text":"5th-order WENO-JS interpolation\n\nweno5(wL2::T, wL1::T, wN::T, wR1::T, wR2::T) where {T}\n\n\n\n\n\n","category":"function"},{"location":"api_solver/#Solver","page":"Solver","title":"Solver","text":"","category":"section"},{"location":"api_solver/","page":"Solver","title":"Solver","text":"Kinetic.initialize\ninit_fvm\nSolverSet\nset_ib\nsolve!\nKinetic.timestep\nreconstruct!\nevolve!\nupdate!\nupdate_boundary!\nstep!","category":"page"},{"location":"api_solver/#KitBase.initialize","page":"Solver","title":"KitBase.initialize","text":"Initialize solver from input file\n\n\n\n\n\n","category":"function"},{"location":"api_solver/#KitBase.SolverSet","page":"Solver","title":"KitBase.SolverSet","text":"Structure of solver setup\n\n\n\n\n\n","category":"type"},{"location":"api_solver/#KitBase.set_ib","page":"Solver","title":"KitBase.set_ib","text":"Generate AbstractIB\n\n\n\n\n\n","category":"function"},{"location":"api_solver/#KitBase.solve!","page":"Solver","title":"KitBase.solve!","text":"Solution algorithm\n\n1D solver: solve!(KS::SolverSet, ctr::AbstractArray{<:AbstractControlVolume1D,1},   face::Array{<:AbstractInterface1D,1}, simTime::Float64)\n@return: ending time\n\n\n\n\n\n","category":"function"},{"location":"api_solver/#KitBase.timestep","page":"Solver","title":"KitBase.timestep","text":"Timestep calculator\n\n1D solver: timestep(KS::SolverSet, ctr::AbstractArray{<:AbstractControlVolume1D,1},   simTime::Real)\n@return: Δt\n\n\n\n\n\n","category":"function"},{"location":"api_solver/#KitBase.reconstruct!","page":"Solver","title":"KitBase.reconstruct!","text":"Reconstructor\n\n1D solver: reconstruct!(KS::SolverSet, ctr::AbstractArray{<:AbstractControlVolume1D,1})\n2D solver: reconstruct!(KS::SolverSet, ctr::AbstractArray{ControlVolume2D2F,2})\n\n\n\n\n\n","category":"function"},{"location":"api_solver/#KitBase.evolve!","page":"Solver","title":"KitBase.evolve!","text":"Evolution\n\n\n\n\n\n","category":"function"},{"location":"api_solver/#KitBase.update!","page":"Solver","title":"KitBase.update!","text":"Update flow variables\n\n\n\n\n\n","category":"function"},{"location":"type/#Data-Structure","page":"Type","title":"Data Structure","text":"","category":"section"},{"location":"type/","page":"Type","title":"Type","text":"KitBase.ControlVolume1D\nKitBase.ControlVolume1D1F\nKitBase.ControlVolume1D2F\nKitBase.ControlVolume1D3F\nKitBase.ControlVolume1D4F\nKitBase.ControlVolume2D\nKitBase.ControlVolume2D1F\nKitBase.ControlVolume2D2F\nKitBase.ControlVolume2D3F\nKitBase.Interface1D\nKitBase.Interface1D1F\nKitBase.Interface1D2F\nKitBase.Interface1D3F\nKitBase.Interface1D4F\nKitBase.Interface2D\nKitBase.Interface2D1F\nKitBase.Interface2D2F","category":"page"},{"location":"type/#KitBase.ControlVolume1D","page":"Type","title":"KitBase.ControlVolume1D","text":"1D control volume with no distribution function\n\nControlVolume1D(X::Real, DX::Real, W::AbstractArray, PRIM::AbstractArray)\n\n@vars: x, dx, w, prim, sw\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume1D1F","page":"Type","title":"KitBase.ControlVolume1D1F","text":"1D control volume with 1 distribution function\n\nControlVolume1D1F(X::Real, DX::Real, W::AbstractArray, PRIM::AbstractArray, F::AbstractArray)\n\n@vars: x, dx, w, prim, sw, f, sf\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume1D2F","page":"Type","title":"KitBase.ControlVolume1D2F","text":"1D control volume with 2 distribution functions\n\nControlVolume1D2F(X::Real, DX::Real, W::AbstractArray, PRIM::AbstractArray, H::AbstractArray, B::AbstractArray)\n\n@vars: x, dx, w, prim, sw, h, b, sh, sb\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume1D3F","page":"Type","title":"KitBase.ControlVolume1D3F","text":"1D control volume with 3 distribution functions\n\nControlVolume1D3F(X, DX, W, PRIM, H0, H1, H2, E0, B0, L)\n\n@vars: x, dx, w, prim, sw, h0, h1, h2, sh0, sh1, sh2, E, B, ϕ, ψ, lorenz\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume1D4F","page":"Type","title":"KitBase.ControlVolume1D4F","text":"1D control volume with 4 distribution functions\n\nControlVolume1D4F(X, DX, W, PRIM, H0, H1, H2, H3, E0, B0, L)\n\n@vars: x, dx, w, prim, sw, h0, h1, h2, h3, sh0, sh1, sh2, sh3, E, B, ϕ, ψ, lorenz\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume2D","page":"Type","title":"KitBase.ControlVolume2D","text":"2D control volume with no distribution function\n\nControlVolume2D(X::Real, DX::Real, Y::Real, DY::Real, W::AbstractArray, PRIM::AbstractArray)\n\n@vars: x, y, dx, dy, w, prim, sw\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume2D1F","page":"Type","title":"KitBase.ControlVolume2D1F","text":"2D control volume with 1 distribution function\n\nControlVolume2D1F(X::Real, DX::Real, Y::Real, DY::Real, W::AbstractArray, PRIM::AbstractArray, F::AbstractArray)\n\n@vars: x, y, dx, dy, w, prim, sw, f, sf\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume2D2F","page":"Type","title":"KitBase.ControlVolume2D2F","text":"2D control volume with 2 distribution functions\n\nControlVolume2D2F(X::Real, DX::Real, Y::Real, DY::Real, W::AbstractArray, PRIM::AbstractArray, H::AbstractArray, B::AbstractArray)\n\n@vars: x, y, dx, dy, w, prim, sw, h, b, sh, sb\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume2D3F","page":"Type","title":"KitBase.ControlVolume2D3F","text":"2D control volume with 3 distribution functions\n\nControlVolume2D3F(X, DX, Y, DY, W, PRIM, H0, H1, H2, E0, B0, L)\n\n@vars: x, y, dx, dy, w, prim, sw, h0, h1, h2, sh0, sh1, sh2, E, B, ϕ, ψ, lorenz\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface1D","page":"Type","title":"KitBase.Interface1D","text":"1D cell interface with no distribution function\n\n@vars: fw\n\nInterface1D(w::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface1D1F","page":"Type","title":"KitBase.Interface1D1F","text":"1D cell interface with 1 distribution function\n\n@vars: fw, ff\n\nInterface1D1F(w::AbstractArray, f::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface1D2F","page":"Type","title":"KitBase.Interface1D2F","text":"1D cell interface with 2 distribution functions\n\n@vars: fw, fh, fb\n\nInterface1D2F(w::AbstractArray, f::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface1D3F","page":"Type","title":"KitBase.Interface1D3F","text":"1D cell interface with 3 distribution functions\n\n@vars: fw, fh0, fh1, fh2, femL, femR,\n\ndeterministic: Interface1D3F(w::AbstractArray, f::AbstractArray, E::AbstractArray{<:Real,1})\nstochastic: Interface1D3F(w::AbstractArray, f::AbstractArray, E::AbstractArray{<:Real,2})\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface1D4F","page":"Type","title":"KitBase.Interface1D4F","text":"1D cell interface with 4 distribution functions\n\n@vars: fw, fh0, fh1, fh2, fh3, femL, femR,\n\ndeterministic: Interface1D4F(w::AbstractArray, f::AbstractArray, E::AbstractArray{<:Real,1})\nstochastic: Interface1D4F(w::AbstractArray, f::AbstractArray, E::AbstractArray{<:Real,2})\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface2D","page":"Type","title":"KitBase.Interface2D","text":"2D cell interface with no distribution function\n\n@vars: len, n, fw\n\nInterface2D(L::Real, C::Real, S::Real, w::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface2D1F","page":"Type","title":"KitBase.Interface2D1F","text":"2D cell interface with 1 distribution function\n\n@vars: len, n, fw, ff\n\nInterface2D1F(L::Real, C::Real, S::Real, w::AbstractArray, f::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface2D2F","page":"Type","title":"KitBase.Interface2D2F","text":"2D cell interface with 2 distribution functions\n\n@vars: len, n, fw, fh, fb\n\nInterface2D2F(L::Real, C::Real, S::Real, w::AbstractArray, f::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"type/","page":"Type","title":"Type","text":"Modules = [KitBase]\nOrder = [:type]","category":"page"},{"location":"type/#KitBase.ControlVolumeParticle1D","page":"Type","title":"KitBase.ControlVolumeParticle1D","text":"ControlVolume1D(X::Real, DX::Real, W::AbstractArray, PRIM::AbstractArray)\n\n1D control volume in correspondence with particle simulation\n\n@vars: x, dx, w, prim, sw, wg, τ, np, vrmax, remainder\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolumeParticle2D","page":"Type","title":"KitBase.ControlVolumeParticle2D","text":"ControlVolume2D(X::Real, DX::Real, Y::Real, DY::Real, W::AbstractArray, PRIM::AbstractArray)\n\n2D control volume in correspondence with particle simulation\n\n@vars: x, y, dx, dy, w, prim, sw, wg, τ, np, vrmax, remainder\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Gas","page":"Type","title":"KitBase.Gas","text":"Particle property\n\n@vars: Kn, Ma, Pr, K, γ, ω, αᵣ, ωᵣ, μᵣ, m, np\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.IB","page":"Type","title":"KitBase.IB","text":"Initial & boundary condition with no distribution function\n\n@consts: wL, primL, bcL, wR, primR, bcR, bcU, bcD\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.IB1F","page":"Type","title":"KitBase.IB1F","text":"Initial & boundary condition with 1 distribution function\n\n@consts: wL, primL, fL, bcL, wR, primR, fR, bcR, bcU, bcD\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.IB2F","page":"Type","title":"KitBase.IB2F","text":"Initial & boundary condition with 2 distribution functions\n\n@consts: wL, primL, hL, bL, bcL, wR, primR, hR, bR, bcR, bcU, bcD\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.IB3F","page":"Type","title":"KitBase.IB3F","text":"Initial & boundary condition with 3 distribution functions\n\n@consts: wL, primL, h0L, h1L, h2L, bcL, EL, BL, lorenzL, wR, primR, h0R, h1R, h2R, bcR, ER, BR, lorenzR, bcU, bcD\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.IB4F","page":"Type","title":"KitBase.IB4F","text":"Initial & boundary condition with 4 distribution functions\n\n@consts: wL, primL, h0L, h1L, h2L, h3L, bcL, EL, BL, lorenzL, wR, primR, h0R, h1R, h2R, h3R, bcR, ER, BR, lorenzR, bcU, bcD\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Mixture","page":"Type","title":"KitBase.Mixture","text":"Multi-component gas property\n\n@consts: Kn, Ma, Pr, K, γ, mi, ni, me, ne\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Particle","page":"Type","title":"KitBase.Particle","text":"Particle(M, X, V, E, IDX, FLAG = zeros(eltype(IDX), axes(IDX, 1)), T = zero(M))\n\nStruct of arrays for particle simulation\n\n@vars: m, x, v, e, idx, flag, tc\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Particle1D","page":"Type","title":"KitBase.Particle1D","text":"Particle1D(M::AbstractFloat, X::Real, V::AbstractArray, IDX::Integer, T::Real)\n\n1D particle\n\n@vars: m, x, v, e, idx, tc\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Particle2D","page":"Type","title":"KitBase.Particle2D","text":"Particle2D(M::AbstractFloat, X::Real, V::AbstractArray, IDX::Integer, T::Real)\n\n2D particle\n\n@vars: m, x, v, idx, tb\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Plasma1D","page":"Type","title":"KitBase.Plasma1D","text":"1D plasma property\n\n@consts: Kn, Ma, Pr, K, γ, mi, ni, me, ne, lD, rL, sol, χ, ν, Ap, An, D\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Plasma2D","page":"Type","title":"KitBase.Plasma2D","text":"2D plasma property\n\n@consts: Kn, Ma, Pr, K, γ, mi, ni, me, ne, lD, rL, sol, χ, ν, A1p, A1n, A2p, A2n, D1, D2\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Setup","page":"Type","title":"KitBase.Setup","text":"Computational setup\n\n@consts: case, space, flux, collision, nSpecies, interpOrder, limiter, cfl, maxTime\n\n\n\n\n\n","category":"type"},{"location":"api_math/#Math","page":"Math","title":"Math","text":"","category":"section"},{"location":"api_math/","page":"Math","title":"Math","text":"linspace\nheaviside\nfortsign\nmat_split\ncentral_diff\ncentral_diff!\nupwind_diff\nupwind_diff!\nunstruct_diff\nlgwt\nextract_last","category":"page"},{"location":"api_math/#KitBase.linspace","page":"Math","title":"KitBase.linspace","text":"Python linspace function\n\nlinspace(start::Real, stop::Real, n::Int)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.heaviside","page":"Math","title":"KitBase.heaviside","text":"Heaviside step function\n\nheaviside(x::Real)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.fortsign","page":"Math","title":"KitBase.fortsign","text":"Fortran sign function\n\nfortsign(x::Real, y::Real)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.mat_split","page":"Math","title":"KitBase.mat_split","text":"Split matrix into row vectors\n\nmat_split(m::AbstractArray)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.central_diff","page":"Math","title":"KitBase.central_diff","text":"Central difference\n\ncentral_diff(y::AbstractArray{<:Any,1}, x::AbstractArray{<:Any,1})\n\ncentral_diff(y::AbstractArray{<:Any,1}, dx::Any)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.central_diff!","page":"Math","title":"KitBase.central_diff!","text":"Central difference\n\ncentral_diff!(dy::AbstractArray{<:Any,1}, y::AbstractArray{<:Any,1}, x::AbstractArray{<:Any,1})\n\ncentral_diff!(dy::AbstractArray{<:Any,1}, y::AbstractArray{<:Any,1}, dx::Any)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.upwind_diff","page":"Math","title":"KitBase.upwind_diff","text":"Upwind difference\n\nupwind_diff(\n    y::AbstractArray{<:Any,1},\n    x::AbstractArray{<:Any,1};\n    stream = :right::Symbol,\n)\n\nupwind_diff(y::AbstractArray{<:Any,1}, dx::Any; stream = :right::Symbol)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.upwind_diff!","page":"Math","title":"KitBase.upwind_diff!","text":"Upwind difference\n\nupwind_diff!(\n    dy::AbstractArray{<:Any,1},\n    y::AbstractArray{<:Any,1},\n    x::AbstractArray{<:Any,1};\n    stream = :right::Symbol,\n)\n\nupwind_diff!(\n    dy::AbstractArray{<:Any,1},\n    y::AbstractArray{<:Any,1},\n    dx::Any;\n    stream = :right::Symbol,\n)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.unstruct_diff","page":"Math","title":"KitBase.unstruct_diff","text":"Finite difference for pseudo-unstructured mesh\n\nunstruct_diff(u::AbstractArray{<:Any,1}, x::AbstractArray{<:Any,1}, nx::Int; mode = :central::Symbol)\n\nunstruct_diff(u::Function, x::AbstractArray{<:Any,2}, nx::Int, dim::Int; mode = :central::Symbol)\n\n\n\n\n\n","category":"function"},{"location":"api_flux/#Flux","page":"Flux","title":"Flux","text":"","category":"section"},{"location":"api_flux/","page":"Flux","title":"Flux","text":"flux_gks\nflux_gks!\nflux_kfvs!\nflux_kcu!\nflux_ugks!\nflux_boundary_maxwell!\nflux_lax!\nflux_hll!\nflux_roe!\nflux_em!\nflux_emx!\nflux_emy!","category":"page"},{"location":"api_flux/#KitBase.flux_gks","page":"Flux","title":"KitBase.flux_gks","text":"Gas kinetic flux\n\nflux_gks(u::Real, μ::Real, dt::Real, su = 0.0::Real, a = 0::Real)\nflux_gks(uL::Real, uR::Real, μ::Real, dt::Real, dxL::Real,\n    dxR::Real, suL = 0.0::Real, suR = 0.0::Real, a = 0::Real)\n\n@args: conservative scalars and their slopes\n@args: viscosity\n@args: time step and cell size\n@return: scalar flux\n\n\n\n\n\n","category":"function"},{"location":"api_flux/#KitBase.flux_gks!","page":"Flux","title":"KitBase.flux_gks!","text":"Gas kinetic Navier-Stokes flux\n\n1D: flux_gks!(fw, wL, wR, γ, K, μᵣ, ω, dt, dx, swL, swR)\n2D: flux_gks!(fw, wL, wR, γ, K, μᵣ, ω, dt, dx, dy, swL, swR)\n\n@args: conservative variables and their left/right slopes\n@args: molecular and thermodynamic parameters\n@args: time step and cell size\n\n\n\n\n\n","category":"function"},{"location":"api_flux/#KitBase.flux_kfvs!","page":"Flux","title":"KitBase.flux_kfvs!","text":"Kinetic flux vector splitting (KFVS) flux\n\nDOM: `flux_kfvs!(ff, fL, fR, u, dt, sfL, sfR)`\n1D1F1V: `flux_kfvs!(fw, ff, fL, fR, u, ω, dt, sfL, sfR)`\n1D1F3V: `flux_kfvs!(fw, ff, fL, fR, u, v, w, ω, dt, sfL, sfR)`\n1D2F1V: `flux_kfvs!(fw, fh, fb, hL, bL, hR, bR, u, ω, dt, shL, sbL, shR, sbR)`\n1D4F1V: `flux_kfvs!(fw, fh0, fh1, fh2, fh3, h0L, h1L, h2L, h3L, h0R, h1R, h2R, h3R, u, ω, dt, sh0L, sh1L, sh2L, sh3L, sh0R, sh1R, sh2R, sh3R)`\n2D1F2V: `flux_kfvs!(fw, ff, fL, fR, u, v, ω, dt, len, sfL, sfR)`\n2D2F2V: `flux_kfvs!(fw, fh, fb, hL, bL, hR, bR, u, v, ω, dt, len, shL, sbL, shR, sbR)`\n\n@args: particle distribution functions and their left/right slopes\n@args: particle velocity quadrature points and weights\n@args: time step and cell size\n\n\n\n\n\n","category":"function"},{"location":"api_flux/#KitBase.flux_kcu!","page":"Flux","title":"KitBase.flux_kcu!","text":"Kinetic central-upwind (KCU) method\n\n1D1F1V: flux_kcu!(fw, ff, wL, fL, wR, fR, u, ω, inK, γ, visRef, visIdx, Pr, dt)\n1D2F1V: flux_kcu!(fw, fh, fb, wL, hL, bL, wR, hR, bR, u, ω, inK, γ, visRef, visIdx, Pr, dt)\n1D4F1V: flux_kcu!(fw, fh0, fh1, fh2, fh3, wL, h0L, h1L, h2L, h3L, wR, h0R, h1R, h2R, h3R, u, ω, inK, γ, visRef, visIdx, Pr, dt)\n2D1F2V: flux_kcu!(fw, ff, wL, fL, wR, fR, u, v, ω, inK, γ, visRef, visIdx, Pr, dt, len)\n2D2F2V: flux_kcu!(fw, fh, fb, wL, hL, bL, wR, hR, bR, u, v, ω, inK, γ, visRef, visIdx, Pr, dt, len)\n2D3F2V: flux_kcu!(fw, fh0, fh1, fh2, wL, h0L, h1L, h2L, wR, h0R, h1R, h2R, u, v, ω, inK, γ, visRef, visIdx, Pr, dt, len)\n\n@args: particle distribution functions and their slopes at left/right sides of interface\n@args: particle velocity quadrature points and weights\n@args: time step and cell size\n\n\n\n\n\n","category":"function"},{"location":"api_flux/#KitBase.flux_ugks!","page":"Flux","title":"KitBase.flux_ugks!","text":"Unified gas kinetic scheme (UGKS)\n\n@args: particle distribution functions and their slopes at left/right sides of interface\n@args: particle velocity quadrature points and weights\n@args: time step\n\n\n\n\n\n","category":"function"},{"location":"api_flux/#KitBase.flux_boundary_maxwell!","page":"Flux","title":"KitBase.flux_boundary_maxwell!","text":"Maxwell's diffusive boundary flux\n\n@args: particle distribution functions and their slopes at left/right sides of interface\n@args: particle velocity quadrature points and weights\n@args: time step\n\n\n\n\n\n","category":"function"},{"location":"api_flux/#KitBase.flux_lax!","page":"Flux","title":"KitBase.flux_lax!","text":"Lax-Friedrichs flux\n\nflux_lax!(fw::AbstractArray{<:Real,1}, wL::AbstractArray{<:Real,1}, wR::AbstractArray{<:Real,1}, γ::Real, dt::Real, dx::Real)\n\nP. D. Lax, Weak Solutions of Nonlinear Hyperbolic Equations and Their Numerical Computation, Commun. Pure and Applied Mathematics, 7, 159-193, 1954.\n\n\n\n\n\n","category":"function"},{"location":"api_flux/#KitBase.flux_hll!","page":"Flux","title":"KitBase.flux_hll!","text":"HLL flux for the Euler equations\n\nflux_hll!(fw::AbstractArray{<:Real,1}, wL::AbstractArray{<:Real,1}, wR::AbstractArray{<:Real,1}, γ::Real, dt::Real)\n\n@args: variables at left & right sides of interface\n@args: specific heat ratio\n\n\n\n\n\n","category":"function"},{"location":"api_flux/#KitBase.flux_roe!","page":"Flux","title":"KitBase.flux_roe!","text":"Roe's flux with entropy fix\n\nflux_roe!(fw::AbstractArray{<:Real,1}, wL::AbstractArray{<:Real,1}, wR::AbstractArray{<:Real,1},\nγ::Real, dt::Real, n = [1.0, 0.0]::AbstractArray{<:Real,1})\n\nP. L. Roe, Approximate Riemann Solvers, Parameter Vectors and Difference Schemes, Journal of Computational Physics, 43, pp. 357-372. (cf. http://cfdbooks.com/cfdcodes.html)\n\n@args primL[1:4] = left state (rhoL, uL, vL, pL)\n@args primR[1:4] = right state (rhoR, uR, vR, pR)\n@args γ: specific heat ratio\n@args n[2]: unit face normal (L -> R)\n\n\n\n\n\n","category":"function"},{"location":"api_flux/#KitBase.flux_em!","page":"Flux","title":"KitBase.flux_em!","text":"Wave propagation method for Maxwell's equations\n\nflux_em!(femL, femR, ELL, BLL, EL, BL, ER, BR, ERR, BRR, ϕL, ϕR, ψL, ψR, dxL, dxR, Ap, An, D, sol, χ, ν, dt)\n\n@args: {E, B, ϕ, ψ} in left-left, left, right, and right-right cells\n@args: eigenmatrix (A -> A+ & A-), eigenvalue (D)\n@args: full size of left & right cells\n@args: speed of light (sol)\n@args: auxiliary parameters (χₑ, νᵦ)\n\n\n\n\n\n","category":"function"},{"location":"api_flux/#KitBase.flux_emx!","page":"Flux","title":"KitBase.flux_emx!","text":"Wave propagation method for 2D Maxwell's equations\n\nflux_emx!(femL, femR, femLU, femLD, femRU, femRD,\nELL, BLL, EL, BL, ER, BR, ERR, BRR, ϕL, ϕR, ψL, ψR,\ndxL, dxR, A1p, A1n, A2p, A2n, D, sol, χ, ν, dt)\n\n@args: {E, B, ϕ, ψ} in left-left, left, right, and right-right cells\n@args: eigenmatrix (A -> A+ & A-), eigenvalue (D)\n@args: full size of left & right cells\n@args: speed of light (sol)\n@args: auxiliary parameters (χₑ, νᵦ)\n\n\n\n\n\n","category":"function"},{"location":"api_flux/#KitBase.flux_emy!","page":"Flux","title":"KitBase.flux_emy!","text":"Wave propagation method for 2D Maxwell's equations\n\nflux_emx!(femL, femR, femLU, femLD, femRU, femRD,\nELL, BLL, EL, BL, ER, BR, ERR, BRR, ϕL, ϕR, ψL, ψR,\ndxL, dxR, A1p, A1n, A2p, A2n, D, sol, χ, ν, dt)\n\n@args: {E, B, ϕ, ψ} in left-left, left, right, and right-right cells\n@args: eigenmatrix (A -> A+ & A-), eigenvalue (D)\n@args: full size of left & right cells\n@args: speed of light (sol)\n@args: auxiliary parameters (χₑ, νᵦ)\n\n\n\n\n\n","category":"function"},{"location":"algorithm/#Solution-Algorithm","page":"Algorithm","title":"Solution Algorithm","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The finite volume method (FVM) is employed in this package. The general solution algorithm can be conclude as follows, where both explicit and implicit methods are implemented.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"(Image: )","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"(1) pre-process: initialize(configfilename::AbstractString)","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"new run: .txt / .cfg / .toml\nrestart: .jld2 (HDF5) -> solSet, ctr, face, t","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"(2) calculate timestep based on the CFL condition","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"(3) reconstruct field solutions","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"van-Leer\nminmod\nsuperbee\nWENO","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"(4) evolve numerical fluxes","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"macroscopic: Godunov, Lax, Roe, HLL, wave-propagation\nmesoscopic: upwind, central-upwind, gas-kinetic scheme","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"(5) update cell-averaged variables","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"explicit\nimplicit\nimplicit-explicit (IMEX)","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"(6) post-process","category":"page"},{"location":"#Kinetic.jl","page":"Home","title":"Kinetic.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetic is a lightweight Julia toolbox for the study of computational fluid dynamics and scientific machine learning. The main module consists of KitBase.jl with basic physics and KitML.jl with neural dynamics.  The high-performance Fortran library KitFort.jl is optional and can be manually imported when the executing efficiency becomes the first priority.  A wrapper kineticpy has been built to locate the data hierarchies and methods in Python.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Kinetic is interested in theoretical modeling and numerical simulation of many-particle systems, e.g. gases, photons, plasmas, neutrons, electrons, etc. It employs the finite volume method (FVM) to conduct 1-3 dimensional numerical simulations on CPUs and GPUs. Any advection-diffusion type equation can be hooked and solved within the framework. The user interface is designed as intuitive and neat as possible, allowing users to focus on physics and to cooperate with existing packages in the Julia ecosystem. We pay special attentions to Hilbert's sixth problem, i.e. building the numerical passage between the kinetic theory of gases and continuum mechanics.  Two types of governing equations are therefore bridged, i.e. the Boltzmann equation","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracpartial fpartial t+ mathbf u cdot nabla_mathbf x f + mathbf a cdot nabla_mathbf u f = int_mathcal R^3 int_mathcal S^2 B (f(mathbf u_*)f(mathbf u)-f(mathbf u_*) f(mathbf u)) dOmega dmathbf u_*","category":"page"},{"location":"","page":"Home","title":"Home","text":"and its upscaling moment system","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracpartial mathbf Wpartial t + nabla_mathbf x cdot mathbf F = mathbf S","category":"page"},{"location":"#Getting-help","page":"Home","title":"Getting help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are interested in using Kinetic.jl or are trying to figure out how to use it, please feel free to get in touch and raise questions. Open an issue or pull request if you have questions, suggestions or solutions.","category":"page"}]
}
