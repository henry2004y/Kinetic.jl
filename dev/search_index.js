var documenterSearchIndex = {"docs":
[{"location":"solver_update/#Update","page":"Update","title":"Update","text":"","category":"section"},{"location":"solver_update/","page":"Update","title":"Update","text":"update!","category":"page"},{"location":"solver_update/#KitBase.update!","page":"Update","title":"KitBase.update!","text":"Update flow variables\n\n\n\n\n\n","category":"function"},{"location":"solver_update/","page":"Update","title":"Update","text":"The update solver calculate the variables at n+1 step based on numerical fluxes and in-cell collisions.","category":"page"},{"location":"solver_update/","page":"Update","title":"Update","text":"explicit\nimplicit\nimplicit-explicit (IMEX)","category":"page"},{"location":"api_theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"api_theory/","page":"Theory","title":"Theory","text":"prim_conserve\nconserve_prim\nmixture_prim_conserve\nmixture_conserve_prim\nem_coefficients\nadvection_flux\nburgers_flux\neuler_flux\neuler_jacobi\ngauss_moments\nmixture_gauss_moments\nmoments_conserve\nmixture_moments_conserve\npdf_slope\nmixture_pdf_slope\nmoments_conserve_slope\nmixture_moments_conserve_slope\ndiscrete_moments\nstress\nheat_flux\nmaxwellian\nmixture_maxwellian\nshakhov\nreduce_distribution\nfull_distribution\nref_vhs_vis\nvhs_collision_time\naap_hs_collision_time\naap_hs_prim\naap_hs_diffeq!\nshift_pdf!\nhs_boltz_kn\nkernel_mode\nboltzmann_fft\nboltzmann_fft!\nheat_capacity_ratio\nsound_speed","category":"page"},{"location":"api_theory/#KitBase.prim_conserve","page":"Theory","title":"KitBase.prim_conserve","text":"Transform primitive -> conservative variables\n\nprim_conserve(prim::T, γ) where {T<:AbstractArray{<:Real,1}}\n\nprim_conserve(ρ, U, λ, γ)\n\nprim_conserve(ρ, U, V, λ, γ)\n\nprim_conserve(ρ, U, V, W, λ, γ)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.conserve_prim","page":"Theory","title":"KitBase.conserve_prim","text":"Transform conservative -> primitive variables\n\nscalar: pseudo primitive vector for scalar conservation laws\nconserve_prim(u)\nconserve_prim(u, a)\nvector: primitive vector for Euler, Navier-Stokes and extended equations\nconserve_prim(W::T, γ) where {T<:AbstractArray{<:Real,1}}\nconserve_prim(ρ, M, E, γ)\nconserve_prim(ρ, MX, MY, E, γ)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_prim_conserve","page":"Theory","title":"KitBase.mixture_prim_conserve","text":"Transform multi-component primitive -> conservative variables\n\nmixture_prim_conserve(prim::T, γ) where {T<:AbstractArray{<:Real,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_conserve_prim","page":"Theory","title":"KitBase.mixture_conserve_prim","text":"Transform multi-component conservative -> primitive variables\n\nmixture_conserve_prim(W::T, γ) where {T<:AbstractArray{<:Real,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.em_coefficients","page":"Theory","title":"KitBase.em_coefficients","text":"Calculate electromagnetic coeffcients in hyperbolic Maxwell's equations\n\nem_coefficients(\n    prim::X,\n    E::Y,\n    B::Z,\n    mr,\n    lD,\n    rL,\n    dt,\n) where {X<:AbstractArray{<:Real,2},Y<:AbstractArray{<:Real,1},Z<:AbstractArray{<:Real,1}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.advection_flux","page":"Theory","title":"KitBase.advection_flux","text":"Theoretical flux of linear advection equation\n\nadvection_flux(u, a)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.burgers_flux","page":"Theory","title":"KitBase.burgers_flux","text":"Theoretical flux of Burgers' equation\n\nburgers_flux(u)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.euler_flux","page":"Theory","title":"KitBase.euler_flux","text":"Theoretical fluxes of Euler Equations\n\neuler_flux(w::A, γ; frame = :cartesian::Symbol) where {A<:AbstractArray{<:Real,1}}\n\n@return: flux tuple\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.euler_jacobi","page":"Theory","title":"KitBase.euler_jacobi","text":"Flux Jacobian of Euler Equations\n\neuler_jacobi(w::T, γ) where {T<:AbstractArray{<:Real,1}}\n\n@return: Jacobian matrix A\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.gauss_moments","page":"Theory","title":"KitBase.gauss_moments","text":"Calculate moments of Gaussian distribution G = (λ / π)^(D / 2) * exp[-λ(c^2 + ξ^2)]\n\ninternality: gauss_moments(prim::T) where {T<:AbstractArray{<:Real,1}}\nno internality: gauss_moments(prim::T, inK) where {T<:AbstractArray{<:Real,1}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_gauss_moments","page":"Theory","title":"KitBase.mixture_gauss_moments","text":"Calculate moments of Gaussian distribution in multi-component gas\n\nmixture_gauss_moments(prim::T, inK) where {T<:AbstractArray{<:Real,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.moments_conserve","page":"Theory","title":"KitBase.moments_conserve","text":"Calculate conservative moments of particle distribution\n\nmoments_conserve(Mu::OffsetArray{<:AbstractFloat,1}, alpha::Int)\n\nmoments_conserve(Mu::OffsetArray{<:Real,1}, Mxi::OffsetArray{<:Real,1},     alpha::Int, delta::Int)\n\nmoments_conserve(Mu::OffsetArray{<:Real,1}, Mv::OffsetArray{<:Real,1},     Mw::OffsetArray{<:Real,1}, alpha::Int, beta::Int, delta::Int)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_moments_conserve","page":"Theory","title":"KitBase.mixture_moments_conserve","text":"Calculate conservative moments of particle distribution in multi-component gas\n\nmixture_moments_conserve(\n    Mu::T,\n    Mxi::T,\n    alpha::I,\n    delta::I,\n) where {T<:OffsetArray{<:AbstractFloat,2},I<:Int}\n\nfunction mixture_moments_conserve(\n    Mu::T,\n    Mv::T,\n    Mw::T,\n    alpha::I,\n    beta::I,\n    delta::I,\n) where {T<:OffsetArray{<:AbstractFloat,2},I<:Int}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.pdf_slope","page":"Theory","title":"KitBase.pdf_slope","text":"Calculate slope of particle distribution function a = a1 + u * a2 + 0.5 * u^2 * a3\n\npdf_slope(u, Δ)\n\npdf_slope(prim::A, sw::B, inK) where {A<:AbstractArray{<:Real,1},B<:AbstractArray{<:Real,1}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_pdf_slope","page":"Theory","title":"KitBase.mixture_pdf_slope","text":"Calculate slope of multi-component particle distribution function a = a1 + u * a2 + 0.5 * u^2 * a3\n\nmixture_pdf_slope(prim::X, sw::Y, inK) where {X<:AbstractArray{<:Real,2},Y<:AbstractArray{<:Real,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.moments_conserve_slope","page":"Theory","title":"KitBase.moments_conserve_slope","text":"Calculate slope-related conservative moments a = a1 + u * a2 + 0.5 * u^2 * a3\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_moments_conserve_slope","page":"Theory","title":"KitBase.mixture_moments_conserve_slope","text":"Calculate slope-related conservative moments a = a1 + u * a2 + 0.5 * u^2 * a3\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.discrete_moments","page":"Theory","title":"KitBase.discrete_moments","text":"Discrete moments of particle distribution\n\ndiscrete_moments(f, ω): direct quadrature\ndiscrete_moments(f, u, ω, n): velocity moments\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.stress","page":"Theory","title":"KitBase.stress","text":"Calculate stress tensor from particle distribution function\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.heat_flux","page":"Theory","title":"KitBase.heat_flux","text":"Calculate heat flux from particle distribution function\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.maxwellian","page":"Theory","title":"KitBase.maxwellian","text":"Maxwellian in discrete form\n\n@args: particle velocity quadrature points\n@args: density, velocity and inverse of temperature\n@return: Maxwellian distribution function\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_maxwellian","page":"Theory","title":"KitBase.mixture_maxwellian","text":"Multi-component Maxwellian in discrete form\n\nmixture_maxwellian(u::X, prim::Y) where {X<:AbstractArray{<:AbstractFloat,2},Y<:AbstractArray{<:Real,2}}\n\nmixture_maxwellian(\n    u::X,\n    v::X,\n    prim::Y,\n) where {X<:AbstractArray{<:AbstractFloat,3},Y<:AbstractArray{<:Real,2}}\n\nmixture_maxwellian(\n    u::X,\n    v::X,\n    w::X,\n    prim::Y,\n) where {X<:AbstractArray{<:AbstractFloat,4},Y<:AbstractArray{<:Real,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.shakhov","page":"Theory","title":"KitBase.shakhov","text":"Shakhov non-equilibrium part\n\n@arg: particle velocity quadrature points\n@arg: discrete Maxwellian\n@arg: primitive variables, Prandtl number, heat flux, inner degree of freedom\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.reduce_distribution","page":"Theory","title":"KitBase.reduce_distribution","text":"Reduced distribution function\n\n@arg : particle distribution function with full velocity space\n@arg : quadrature weights with reduced velocity setting (v & w by default)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.full_distribution","page":"Theory","title":"KitBase.full_distribution","text":"Recover full distribution function from reduced ones\n\n@arg h & b : reduced particle distribution function with 1D velocity space\n@arg u : quadrature nodes in 1D velocity space\n@arg weights : quadrature weights in 1D velocity space\n@arg v & w : quadrature nodes in the rest velocity space (with 3D setting)\n@return f : particle distribution function with 3D velocity space\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.ref_vhs_vis","page":"Theory","title":"KitBase.ref_vhs_vis","text":"ref_vhs_vis(Kn, alpha, omega)\n\nCalculate reference viscosity with variable hard sphere (VHS) model\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.vhs_collision_time","page":"Theory","title":"KitBase.vhs_collision_time","text":"vhs_collision_time(prim::T, muRef, omega) where {T<:AbstractArray{<:Real,1}}\n\nCalculate collision time with variable hard sphere (VHS) model\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.aap_hs_collision_time","page":"Theory","title":"KitBase.aap_hs_collision_time","text":"Calculate mixture collision time from AAP model\n\naap_hs_collision_time(     prim::AbstractArray{<:Real,2},     mi::Real,     ni::Real,     me::Real,     ne::Real,     kn::Real, )\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.aap_hs_prim","page":"Theory","title":"KitBase.aap_hs_prim","text":"Calculate mixture primitive variables from AAP model\n\ntested √\n\naap_hs_prim(     prim::AbstractArray{<:Real,2},     tau::AbstractArray{<:Real,1},     mi::Real,     ni::Real,     me::Real,     ne::Real,     kn::Real, )\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.aap_hs_diffeq!","page":"Theory","title":"KitBase.aap_hs_diffeq!","text":"Source term of AAP model in DifferentialEquations.jl\n\naap_hs_diffeq!(du, u, p, t)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.shift_pdf!","page":"Theory","title":"KitBase.shift_pdf!","text":"Shift distribution function by external force\n\nshift_pdf!(\n    f::T,\n    a,\n    du,\n    dt,\n) where {T<:AbstractArray{<:AbstractFloat,1}}\n\nshift_pdf!(\n    f::X,\n    a::Y,\n    du::Z,\n    dt,\n) where {X<:AbstractArray{<:AbstractFloat,2},Y<:AbstractArray{<:Real,1},Z<:AbstractArray{<:AbstractFloat,1}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.hs_boltz_kn","page":"Theory","title":"KitBase.hs_boltz_kn","text":"Calculate effective Knudsen number for fast spectral method with hard sphere (HS) model\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.kernel_mode","page":"Theory","title":"KitBase.kernel_mode","text":"Calculate collision kernel for fast spectral method\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.boltzmann_fft","page":"Theory","title":"KitBase.boltzmann_fft","text":"Calculate collision operator with FFT-based fast spectral method\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.boltzmann_fft!","page":"Theory","title":"KitBase.boltzmann_fft!","text":"Calculate collision operator with FFT-based fast spectral method\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.heat_capacity_ratio","page":"Theory","title":"KitBase.heat_capacity_ratio","text":"Calculate heat capacity ratio\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.sound_speed","page":"Theory","title":"KitBase.sound_speed","text":"Calculate speed of sound\n\n\n\n\n\n","category":"function"},{"location":"api_io/#I-/-O","page":"I / O","title":"I / O","text":"","category":"section"},{"location":"api_io/","page":"I / O","title":"I / O","text":"read_dict","category":"page"},{"location":"api_io/#KitBase.read_dict","page":"I / O","title":"KitBase.read_dict","text":"Read text into dictionary\n\nread_dict(filename::String, allowed)\nread_dict(filename::String)\n\n@args filename: configuration text file\n@args allowed: keywords\n@return vars: dictionary with values of variables\n\n\n\n\n\n","category":"function"},{"location":"install/#Installation-Instructions","page":"Installation","title":"Installation Instructions","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Kinetic is a registered Julia package in the official entry. We recommend installing it with the built-in Julia package manager, because this automatically installs a stable, tagged release.  From the Julia REPL, you could add the package and instantiate/build all dependencies via","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> ]\n(v1.5) pkg> add Kinetic\n(v1.5) pkg> build Kinetic","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This will install Kinetic and all its dependencies. After that, using/import the package,","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using Kinetic","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Kinetic can be updated to the latest tagged release from the package manager by executing","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(v1.5) pkg> update Kinetic","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"tip: Use Julia 1.3 or newer\nKinetic matches perfectly with Julia 1.3 and newer versions. Installing it with an older version of Julia will locate incomplete functionality.","category":"page"},{"location":"api_config/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"api_config/","page":"Configuration","title":"Configuration","text":"ib_rh\nib_sod\nib_briowu\nib_cavity","category":"page"},{"location":"api_config/#KitBase.ib_rh","page":"Configuration","title":"KitBase.ib_rh","text":"Initialize Rankine-Hugoniot relation\n\n1d1f1v: ib_rh(MaL, gam, u::T) where {T<:AbstractArray{<:AbstractFloat,1}}\n1d2f1v: ib_rh(MaL, gam, u::T, K) where {T<:AbstractArray{<:AbstractFloat,1}}\n1d1f3v: ib_rh(MaL, gam, u::T, v::T, w::T) where {T<:AbstractArray{<:AbstractFloat,3}}\n\n\n\n\n\n","category":"function"},{"location":"api_config/#KitBase.ib_sod","page":"Configuration","title":"KitBase.ib_sod","text":"Initialize Sod shock tube\n\n1d1f1v: ib_sod(γ, u::T) where {T<:AbstractArray{<:AbstractFloat,1}}\n1d1f3v: ib_sod(γ, u::T, v::T, w::T) where {T<:AbstractArray{<:AbstractFloat,3}}\n1d2f1v: ib_sod(γ, u::T, K) where {T<:AbstractArray{<:AbstractFloat,1}}\n\n\n\n\n\n","category":"function"},{"location":"api_config/#KitBase.ib_briowu","page":"Configuration","title":"KitBase.ib_briowu","text":"Initialize Brio-Wu MHD shock\n\nib_briowu(gam, uspace::T, mi, me) where {T<:AbstractArray{<:AbstractFloat,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_config/#KitBase.ib_cavity","page":"Configuration","title":"KitBase.ib_cavity","text":"Initialize lid-driven cavity\n\n2d1f2v: ib_cavity(gam, Um, Vm, Tm, u::T, v::T) where {T<:AbstractArray{<:AbstractFloat,2}}\n2d2f2v: ib_cavity(gam, Um, Vm, Tm, u::T, v::T, K) where {T<:AbstractArray{<:AbstractFloat,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#Physical-Space","page":"Physical Space","title":"Physical Space","text":"","category":"section"},{"location":"api_geo/","page":"Physical Space","title":"Physical Space","text":"global_frame\nlocal_frame\nPSpace1D\nPSpace2D\nuniform_mesh\nmeshgrid\nUnstructMesh \nread_mesh\nmesh_connectivity_2D\nmesh_center_2D\nmesh_area_2D","category":"page"},{"location":"api_geo/#KitBase.global_frame","page":"Physical Space","title":"KitBase.global_frame","text":"Transform local flow variables to global frame\n\n2D: global_frame(w::AbstractArray{<:Real,1}, cosa, sina)\n3D: global_frame(w::AbstractArray{<:Real,1}, dirccos::AbstractArray{<:Real,2})\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.local_frame","page":"Physical Space","title":"KitBase.local_frame","text":"Transform global flow variables to local frame\n\n2D: local_frame(w::AbstractArray{<:Real,1}, cosa, sina)\n3D: local_frame(w::AbstractArray{<:Real,1}, dirccos::AbstractArray{<:Real,2})\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.PSpace1D","page":"Physical Space","title":"KitBase.PSpace1D","text":"1D physical space with structured mesh\n\n@consts: x0, x1, nx, x, dx\n\n\n\n\n\n","category":"type"},{"location":"api_geo/#KitBase.PSpace2D","page":"Physical Space","title":"KitBase.PSpace2D","text":"2D Physical space with structured mesh\n\n@consts: x0, x1, nx, y0, y1, ny, x, y, dx, dy\n\n\n\n\n\n","category":"type"},{"location":"api_geo/#KitBase.uniform_mesh","page":"Physical Space","title":"KitBase.uniform_mesh","text":"uniform_mesh(x0::Real, xnum::Int, dx::Real)\n\nGenerate uniform mesh\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.meshgrid","page":"Physical Space","title":"KitBase.meshgrid","text":"Equivalent structured mesh generator as matlab\n\n2D: meshgrid(x::AbstractArray{<:Real,1}, y::AbstractArray{<:Real,1})\n3D: meshgrid(x::AbstractArray{<:Real,1}, y::AbstractArray{<:Real,1}, z::AbstractArray{<:Real,1})\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.UnstructMesh","page":"Physical Space","title":"KitBase.UnstructMesh","text":"Physical space with unstructured mesh\n\n@consts: nodes, cells\n\n\n\n\n\n","category":"type"},{"location":"api_geo/#KitBase.read_mesh","page":"Physical Space","title":"KitBase.read_mesh","text":"Read mesh file\n\nread_mesh(file)\n\n@return nodes : are saved with 3D coordinates (z=0 for 2D case)\n@return cells : node ids inside cells\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.mesh_connectivity_2D","page":"Physical Space","title":"KitBase.mesh_connectivity_2D","text":"Compute connectivity of 2D unstructured mesh\n\nmesh_connectivity_2D(cells::AbstractArray{<:Int,2})\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.mesh_center_2D","page":"Physical Space","title":"KitBase.mesh_center_2D","text":"Compute central points of 2D elements\n\nmesh_center_2D(nodes::AbstractArray{<:AbstractFloat,2}, cells::AbstractArray{<:Int,2})\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.mesh_area_2D","page":"Physical Space","title":"KitBase.mesh_area_2D","text":"Compute areas of 2D elements\n\nmesh_area_2D(nodes::AbstractArray{<:AbstractFloat,2}, cells::AbstractArray{<:Int,2})\n\n\n\n\n\n","category":"function"},{"location":"api_phase/#Phase-Space","page":"Phase Space","title":"Phase Space","text":"","category":"section"},{"location":"api_phase/","page":"Phase Space","title":"Phase Space","text":"VSpace1D\nVSpace2D\nVSpace3D\nMVSpace1D\nMVSpace2D\nMVSpace3D\nnewton_cotes\nlegendre_quadrature\nocta_quadrature\nquadrature_weights","category":"page"},{"location":"api_phase/#KitBase.VSpace1D","page":"Phase Space","title":"KitBase.VSpace1D","text":"1D velocity space\n\n@consts: u0, u1, nu, u, du, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.VSpace2D","page":"Phase Space","title":"KitBase.VSpace2D","text":"2D velocity space\n\n@consts: u0, u1, nu, v0, v1, nv, u, v, du, dv, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.VSpace3D","page":"Phase Space","title":"KitBase.VSpace3D","text":"3D velocity space\n\n@consts: u0, u1, nu, v0, v1, nv, w0, w1, nw, u, v, w, du, dv, dw, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.MVSpace1D","page":"Phase Space","title":"KitBase.MVSpace1D","text":"1D multi-component velocity space\n\n@consts: u0, u1, nu, u, du, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.MVSpace2D","page":"Phase Space","title":"KitBase.MVSpace2D","text":"2D multi-component velocity space\n\n@consts: u0, u1, nu, v0, v1, nv, u, v, du, dv, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.MVSpace3D","page":"Phase Space","title":"KitBase.MVSpace3D","text":"3D multi-component velocity space\n\n@consts: u0, u1, nu, v0, v1, nv, w0, w1, nw, u, v, w, du, dv, dw, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.newton_cotes","page":"Phase Space","title":"KitBase.newton_cotes","text":"newton_cotes(idx::T, num::T) where {T<:Integer}\n\nEvaluate quadrature weight from Newton-Cotes rule\n\n\n\n\n\n","category":"function"},{"location":"api_phase/#KitBase.legendre_quadrature","page":"Phase Space","title":"KitBase.legendre_quadrature","text":"Gauss-Legendre quadrature\n\nlegendre_quadrature(n::Int)\n\n@arg n : quadrature order (MUST be even)\n@return points : quadrature points in 3D coordinate\n@return weights : quadrature weights\n\n\n\n\n\n","category":"function"},{"location":"api_phase/#KitBase.octa_quadrature","page":"Phase Space","title":"KitBase.octa_quadrature","text":"Octaeder quadrature\n\nocta_quadrature(n::Int, slerpflag = true::Bool)\n\n@arg n : quadrature order\n@arg slerpflag : flag of spherical linear interpolation\n@return points\n@return triangulation\n\n\n\n\n\n","category":"function"},{"location":"api_phase/#KitBase.quadrature_weights","page":"Phase Space","title":"KitBase.quadrature_weights","text":"Create quadrature weights from points and triangulation\n\ncreate_weights(n::Int, xyz::AbstractArray{<:Real,2}, triangles::AbstractArray{Int,2})\n\n@arg xyz : quadrature points\n@arg triangles : triangulation\n@return weights : quadrature weights\n\n\n\n\n\n","category":"function"},{"location":"solver/#General","page":"General","title":"General","text":"","category":"section"},{"location":"solver/","page":"General","title":"General","text":"Kinetic employs the finite volume method (FVM) for modeling and simulation.  The general solution algorithm can be conclude as follows, where both explicit and implicit methods are implemented.","category":"page"},{"location":"solver/","page":"General","title":"General","text":"(Image: )","category":"page"},{"location":"solver/","page":"General","title":"General","text":"The high-level solver function is ","category":"page"},{"location":"solver/","page":"General","title":"General","text":"solve!","category":"page"},{"location":"solver/#KitBase.solve!","page":"General","title":"KitBase.solve!","text":"Solution algorithm\n\n1D solver: solve!(KS::SolverSet, ctr::AbstractArray{<:AbstractControlVolume1D,1},   face::Array{<:AbstractInterface1D,1}, simTime::Float64)\n@return: ending time\n\n\n\n\n\n","category":"function"},{"location":"solver/","page":"General","title":"General","text":"The detailed solution procedures can be concluded as follows","category":"page"},{"location":"solver/","page":"General","title":"General","text":"pre-process\ntimestep calculation\nreconstruction\nevolution\nupdate\npost-process","category":"page"},{"location":"api_step/#Stepper","page":"Stepper","title":"Stepper","text":"","category":"section"},{"location":"api_step/","page":"Stepper","title":"Stepper","text":"KitBase.step!","category":"page"},{"location":"api_step/#KitBase.step!","page":"Stepper","title":"KitBase.step!","text":"Update flow variables with finite volume formulation\n\nwrapper: step!(ks, faceL, cell, faceR, dt, res, avg, collision=:bgk, isMHD=:true)\n\n1d0f: step!(fwL, w, prim, fwR, γ, dx, RES, AVG)\n\n1d1f1v: step!(fwL, ffL, w, prim, f, fwR, ffR, u, weights, γ, μᵣ, ω, Pr, dx, dt, RES, AVG, collision=:bgk)\n\n1d1f3v: step!(fwL, ffL, w, prim, f, fwR, ffR, uVelo, vVelo, wVelo, weights, γ, μᵣ, ω, Pr, dx, dt, RES, AVG, collision=:bgk)\n\n1d2f1v: step!(fwL, fhL, fbL, w, prim, h, b, fwR, fhR, fbR, u, weights, K, γ, μᵣ, ω, Pr, dx, dt, RES, AVG, collision=:bgk)\n\n1d2f1v2s: step!(fwL, fhL, fbL, w, prim, h, b, fwR, fhR, fbR, u, weights, K, γ, mi, ni, me, ne, Kn, Pr, dx, dt, RES, AVG, collision=:bgk)\n\n\n\n\n\n","category":"function"},{"location":"api_step/","page":"Stepper","title":"Stepper","text":"Kinetic.initialize Kinetic.initfvm SolverSet setib solve! Kinetic.timestep reconstruct! evolve! update! update_boundary! step!","category":"page"},{"location":"solver_flux/#Evolution","page":"Evolution","title":"Evolution","text":"","category":"section"},{"location":"solver_flux/","page":"Evolution","title":"Evolution","text":"evolve!","category":"page"},{"location":"solver_flux/#KitBase.evolve!","page":"Evolution","title":"KitBase.evolve!","text":"Evolution\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/","page":"Evolution","title":"Evolution","text":"The evolution solver calculate the interface numerical fluxes based on two neighbor cells.","category":"page"},{"location":"solver_flux/","page":"Evolution","title":"Evolution","text":"macroscopic: Godunov, Lax, Roe, HLL, wave-propagation\nmesoscopic: upwind, central-upwind, gas-kinetic scheme","category":"page"},{"location":"solver_flux/","page":"Evolution","title":"Evolution","text":"The available flux solvers are","category":"page"},{"location":"solver_flux/","page":"Evolution","title":"Evolution","text":"flux_lax!\nflux_hll!\nflux_roe!\nflux_gks\nflux_gks!\nflux_kfvs!\nflux_kcu!\nflux_ugks!\nflux_boundary_maxwell!\nflux_boundary_specular!\nflux_em!\nflux_emx!\nflux_emy!","category":"page"},{"location":"solver_flux/#KitBase.flux_lax!","page":"Evolution","title":"KitBase.flux_lax!","text":"Lax-Friedrichs flux\n\nflux_lax!(fw::AbstractArray{<:Real,1}, wL::AbstractArray{<:Real,1}, wR::AbstractArray{<:Real,1}, γ::Real, dt::Real, dx::Real)\n\nP. D. Lax, Weak Solutions of Nonlinear Hyperbolic Equations and Their Numerical Computation, Commun. Pure and Applied Mathematics, 7, 159-193, 1954.\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_hll!","page":"Evolution","title":"KitBase.flux_hll!","text":"HLL flux for the Euler equations\n\nflux_hll!(fw::AbstractArray{<:Real,1}, wL::AbstractArray{<:Real,1}, wR::AbstractArray{<:Real,1}, γ::Real, dt::Real)\n\n@args: variables at left & right sides of interface\n@args: specific heat ratio\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_roe!","page":"Evolution","title":"KitBase.flux_roe!","text":"Roe's flux with entropy fix\n\nflux_roe!(fw::AbstractArray{<:Real,1}, wL::AbstractArray{<:Real,1}, wR::AbstractArray{<:Real,1},\nγ::Real, dt::Real, n = [1.0, 0.0]::AbstractArray{<:Real,1})\n\nP. L. Roe, Approximate Riemann Solvers, Parameter Vectors and Difference Schemes, Journal of Computational Physics, 43, pp. 357-372. (cf. http://cfdbooks.com/cfdcodes.html)\n\n@args primL[1:4] = left state (rhoL, uL, vL, pL)\n@args primR[1:4] = right state (rhoR, uR, vR, pR)\n@args γ: specific heat ratio\n@args n[2]: unit face normal (L -> R)\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_gks","page":"Evolution","title":"KitBase.flux_gks","text":"Gas kinetic flux\n\nflux_gks(u::Real, μ::Real, dt::Real, su = 0.0::Real, a = 0::Real)\nflux_gks(uL::Real, uR::Real, μ::Real, dt::Real, dxL::Real,\n    dxR::Real, suL = 0.0::Real, suR = 0.0::Real, a = 0::Real)\n\n@args: conservative scalars and their slopes\n@args: viscosity\n@args: time step and cell size\n@return: scalar flux\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_gks!","page":"Evolution","title":"KitBase.flux_gks!","text":"Gas kinetic Navier-Stokes flux\n\n1D: flux_gks!(fw, wL, wR, γ, K, μᵣ, ω, dt, dx, swL, swR)\n2D: flux_gks!(fw, wL, wR, γ, K, μᵣ, ω, dt, dx, dy, swL, swR)\n\n@args: conservative variables and their left/right slopes\n@args: molecular and thermodynamic parameters\n@args: time step and cell size\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_kfvs!","page":"Evolution","title":"KitBase.flux_kfvs!","text":"Kinetic flux vector splitting (KFVS) flux\n\nDOM: `flux_kfvs!(ff, fL, fR, u, dt, sfL, sfR)`\n1D1F1V: `flux_kfvs!(fw, ff, fL, fR, u, ω, dt, sfL, sfR)`\n1D1F3V: `flux_kfvs!(fw, ff, fL, fR, u, v, w, ω, dt, sfL, sfR)`\n1D2F1V: `flux_kfvs!(fw, fh, fb, hL, bL, hR, bR, u, ω, dt, shL, sbL, shR, sbR)`\n1D4F1V: `flux_kfvs!(fw, fh0, fh1, fh2, fh3, h0L, h1L, h2L, h3L, h0R, h1R, h2R, h3R, u, ω, dt, sh0L, sh1L, sh2L, sh3L, sh0R, sh1R, sh2R, sh3R)`\n2D1F2V: `flux_kfvs!(fw, ff, fL, fR, u, v, ω, dt, len, sfL, sfR)`\n2D2F2V: `flux_kfvs!(fw, fh, fb, hL, bL, hR, bR, u, v, ω, dt, len, shL, sbL, shR, sbR)`\n\n@args: particle distribution functions and their left/right slopes\n@args: particle velocity quadrature points and weights\n@args: time step and cell size\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_kcu!","page":"Evolution","title":"KitBase.flux_kcu!","text":"Kinetic central-upwind (KCU) method\n\n1D1F1V: flux_kcu!(fw, ff, wL, fL, wR, fR, u, ω, inK, γ, visRef, visIdx, Pr, dt)\n1D2F1V: flux_kcu!(fw, fh, fb, wL, hL, bL, wR, hR, bR, u, ω, inK, γ, visRef, visIdx, Pr, dt)\n1D4F1V: flux_kcu!(fw, fh0, fh1, fh2, fh3, wL, h0L, h1L, h2L, h3L, wR, h0R, h1R, h2R, h3R, u, ω, inK, γ, visRef, visIdx, Pr, dt)\n2D1F2V: flux_kcu!(fw, ff, wL, fL, wR, fR, u, v, ω, inK, γ, visRef, visIdx, Pr, dt, len)\n2D2F2V: flux_kcu!(fw, fh, fb, wL, hL, bL, wR, hR, bR, u, v, ω, inK, γ, visRef, visIdx, Pr, dt, len)\n2D3F2V: flux_kcu!(fw, fh0, fh1, fh2, wL, h0L, h1L, h2L, wR, h0R, h1R, h2R, u, v, ω, inK, γ, visRef, visIdx, Pr, dt, len)\n\n@args: particle distribution functions and their slopes at left/right sides of interface\n@args: particle velocity quadrature points and weights\n@args: time step and cell size\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_ugks!","page":"Evolution","title":"KitBase.flux_ugks!","text":"Unified gas kinetic scheme (UGKS)\n\n@args: particle distribution functions and their slopes at left/right sides of interface\n@args: particle velocity quadrature points and weights\n@args: time step\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_boundary_maxwell!","page":"Evolution","title":"KitBase.flux_boundary_maxwell!","text":"Maxwell's diffusive boundary flux\n\n@args: particle distribution functions and their slopes at left/right sides of interface\n@args: particle velocity quadrature points and weights\n@args: time step\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_em!","page":"Evolution","title":"KitBase.flux_em!","text":"Wave propagation method for Maxwell's equations\n\nflux_em!(femL, femR, ELL, BLL, EL, BL, ER, BR, ERR, BRR, ϕL, ϕR, ψL, ψR, dxL, dxR, Ap, An, D, sol, χ, ν, dt)\n\n@args: {E, B, ϕ, ψ} in left-left, left, right, and right-right cells\n@args: eigenmatrix (A -> A+ & A-), eigenvalue (D)\n@args: full size of left & right cells\n@args: speed of light (sol)\n@args: auxiliary parameters (χₑ, νᵦ)\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_emx!","page":"Evolution","title":"KitBase.flux_emx!","text":"Wave propagation method for 2D Maxwell's equations\n\nflux_emx!(femL, femR, femLU, femLD, femRU, femRD,\nELL, BLL, EL, BL, ER, BR, ERR, BRR, ϕL, ϕR, ψL, ψR,\ndxL, dxR, A1p, A1n, A2p, A2n, D, sol, χ, ν, dt)\n\n@args: {E, B, ϕ, ψ} in left-left, left, right, and right-right cells\n@args: eigenmatrix (A -> A+ & A-), eigenvalue (D)\n@args: full size of left & right cells\n@args: speed of light (sol)\n@args: auxiliary parameters (χₑ, νᵦ)\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_emy!","page":"Evolution","title":"KitBase.flux_emy!","text":"Wave propagation method for 2D Maxwell's equations\n\nflux_emx!(femL, femR, femLU, femLD, femRU, femRD,\nELL, BLL, EL, BL, ER, BR, ERR, BRR, ϕL, ϕR, ψL, ψR,\ndxL, dxR, A1p, A1n, A2p, A2n, D, sol, χ, ν, dt)\n\n@args: {E, B, ϕ, ψ} in left-left, left, right, and right-right cells\n@args: eigenmatrix (A -> A+ & A-), eigenvalue (D)\n@args: full size of left & right cells\n@args: speed of light (sol)\n@args: auxiliary parameters (χₑ, νᵦ)\n\n\n\n\n\n","category":"function"},{"location":"solver_timestep/#Timestep","page":"Timestep","title":"Timestep","text":"","category":"section"},{"location":"solver_timestep/","page":"Timestep","title":"Timestep","text":"timestep","category":"page"},{"location":"solver_timestep/#KitBase.timestep","page":"Timestep","title":"KitBase.timestep","text":"Timestep calculator\n\n1D solver: timestep(KS::SolverSet, ctr::AbstractArray{<:AbstractControlVolume1D,1},   simTime::Real)\n@return: Δt\n\n\n\n\n\n","category":"function"},{"location":"solver_timestep/","page":"Timestep","title":"Timestep","text":"The timestep solver returns the time interval used for the upcoming solution loop based on the current variables.","category":"page"},{"location":"type/#Data-Structure","page":"Type","title":"Data Structure","text":"","category":"section"},{"location":"type/","page":"Type","title":"Type","text":"Kinetic is organized with the data structures and methods of both generality and convenience.  While most of the methods can be applied to multi-dimensional arrays directly, we provide a set of domain-specific structs that handles multiple dispatch in an elegant way. In the finite volume method, the data is stored separately throughout the cells. Therefore, we provide AbstractControlVolume structs for solving different equations that are used as arrays of structs (AoS) in the simulations.","category":"page"},{"location":"type/","page":"Type","title":"Type","text":"The 1D control volume structs are","category":"page"},{"location":"type/","page":"Type","title":"Type","text":"ControlVolume1D\nControlVolume1D1F\nControlVolume1D2F\nControlVolume1D3F\nControlVolume1D4F","category":"page"},{"location":"type/#KitBase.ControlVolume1D","page":"Type","title":"KitBase.ControlVolume1D","text":"1D control volume with no distribution function\n\nControlVolume1D(X::Real, DX::Real, W::AbstractArray, PRIM::AbstractArray)\n\n@vars: x, dx, w, prim, sw\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume1D1F","page":"Type","title":"KitBase.ControlVolume1D1F","text":"1D control volume with 1 distribution function\n\nControlVolume1D1F(X::Real, DX::Real, W::AbstractArray, PRIM::AbstractArray, F::AbstractArray)\n\n@vars: x, dx, w, prim, sw, f, sf\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume1D2F","page":"Type","title":"KitBase.ControlVolume1D2F","text":"1D control volume with 2 distribution functions\n\nControlVolume1D2F(X::Real, DX::Real, W::AbstractArray, PRIM::AbstractArray, H::AbstractArray, B::AbstractArray)\n\n@vars: x, dx, w, prim, sw, h, b, sh, sb\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume1D3F","page":"Type","title":"KitBase.ControlVolume1D3F","text":"1D control volume with 3 distribution functions\n\nControlVolume1D3F(X, DX, W, PRIM, H0, H1, H2, E0, B0, L)\n\n@vars: x, dx, w, prim, sw, h0, h1, h2, sh0, sh1, sh2, E, B, ϕ, ψ, lorenz\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume1D4F","page":"Type","title":"KitBase.ControlVolume1D4F","text":"1D control volume with 4 distribution functions\n\nControlVolume1D4F(X, DX, W, PRIM, H0, H1, H2, H3, E0, B0, L)\n\n@vars: x, dx, w, prim, sw, h0, h1, h2, h3, sh0, sh1, sh2, sh3, E, B, ϕ, ψ, lorenz\n\n\n\n\n\n","category":"type"},{"location":"type/","page":"Type","title":"Type","text":"The 2D control volume structs are","category":"page"},{"location":"type/","page":"Type","title":"Type","text":"ControlVolume2D\nControlVolume2D1F\nControlVolume2D2F\nControlVolume2D3F","category":"page"},{"location":"type/#KitBase.ControlVolume2D","page":"Type","title":"KitBase.ControlVolume2D","text":"2D control volume with no distribution function\n\nControlVolume2D(X::Real, DX::Real, Y::Real, DY::Real, W::AbstractArray, PRIM::AbstractArray)\n\n@vars: x, y, dx, dy, w, prim, sw\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume2D1F","page":"Type","title":"KitBase.ControlVolume2D1F","text":"2D control volume with 1 distribution function\n\nControlVolume2D1F(X::Real, DX::Real, Y::Real, DY::Real, W::AbstractArray, PRIM::AbstractArray, F::AbstractArray)\n\n@vars: x, y, dx, dy, w, prim, sw, f, sf\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume2D2F","page":"Type","title":"KitBase.ControlVolume2D2F","text":"2D control volume with 2 distribution functions\n\nControlVolume2D2F(X::Real, DX::Real, Y::Real, DY::Real, W::AbstractArray, PRIM::AbstractArray, H::AbstractArray, B::AbstractArray)\n\n@vars: x, y, dx, dy, w, prim, sw, h, b, sh, sb\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume2D3F","page":"Type","title":"KitBase.ControlVolume2D3F","text":"2D control volume with 3 distribution functions\n\nControlVolume2D3F(X, DX, Y, DY, W, PRIM, H0, H1, H2, E0, B0, L)\n\n@vars: x, y, dx, dy, w, prim, sw, h0, h1, h2, sh0, sh1, sh2, E, B, ϕ, ψ, lorenz\n\n\n\n\n\n","category":"type"},{"location":"type/","page":"Type","title":"Type","text":"The numerical fluxes are evaluated through AbstractInterface structs","category":"page"},{"location":"type/","page":"Type","title":"Type","text":"Interface1D\nInterface1D1F\nInterface1D2F\nInterface1D3F\nInterface1D4F\nInterface2D\nInterface2D1F\nInterface2D2F","category":"page"},{"location":"type/#KitBase.Interface1D","page":"Type","title":"KitBase.Interface1D","text":"1D cell interface with no distribution function\n\n@vars: fw\n\nInterface1D(w::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface1D1F","page":"Type","title":"KitBase.Interface1D1F","text":"1D cell interface with 1 distribution function\n\n@vars: fw, ff\n\nInterface1D1F(w::AbstractArray, f::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface1D2F","page":"Type","title":"KitBase.Interface1D2F","text":"1D cell interface with 2 distribution functions\n\n@vars: fw, fh, fb\n\nInterface1D2F(w::AbstractArray, f::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface1D3F","page":"Type","title":"KitBase.Interface1D3F","text":"1D cell interface with 3 distribution functions\n\n@vars: fw, fh0, fh1, fh2, femL, femR,\n\ndeterministic: Interface1D3F(w::AbstractArray, f::AbstractArray, E::AbstractArray{<:Real,1})\nstochastic: Interface1D3F(w::AbstractArray, f::AbstractArray, E::AbstractArray{<:Real,2})\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface1D4F","page":"Type","title":"KitBase.Interface1D4F","text":"1D cell interface with 4 distribution functions\n\n@vars: fw, fh0, fh1, fh2, fh3, femL, femR,\n\ndeterministic: Interface1D4F(w::AbstractArray, f::AbstractArray, E::AbstractArray{<:Real,1})\nstochastic: Interface1D4F(w::AbstractArray, f::AbstractArray, E::AbstractArray{<:Real,2})\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface2D","page":"Type","title":"KitBase.Interface2D","text":"2D cell interface with no distribution function\n\n@vars: len, n, fw\n\nInterface2D(L::Real, C::Real, S::Real, w::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface2D1F","page":"Type","title":"KitBase.Interface2D1F","text":"2D cell interface with 1 distribution function\n\n@vars: len, n, fw, ff\n\nInterface2D1F(L::Real, C::Real, S::Real, w::AbstractArray, f::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface2D2F","page":"Type","title":"KitBase.Interface2D2F","text":"2D cell interface with 2 distribution functions\n\n@vars: len, n, fw, fh, fb\n\nInterface2D2F(L::Real, C::Real, S::Real, w::AbstractArray, f::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"type/","page":"Type","title":"Type","text":"The rest structs for saving general computational setups are","category":"page"},{"location":"type/","page":"Type","title":"Type","text":"SolverSet","category":"page"},{"location":"type/#KitBase.SolverSet","page":"Type","title":"KitBase.SolverSet","text":"Structure of solver setup\n\n\n\n\n\n","category":"type"},{"location":"type/","page":"Type","title":"Type","text":"Modules = [KitBase]\nOrder = [:type]","category":"page"},{"location":"type/#KitBase.ControlVolumeParticle1D","page":"Type","title":"KitBase.ControlVolumeParticle1D","text":"ControlVolume1D(X::Real, DX::Real, W::AbstractArray, PRIM::AbstractArray)\n\n1D control volume in correspondence with particle simulation\n\n@vars: x, dx, w, prim, sw, wg, τ, np, vrmax, remainder\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolumeParticle2D","page":"Type","title":"KitBase.ControlVolumeParticle2D","text":"ControlVolume2D(X::Real, DX::Real, Y::Real, DY::Real, W::AbstractArray, PRIM::AbstractArray)\n\n2D control volume in correspondence with particle simulation\n\n@vars: x, y, dx, dy, w, prim, sw, wg, τ, np, vrmax, remainder\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Gas","page":"Type","title":"KitBase.Gas","text":"Particle property\n\n@vars: Kn, Ma, Pr, K, γ, ω, αᵣ, ωᵣ, μᵣ, m, np\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.IB","page":"Type","title":"KitBase.IB","text":"Initial & boundary condition with no distribution function\n\n@consts: wL, primL, bcL, wR, primR, bcR, bcU, bcD\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.IB1F","page":"Type","title":"KitBase.IB1F","text":"Initial & boundary condition with 1 distribution function\n\n@consts: wL, primL, fL, bcL, wR, primR, fR, bcR, bcU, bcD\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.IB2F","page":"Type","title":"KitBase.IB2F","text":"Initial & boundary condition with 2 distribution functions\n\n@consts: wL, primL, hL, bL, bcL, wR, primR, hR, bR, bcR, bcU, bcD\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.IB3F","page":"Type","title":"KitBase.IB3F","text":"Initial & boundary condition with 3 distribution functions\n\n@consts: wL, primL, h0L, h1L, h2L, bcL, EL, BL, lorenzL, wR, primR, h0R, h1R, h2R, bcR, ER, BR, lorenzR, bcU, bcD\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.IB4F","page":"Type","title":"KitBase.IB4F","text":"Initial & boundary condition with 4 distribution functions\n\n@consts: wL, primL, h0L, h1L, h2L, h3L, bcL, EL, BL, lorenzL, wR, primR, h0R, h1R, h2R, h3R, bcR, ER, BR, lorenzR, bcU, bcD\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Mixture","page":"Type","title":"KitBase.Mixture","text":"Multi-component gas property\n\n@consts: Kn, Ma, Pr, K, γ, mi, ni, me, ne\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Particle","page":"Type","title":"KitBase.Particle","text":"Particle(M, X, V, E, IDX, FLAG = zeros(eltype(IDX), axes(IDX, 1)), T = zero(M))\n\nStruct of arrays for particle simulation\n\n@vars: m, x, v, e, idx, flag, tc\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Particle1D","page":"Type","title":"KitBase.Particle1D","text":"Particle1D(M::AbstractFloat, X::Real, V::AbstractArray, IDX::Integer, T::Real)\n\n1D particle\n\n@vars: m, x, v, e, idx, tc\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Particle2D","page":"Type","title":"KitBase.Particle2D","text":"Particle2D(M::AbstractFloat, X::Real, V::AbstractArray, IDX::Integer, T::Real)\n\n2D particle\n\n@vars: m, x, v, idx, tb\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Plasma1D","page":"Type","title":"KitBase.Plasma1D","text":"1D plasma property\n\n@consts: Kn, Ma, Pr, K, γ, mi, ni, me, ne, lD, rL, sol, χ, ν, Ap, An, D\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Plasma2D","page":"Type","title":"KitBase.Plasma2D","text":"2D plasma property\n\n@consts: Kn, Ma, Pr, K, γ, mi, ni, me, ne, lD, rL, sol, χ, ν, A1p, A1n, A2p, A2n, D1, D2\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Setup","page":"Type","title":"KitBase.Setup","text":"Computational setup\n\n@consts: case, space, flux, collision, nSpecies, interpOrder, limiter, cfl, maxTime\n\n\n\n\n\n","category":"type"},{"location":"api_math/#Math","page":"Math","title":"Math","text":"","category":"section"},{"location":"api_math/","page":"Math","title":"Math","text":"linspace\nheaviside\nfortsign\nmat_split\ncentral_diff\ncentral_diff!\nupwind_diff\nupwind_diff!\nunstruct_diff\nKitBase.lgwt\nKitBase.extract_last","category":"page"},{"location":"api_math/#KitBase.linspace","page":"Math","title":"KitBase.linspace","text":"Python linspace function\n\nlinspace(start::Real, stop::Real, n::Int)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.heaviside","page":"Math","title":"KitBase.heaviside","text":"Heaviside step function\n\nheaviside(x::Real)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.fortsign","page":"Math","title":"KitBase.fortsign","text":"Fortran sign function\n\nfortsign(x::Real, y::Real)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.mat_split","page":"Math","title":"KitBase.mat_split","text":"Split matrix into row vectors\n\nmat_split(m::AbstractArray)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.central_diff","page":"Math","title":"KitBase.central_diff","text":"Central difference\n\ncentral_diff(y::AbstractArray{<:Any,1}, x::AbstractArray{<:Any,1})\n\ncentral_diff(y::AbstractArray{<:Any,1}, dx::Any)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.central_diff!","page":"Math","title":"KitBase.central_diff!","text":"Central difference\n\ncentral_diff!(dy::AbstractArray{<:Any,1}, y::AbstractArray{<:Any,1}, x::AbstractArray{<:Any,1})\n\ncentral_diff!(dy::AbstractArray{<:Any,1}, y::AbstractArray{<:Any,1}, dx::Any)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.upwind_diff","page":"Math","title":"KitBase.upwind_diff","text":"Upwind difference\n\nupwind_diff(\n    y::AbstractArray{<:Any,1},\n    x::AbstractArray{<:Any,1};\n    stream = :right::Symbol,\n)\n\nupwind_diff(y::AbstractArray{<:Any,1}, dx::Any; stream = :right::Symbol)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.upwind_diff!","page":"Math","title":"KitBase.upwind_diff!","text":"Upwind difference\n\nupwind_diff!(\n    dy::AbstractArray{<:Any,1},\n    y::AbstractArray{<:Any,1},\n    x::AbstractArray{<:Any,1};\n    stream = :right::Symbol,\n)\n\nupwind_diff!(\n    dy::AbstractArray{<:Any,1},\n    y::AbstractArray{<:Any,1},\n    dx::Any;\n    stream = :right::Symbol,\n)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.unstruct_diff","page":"Math","title":"KitBase.unstruct_diff","text":"Finite difference for pseudo-unstructured mesh\n\nunstruct_diff(u::AbstractArray{<:Any,1}, x::AbstractArray{<:Any,1}, nx::Int; mode = :central::Symbol)\n\nunstruct_diff(u::Function, x::AbstractArray{<:Any,2}, nx::Int, dim::Int; mode = :central::Symbol)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.lgwt","page":"Math","title":"KitBase.lgwt","text":"Gauss Legendre integral for fast spectral method\n\nlgwt(N::Int, a::Real, b::Real)\n\n@args: number of quadrature points N, integral range [a, b]\n@args: quadrature points x & weights w\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.extract_last","page":"Math","title":"KitBase.extract_last","text":"Extract subarray except the last column\n\nextract_last(a::AbstractArray, idx::Int; mode=:view::Symbol)\n\n\n\n\n\n","category":"function"},{"location":"solver_post/#Post-process","page":"Post-process","title":"Post-process","text":"","category":"section"},{"location":"solver_post/","page":"Post-process","title":"Post-process","text":"plot_line\nwrite_jld","category":"page"},{"location":"solver_post/#KitBase.plot_line","page":"Post-process","title":"KitBase.plot_line","text":"Plot 1D profile\n\nplot_line(KS, ctr; backend)\n\n\n\n\n\n","category":"function"},{"location":"solver_post/#KitBase.write_jld","page":"Post-process","title":"KitBase.write_jld","text":"Write data into JLD2\n\nwrite_jld(KS, ctr, t)\n\n\n\n\n\n","category":"function"},{"location":"solver_post/","page":"Post-process","title":"Post-process","text":"The post-process solver handles the simulation data and visualization.","category":"page"},{"location":"physics/#Basic-Physics","page":"Physics","title":"Basic Physics","text":"","category":"section"},{"location":"physics/","page":"Physics","title":"Physics","text":"The physical world shows a diverse set of behaviors on different characteristic scales. Consider the molecular motion of gases as an example. Down to the finest scale of a many-particle system, the Newton's second law depicts particle motions via","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"mathbfF = m mathbfa","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"As a first order system it reads","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"fracd mathbf xdt = mathbf v  fracd mathbf vdt = fracmathbf Fm","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"An intuitive numerical algorithm is to get the numerous particles on board and track the trajectories of them. A typical example is the Molecular Dynamics. This is not going to be efficient since there are more than 2e25 molecules per cubic meter in normal atmosphere, and things get even more complicated when you count on the N-body interactions all the time. Some methods have been proposed to simplify the computation. As an example, the Direct simulation Monte Carlo employs certain molecular models and conduct the intermolecular collisions in a stochastic manner. It significantly reduces the computational cost, while the trade-off is the artificial fluctuations. Many realizations must be simulated successively to average the solutions and reduce the errors.","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"An alternative strategy is made from ensemble averaging, where the coarse-grained modeling is used to provide a bottom-up view. At the mean free path and collision time scale of molecules, particles travel freely during most of time with mild intermolecular collisions. Such dynamics can be described with an operator splitting approach, i.e. the kinetic transport equation","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"fracpartial fpartial t+ mathbf v cdot nabla_mathbf x f + mathbf a cdot nabla_mathbf v f = Q(f)","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"where the left and right hand sides model particle transports and collisions correspondingly. Different collision models can be inserted into such equation. If the particles only collide with a background material one obtains linear Boltzmann collision operator","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"Q(f)=int_mathbb R^3 mathcal B(mathbf v_* mathbf v) left f(mathbf v_*)-f(mathbf v)right dmathbf v_*","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"where the collision kernel mathcal B models the strength of collisions at different velocities.  If the interactions among particles are considered, the collision operator becomes nonlinear.  For example, the two-body collision results in nonlinear Boltzmann equation","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"Q(f)=int_mathbb R^3 int_mathcal S^2 mathcal B(cos beta mathbfv-mathbfv_*) left f(mathbf v)f(mathbf v_*)-f(mathbf v)f(mathbf v_*)right dmathbf Omega dmathbf v_*","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"To solve the Boltzmann equation, a discretized phase space needs to be introduced and the solution algorithm is called discrete ordinates method or discrete velocity method. Due to the complicated fivefold integral in the nonlinear Boltzmann collision operator, sometimes it is replaced by the simplified models in the discrete velocity method, e.g. the relaxation model","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"Q(f) = nu (mathcal M - f)","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"Meanwhile, with the enlargement of modeling scale to a macroscopic hydrodynamic level, the accumulating effect of particle collisions results in an equalization of local temperature and velocity, where the moderate non-equilibrium effects can be well described by viscous transport, heat conduction and mass diffusion, i.e., the so called transport phenomena.  Large-scale dynamics presents the property of waves, and the macroscopic transport equations can be constructed to describe the bulk behaviors of fluids. Typical examples are the Euler and Navier-Stokes equations","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"fracpartial mathbf Wpartial t + nabla_mathbf x cdot mathbf F = mathbf S","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"From microscopic particle transport to macroscopic fluid motion, there is a continuous variation of flow dynamics. ","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"Kinetic.jl is designed to solve different physical models. We pay special attentions to Hilbert's sixth problem, i.e. building the numerical passage between the kinetic theory of gases and continuum mechanics.  A list of current solvers include:","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"linear Boltzmann equation\nnonlinear Boltzmann equation\nnonlinear kinetic model equation\nmulti-component Boltzmann equations\nadvection-diffusion equation\nBurgers equation\nEuler equations\nNavier-Stokes equations\nExtended hydrodynamical equations from kinetic moments\nMagnetohydrodynamical equations\nTwo-fluid equations\nPoisson equation\nMaxwell's equations","category":"page"},{"location":"solver_pre/#Pre-process","page":"Pre-process","title":"Pre-process","text":"","category":"section"},{"location":"solver_pre/","page":"Pre-process","title":"Pre-process","text":"initialize","category":"page"},{"location":"solver_pre/#KitBase.initialize","page":"Pre-process","title":"KitBase.initialize","text":"Initialize solver from input file\n\n\n\n\n\n","category":"function"},{"location":"solver_pre/","page":"Pre-process","title":"Pre-process","text":"The pre-process solver initializes the simulation that returns solver set, control volumes, interfaces, and current time. It could be a new simulation or restart of an interrupted one.","category":"page"},{"location":"solver_pre/","page":"Pre-process","title":"Pre-process","text":"new run: .txt / .cfg / .toml / etc.\nrestart: .jld2","category":"page"},{"location":"solver_reconstruction/#Reconstruction","page":"Reconstruction","title":"Reconstruction","text":"","category":"section"},{"location":"solver_reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"reconstruct!","category":"page"},{"location":"solver_reconstruction/#KitBase.reconstruct!","page":"Reconstruction","title":"KitBase.reconstruct!","text":"Reconstructor\n\n1D solver: reconstruct!(KS::SolverSet, ctr::AbstractArray{<:AbstractControlVolume1D,1})\n2D solver: reconstruct!(KS::SolverSet, ctr::AbstractArray{ControlVolume2D2F,2})\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"The reconstruction solver interpolates piecewise solutions with the desirable order of accuracy. The reconstruction stencils can be based on 2 or 3 cells","category":"page"},{"location":"solver_reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"reconstruct2\nreconstruct2!\nreconstruct3\nreconstruct3!","category":"page"},{"location":"solver_reconstruction/#KitBase.reconstruct2","page":"Reconstruction","title":"KitBase.reconstruct2","text":"Two-cell reconstruction\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.reconstruct2!","page":"Reconstruction","title":"KitBase.reconstruct2!","text":"Two-cell reconstruction\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.reconstruct3","page":"Reconstruction","title":"KitBase.reconstruct3","text":"Three-cell reconstruction\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.reconstruct3!","page":"Reconstruction","title":"KitBase.reconstruct3!","text":"Three-cell reconstruction\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"The available schemes are","category":"page"},{"location":"solver_reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"vanleer\nminmod\nsuperbee\nvanalbaba\nweno5","category":"page"},{"location":"solver_reconstruction/#KitBase.vanleer","page":"Reconstruction","title":"KitBase.vanleer","text":"van Leer limiter\n\nvanleer(sL::Real, sR::Real)\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.minmod","page":"Reconstruction","title":"KitBase.minmod","text":"minmod limiter\n\nminmod(sL::Real, sR::Real)\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.superbee","page":"Reconstruction","title":"KitBase.superbee","text":"superbee limiter\n\nsuperbee(sL::Real, sR::Real)\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.vanalbaba","page":"Reconstruction","title":"KitBase.vanalbaba","text":"van Albaba limiter\n\nvanalbaba(sL::Real, sR::Real)\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.weno5","page":"Reconstruction","title":"KitBase.weno5","text":"5th-order WENO-JS interpolation\n\nweno5(wL2::T, wL1::T, wN::T, wR1::T, wR2::T) where {T}\n\n\n\n\n\n","category":"function"},{"location":"#Kinetic.jl","page":"Home","title":"Kinetic.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetic is a lightweight Julia toolbox for the study of computational fluid dynamics and scientific machine learning. The main module consists of KitBase.jl with basic physics and KitML.jl with neural dynamics.  The high-performance Fortran library KitFort.jl is optional and can be manually imported when the executing efficiency becomes the first priority.  A wrapper kineticpy has been built to locate the data hierarchies and methods in Python.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Kinetic is interested in theoretical modeling and numerical simulation of many-particle systems, e.g. gases, photons, plasmas, neutrons, electrons, etc. It employs the finite volume method (FVM) to conduct 1-3 dimensional numerical simulations on CPUs and GPUs. Any advection-diffusion type equation can be hooked and solved within the framework. The user interface is designed as intuitive and neat as possible. The combined development of high-level and low-level APIs allows users to focus on physics and to cooperate with existing packages in the Julia ecosystem.","category":"page"},{"location":"#Getting-help","page":"Home","title":"Getting help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are interested in using Kinetic.jl or are trying to figure out how to use it, please feel free to get in touch and raise questions. Open an issue or pull request if you have questions, suggestions or solutions.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Simulating-gas-dynamics-in-a-few-lines","page":"Tutorial","title":"Simulating gas dynamics in a few lines","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the following, we present an illustrative example of the shock tube problem in gas dynamics.  First let us prepare the configuration file as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# case\ncase = sod\nspace = 1d2f1v\nnSpecies = 1\nflux = kfvs\ncollision = bgk\ninterpOrder = 2\nlimiter = vanleer\nboundary = fix\ncfl = 0.5\nmaxTime = 0.2\n\n# physical space\nx0 = 0\nx1 = 1\nnx = 200\npMeshType = uniform\nnxg = 1\n\n# velocity space\nvMeshType = rectangle\numin = -5\numax = 5\nnu = 28\nnug = 0\n\n# gas\nknudsen = 0.0001\nmach = 0.0\nprandtl = 1\ninK = 2\nomega = 0.81\nalphaRef = 1.0\nomegaRef = 0.5","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The configuration file can be understood as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The simulation case is the standard Sod shock tube\nA phase space in 1D physical and 1D velocity space is created with two particle distribution functions inside\nThe numerical flux function is the kinetic flux vector splitting method and the collision term uses the BGK relaxation\nThe reconstruction step employs van Leer limiter to create 2nd-order interpolation\nThe two boundaries are fixed with Dirichlet boundary condition\nThe timestep is determined with a CFL number of 0.5\nThe maximum simulation time is 0.2\nThe physical space spans in [0, 1] with 200 uniform cells\nThe velocity space spans in [-5, 5] with 28 uniform cells\nThe reference Knudsen number is set as 1e-4\nThe reference Mach number is absent\nThe reference Prandtl number is 1\nThe gas molecule contains two internal degrees of freedom\nThe viscosity is evaluated with the following formulas","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"mu = mu_ref left(fracTT_refright)^omega","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"mu_ref=frac5(alpha+1)(alpha+2) sqrtpi4 alpha(5-2 omega)(7-2 omega) Kn_ref","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The configuration can be stored in any text format.  For example, if config.txt is created,  we then execute the following codes to conduct a simulation","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Kinetic\nset, ctr, face, t = initialize(\"config.txt\")\nt = solve!(set, ctr, face, t)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The computational setup is stored in set and the control volume solutions are stored in ctr and face.  The high-level solver solve! is equivalent as the following low-level procedures","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dt = timestep(ks, ctr, t)\nnt = Int(floor(ks.set.maxTime / dt))\nres = zeros(3)\nfor iter = 1:nt\n    reconstruct!(ks, ctr)\n    evolve!(ks, ctr, face, dt)\n    update!(ks, ctr, face, dt, res)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The result can be visualized with built-in function plot_line, which presents the profiles of gas density, velocity and temperature inside the tube.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_line(set, ctr)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"}]
}
