var documenterSearchIndex = {"docs":
[{"location":"solver_update/#Update","page":"Update","title":"Update","text":"","category":"section"},{"location":"solver_update/","page":"Update","title":"Update","text":"update!","category":"page"},{"location":"solver_update/#KitBase.update!","page":"Update","title":"KitBase.update!","text":"update!(\n    KS::X,\n    ctr::Y,\n    face::Z,\n    dt,\n    residual; # 1D / 2D\n    coll = :bgk::Symbol,\n    bc = :fix::Symbol,\n) where {\n    X<:AbstractSolverSet,\n    Y<:AbstractArray{ControlVolume1D1F,1},\n    Z<:AbstractArray{Interface1D1F,1},\n}\n\nupdate!(\n    KS::X,\n    ctr::Y,\n    face::Z,\n    dt,\n    residual; # 1D / 2D\n    coll = :bgk::Symbol,\n    bc = :extra::Symbol,\n) where {\n    X<:AbstractSolverSet,\n    Y<:AbstractArray{ControlVolume1D2F,1},\n    Z<:AbstractArray{Interface1D2F,1},\n}\n\nupdate!(\n    KS::X,\n    ctr::Y,\n    face::Z,\n    dt,\n    residual; # 1D / 2D\n    coll = :bgk::Symbol,\n    bc = :extra::Symbol,\n    isMHD = true::Bool,\n) where {\n    X<:AbstractSolverSet,\n    Y<:AbstractArray{ControlVolume1D3F,1},\n    Z<:AbstractArray{Interface1D3F,1},\n}\n\nupdate!(\n    KS::X,\n    ctr::Y,\n    face::Z,\n    dt,\n    residual; # 1D / 2D\n    coll = :bgk::Symbol,\n    bc = :extra::Symbol,\n    isMHD = true::Bool,\n) where {\n    X<:AbstractSolverSet,\n    Y<:AbstractArray{ControlVolume1D4F,1},\n    Z<:AbstractArray{Interface1D4F,1},\n}\n\nupdate!(\n    KS::X,\n    ctr::Y,\n    a1face::Z,\n    a2face::Z,\n    dt,\n    residual; # 1D / 2D\n    coll = :bgk::Symbol,\n    bc = :fix::Symbol,\n) where {\n    X<:AbstractSolverSet,\n    Y<:AbstractArray{ControlVolume2D2F,2},\n    Z<:AbstractArray{Interface2D2F,2},\n}\n\nUpdate flow variables over control volumes\n\n\n\n\n\n","category":"function"},{"location":"solver_update/","page":"Update","title":"Update","text":"The update solver calculate the variables at n+1 step based on numerical fluxes and in-cell collisions.","category":"page"},{"location":"solver_update/","page":"Update","title":"Update","text":"explicit\nimplicit\nimplicit-explicit (IMEX)","category":"page"},{"location":"api_theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"api_theory/","page":"Theory","title":"Theory","text":"prim_conserve\nconserve_prim\nmixture_prim_conserve\nmixture_conserve_prim\nem_coefficients\nadvection_flux\nburgers_flux\neuler_flux\neuler_jacobi\ngauss_moments\nmixture_gauss_moments\nmoments_conserve\nmixture_moments_conserve\npdf_slope\nmixture_pdf_slope\nmoments_conserve_slope\nmixture_moments_conserve_slope\ndiscrete_moments\nstress\nheat_flux\nmaxwellian\nmixture_maxwellian\nshakhov\nreduce_distribution\nfull_distribution\nref_vhs_vis\nvhs_collision_time\naap_hs_collision_time\naap_hs_prim\naap_hs_diffeq!\nshift_pdf!\nhs_boltz_kn\nkernel_mode\nboltzmann_fft\nboltzmann_fft!\nheat_capacity_ratio\nsound_speed","category":"page"},{"location":"api_theory/#KitBase.prim_conserve","page":"Theory","title":"KitBase.prim_conserve","text":"Transform primitive -> conservative variables\n\nprim_conserve(prim::T, γ) where {T<:AbstractArray{<:Real,1}}\n\nprim_conserve(ρ, U, λ, γ)\n\nprim_conserve(ρ, U, V, λ, γ)\n\nprim_conserve(ρ, U, V, W, λ, γ)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.conserve_prim","page":"Theory","title":"KitBase.conserve_prim","text":"Transform conservative -> primitive variables\n\nscalar: pseudo primitive vector for scalar conservation laws\nconserve_prim(u)\nconserve_prim(u, a)\nvector: primitive vector for Euler, Navier-Stokes and extended equations\nconserve_prim(W::T, γ) where {T<:AbstractArray{<:Real,1}}\nconserve_prim(ρ, M, E, γ)\nconserve_prim(ρ, MX, MY, E, γ)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_prim_conserve","page":"Theory","title":"KitBase.mixture_prim_conserve","text":"Transform multi-component primitive -> conservative variables\n\nmixture_prim_conserve(prim::T, γ) where {T<:AbstractArray{<:Real,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_conserve_prim","page":"Theory","title":"KitBase.mixture_conserve_prim","text":"Transform multi-component conservative -> primitive variables\n\nmixture_conserve_prim(W::T, γ) where {T<:AbstractArray{<:Real,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.em_coefficients","page":"Theory","title":"KitBase.em_coefficients","text":"Calculate electromagnetic coeffcients in hyperbolic Maxwell's equations\n\nem_coefficients(\n    prim::X,\n    E::Y,\n    B::Z,\n    mr,\n    lD,\n    rL,\n    dt,\n) where {X<:AbstractArray{<:Real,2},Y<:AbstractArray{<:Real,1},Z<:AbstractArray{<:Real,1}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.advection_flux","page":"Theory","title":"KitBase.advection_flux","text":"Theoretical flux of linear advection equation\n\nadvection_flux(u, a)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.burgers_flux","page":"Theory","title":"KitBase.burgers_flux","text":"Theoretical flux of Burgers' equation\n\nburgers_flux(u)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.euler_flux","page":"Theory","title":"KitBase.euler_flux","text":"Theoretical fluxes of Euler Equations\n\neuler_flux(w::A, γ; frame = :cartesian::Symbol) where {A<:AbstractArray{<:Real,1}}\n\n@return: flux tuple\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.euler_jacobi","page":"Theory","title":"KitBase.euler_jacobi","text":"Flux Jacobian of Euler Equations\n\neuler_jacobi(w::T, γ) where {T<:AbstractArray{<:Real,1}}\n\n@return: Jacobian matrix A\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.gauss_moments","page":"Theory","title":"KitBase.gauss_moments","text":"Calculate moments of Gaussian distribution G = (λ / π)^(D / 2) * exp[-λ(c^2 + ξ^2)]\n\ninternality: gauss_moments(prim::T) where {T<:AbstractArray{<:Real,1}}\nno internality: gauss_moments(prim::T, inK) where {T<:AbstractArray{<:Real,1}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_gauss_moments","page":"Theory","title":"KitBase.mixture_gauss_moments","text":"Calculate moments of Gaussian distribution in multi-component gas\n\nmixture_gauss_moments(prim::T, inK) where {T<:AbstractArray{<:Real,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.moments_conserve","page":"Theory","title":"KitBase.moments_conserve","text":"Calculate conservative moments of particle distribution\n\nmoments_conserve(Mu::OffsetArray{<:AbstractFloat,1}, alpha::Int)\n\nmoments_conserve(Mu::OffsetArray{<:Real,1}, Mxi::OffsetArray{<:Real,1},     alpha::Int, delta::Int)\n\nmoments_conserve(Mu::OffsetArray{<:Real,1}, Mv::OffsetArray{<:Real,1},     Mw::OffsetArray{<:Real,1}, alpha::Int, beta::Int, delta::Int)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_moments_conserve","page":"Theory","title":"KitBase.mixture_moments_conserve","text":"Calculate conservative moments of particle distribution in multi-component gas\n\nmixture_moments_conserve(\n    Mu::T,\n    Mxi::T,\n    alpha::I,\n    delta::I,\n) where {T<:OffsetArray{<:AbstractFloat,2},I<:Int}\n\nfunction mixture_moments_conserve(\n    Mu::T,\n    Mv::T,\n    Mw::T,\n    alpha::I,\n    beta::I,\n    delta::I,\n) where {T<:OffsetArray{<:AbstractFloat,2},I<:Int}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.pdf_slope","page":"Theory","title":"KitBase.pdf_slope","text":"Calculate slope of particle distribution function a = a1 + u * a2 + 0.5 * u^2 * a3\n\npdf_slope(u, Δ)\n\npdf_slope(prim::A, sw::B, inK) where {A<:AbstractArray{<:Real,1},B<:AbstractArray{<:Real,1}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_pdf_slope","page":"Theory","title":"KitBase.mixture_pdf_slope","text":"Calculate slope of multi-component particle distribution function a = a1 + u * a2 + 0.5 * u^2 * a3\n\nmixture_pdf_slope(prim::X, sw::Y, inK) where {X<:AbstractArray{<:Real,2},Y<:AbstractArray{<:Real,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.moments_conserve_slope","page":"Theory","title":"KitBase.moments_conserve_slope","text":"Calculate slope-related conservative moments a = a1 + u * a2 + 0.5 * u^2 * a3\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_moments_conserve_slope","page":"Theory","title":"KitBase.mixture_moments_conserve_slope","text":"Calculate slope-related conservative moments a = a1 + u * a2 + 0.5 * u^2 * a3\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.discrete_moments","page":"Theory","title":"KitBase.discrete_moments","text":"Discrete moments of particle distribution\n\ndiscrete_moments(f, ω): direct quadrature\ndiscrete_moments(f, u, ω, n): velocity moments\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.stress","page":"Theory","title":"KitBase.stress","text":"Calculate stress tensor from particle distribution function\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.heat_flux","page":"Theory","title":"KitBase.heat_flux","text":"Calculate heat flux from particle distribution function\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.maxwellian","page":"Theory","title":"KitBase.maxwellian","text":"Maxwellian in discrete form\n\n@args: particle velocity quadrature points\n@args: density, velocity and inverse of temperature\n@return: Maxwellian distribution function\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.mixture_maxwellian","page":"Theory","title":"KitBase.mixture_maxwellian","text":"Multi-component Maxwellian in discrete form\n\nmixture_maxwellian(u::X, prim::Y) where {X<:AbstractArray{<:AbstractFloat,2},Y<:AbstractArray{<:Real,2}}\n\nmixture_maxwellian(\n    u::X,\n    v::X,\n    prim::Y,\n) where {X<:AbstractArray{<:AbstractFloat,3},Y<:AbstractArray{<:Real,2}}\n\nmixture_maxwellian(\n    u::X,\n    v::X,\n    w::X,\n    prim::Y,\n) where {X<:AbstractArray{<:AbstractFloat,4},Y<:AbstractArray{<:Real,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.shakhov","page":"Theory","title":"KitBase.shakhov","text":"Shakhov non-equilibrium part\n\n@arg: particle velocity quadrature points\n@arg: discrete Maxwellian\n@arg: primitive variables, Prandtl number, heat flux, inner degree of freedom\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.reduce_distribution","page":"Theory","title":"KitBase.reduce_distribution","text":"Reduced distribution function\n\n@arg : particle distribution function with full velocity space\n@arg : quadrature weights with reduced velocity setting (v & w by default)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.full_distribution","page":"Theory","title":"KitBase.full_distribution","text":"Recover full distribution function from reduced ones\n\n@arg h & b : reduced particle distribution function with 1D velocity space\n@arg u : quadrature nodes in 1D velocity space\n@arg weights : quadrature weights in 1D velocity space\n@arg v & w : quadrature nodes in the rest velocity space (with 3D setting)\n@return f : particle distribution function with 3D velocity space\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.ref_vhs_vis","page":"Theory","title":"KitBase.ref_vhs_vis","text":"ref_vhs_vis(Kn, alpha, omega)\n\nCalculate reference viscosity with variable hard sphere (VHS) model\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.vhs_collision_time","page":"Theory","title":"KitBase.vhs_collision_time","text":"vhs_collision_time(prim::T, muRef, omega) where {T<:AbstractArray{<:Real,1}}\n\nCalculate collision time with variable hard sphere (VHS) model\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.aap_hs_collision_time","page":"Theory","title":"KitBase.aap_hs_collision_time","text":"Calculate mixture collision time from AAP model\n\naap_hs_collision_time(     prim::AbstractArray{<:Real,2},     mi::Real,     ni::Real,     me::Real,     ne::Real,     kn::Real, )\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.aap_hs_prim","page":"Theory","title":"KitBase.aap_hs_prim","text":"Calculate mixture primitive variables from AAP model\n\ntested √\n\naap_hs_prim(     prim::AbstractArray{<:Real,2},     tau::AbstractArray{<:Real,1},     mi::Real,     ni::Real,     me::Real,     ne::Real,     kn::Real, )\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.aap_hs_diffeq!","page":"Theory","title":"KitBase.aap_hs_diffeq!","text":"Source term of AAP model in DifferentialEquations.jl\n\naap_hs_diffeq!(du, u, p, t)\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.shift_pdf!","page":"Theory","title":"KitBase.shift_pdf!","text":"Shift distribution function by external force\n\nshift_pdf!(\n    f::T,\n    a,\n    du,\n    dt,\n) where {T<:AbstractArray{<:AbstractFloat,1}}\n\nshift_pdf!(\n    f::X,\n    a::Y,\n    du::Z,\n    dt,\n) where {X<:AbstractArray{<:AbstractFloat,2},Y<:AbstractArray{<:Real,1},Z<:AbstractArray{<:AbstractFloat,1}}\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.hs_boltz_kn","page":"Theory","title":"KitBase.hs_boltz_kn","text":"Calculate effective Knudsen number for fast spectral method with hard sphere (HS) model\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.kernel_mode","page":"Theory","title":"KitBase.kernel_mode","text":"Calculate collision kernel for fast spectral method\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.boltzmann_fft","page":"Theory","title":"KitBase.boltzmann_fft","text":"Calculate collision operator with FFT-based fast spectral method\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.boltzmann_fft!","page":"Theory","title":"KitBase.boltzmann_fft!","text":"Calculate collision operator with FFT-based fast spectral method\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.heat_capacity_ratio","page":"Theory","title":"KitBase.heat_capacity_ratio","text":"heat_capacity_ratio(K, D::T) where {T<:Integer}\n\nCalculate heat capacity ratio\n\n\n\n\n\n","category":"function"},{"location":"api_theory/#KitBase.sound_speed","page":"Theory","title":"KitBase.sound_speed","text":"Calculate speed of sound\n\n\n\n\n\n","category":"function"},{"location":"api_io/#I-/-O","page":"I / O","title":"I / O","text":"","category":"section"},{"location":"api_io/","page":"I / O","title":"I / O","text":"read_dict","category":"page"},{"location":"api_io/#KitBase.read_dict","page":"I / O","title":"KitBase.read_dict","text":"read_dict(filename::String, allowed)\nread_dict(filename::String)\n\nRead text into dictionary\n\n@args filename: configuration text file\n@args allowed: keywords in range\n@return vars: dictionary with values of variables\n\n\n\n\n\n","category":"function"},{"location":"install/#Installation-Instructions","page":"Installation","title":"Installation Instructions","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Kinetic is a registered Julia package in the official entry. We recommend installing it with the built-in Julia package manager, because this automatically installs a stable, tagged release.  From the Julia REPL, you could add the package and instantiate/build all dependencies via","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> ]\n(v1.5) pkg> add Kinetic\n(v1.5) pkg> build Kinetic","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This will install Kinetic and all its dependencies. After that, using/import the package,","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using Kinetic","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Kinetic can be updated to the latest tagged release from the package manager by executing","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(v1.5) pkg> update Kinetic","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"tip: Use Julia 1.3 or newer\nKinetic matches perfectly with Julia 1.3 and newer versions. Installing it with an older version of Julia will locate incomplete functionality.","category":"page"},{"location":"function_index/#Function-Index","page":"Index","title":"Function Index","text":"","category":"section"},{"location":"function_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"api_config/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"api_config/","page":"Configuration","title":"Configuration","text":"ib_rh\nib_sod\nib_briowu\nib_cavity","category":"page"},{"location":"api_config/#KitBase.ib_rh","page":"Configuration","title":"KitBase.ib_rh","text":"Initialize Rankine-Hugoniot relation\n\n1d1f1v: ib_rh(MaL, gam, u::T) where {T<:AbstractArray{<:AbstractFloat,1}}\n1d2f1v: ib_rh(MaL, gam, u::T, K) where {T<:AbstractArray{<:AbstractFloat,1}}\n1d1f3v: ib_rh(MaL, gam, u::T, v::T, w::T) where {T<:AbstractArray{<:AbstractFloat,3}}\n\n\n\n\n\n","category":"function"},{"location":"api_config/#KitBase.ib_sod","page":"Configuration","title":"KitBase.ib_sod","text":"Initialize Sod shock tube\n\n1d1f1v: ib_sod(γ, u::T) where {T<:AbstractArray{<:AbstractFloat,1}}\n1d1f3v: ib_sod(γ, u::T, v::T, w::T) where {T<:AbstractArray{<:AbstractFloat,3}}\n1d2f1v: ib_sod(γ, u::T, K) where {T<:AbstractArray{<:AbstractFloat,1}}\n\n\n\n\n\n","category":"function"},{"location":"api_config/#KitBase.ib_briowu","page":"Configuration","title":"KitBase.ib_briowu","text":"ib_briowu(gam, uspace::T, mi, me) where {T<:AbstractArray{<:AbstractFloat,2}}\n\nInitialize Brio-Wu MHD shock\n\n\n\n\n\n","category":"function"},{"location":"api_config/#KitBase.ib_cavity","page":"Configuration","title":"KitBase.ib_cavity","text":"Initialize lid-driven cavity\n\n2d1f2v: ib_cavity(gam, Um, Vm, Tm, u::T, v::T) where {T<:AbstractArray{<:AbstractFloat,2}}\n2d2f2v: ib_cavity(gam, Um, Vm, Tm, u::T, v::T, K) where {T<:AbstractArray{<:AbstractFloat,2}}\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#Physical-Space","page":"Physical Space","title":"Physical Space","text":"","category":"section"},{"location":"api_geo/","page":"Physical Space","title":"Physical Space","text":"global_frame\nlocal_frame\nPSpace1D\nPSpace2D\nuniform_mesh\nmeshgrid\nUnstructMesh \nread_mesh\nmesh_connectivity_2D\nmesh_center_2D\nmesh_area_2D","category":"page"},{"location":"api_geo/#KitBase.global_frame","page":"Physical Space","title":"KitBase.global_frame","text":"Transform local flow variables to global frame\n\n2D: global_frame(w::AbstractArray{<:Real,1}, cosa, sina)\n3D: global_frame(w::AbstractArray{<:Real,1}, dirccos::AbstractArray{<:Real,2})\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.local_frame","page":"Physical Space","title":"KitBase.local_frame","text":"Transform global flow variables to local frame\n\n2D: local_frame(w::AbstractArray{<:Real,1}, cosa, sina)\n3D: local_frame(w::AbstractArray{<:Real,1}, dirccos::AbstractArray{<:Real,2})\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.PSpace1D","page":"Physical Space","title":"KitBase.PSpace1D","text":"1D physical space with structured mesh\n\n@consts: x0, x1, nx, x, dx\n\n\n\n\n\n","category":"type"},{"location":"api_geo/#KitBase.PSpace2D","page":"Physical Space","title":"KitBase.PSpace2D","text":"2D Physical space with structured mesh\n\n@consts: x0, x1, nx, y0, y1, ny, x, y, dx, dy\n\n\n\n\n\n","category":"type"},{"location":"api_geo/#KitBase.uniform_mesh","page":"Physical Space","title":"KitBase.uniform_mesh","text":"uniform_mesh(x0::Real, xnum::Int, dx::Real)\n\nGenerate uniform mesh\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.meshgrid","page":"Physical Space","title":"KitBase.meshgrid","text":"Equivalent structured mesh generator as matlab\n\n2D: meshgrid(x::AbstractArray{<:Real,1}, y::AbstractArray{<:Real,1})\n3D: meshgrid(x::AbstractArray{<:Real,1}, y::AbstractArray{<:Real,1}, z::AbstractArray{<:Real,1})\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.UnstructMesh","page":"Physical Space","title":"KitBase.UnstructMesh","text":"Physical space with unstructured mesh\n\n@consts: nodes, cells\n\n\n\n\n\n","category":"type"},{"location":"api_geo/#KitBase.read_mesh","page":"Physical Space","title":"KitBase.read_mesh","text":"Read mesh file\n\nread_mesh(file)\n\n@return nodes : are saved with 3D coordinates (z=0 for 2D case)\n@return cells : node ids inside cells\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.mesh_connectivity_2D","page":"Physical Space","title":"KitBase.mesh_connectivity_2D","text":"Compute connectivity of 2D unstructured mesh\n\nmesh_connectivity_2D(cells::AbstractArray{<:Int,2})\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.mesh_center_2D","page":"Physical Space","title":"KitBase.mesh_center_2D","text":"Compute central points of 2D elements\n\nmesh_center_2D(nodes::AbstractArray{<:AbstractFloat,2}, cells::AbstractArray{<:Int,2})\n\n\n\n\n\n","category":"function"},{"location":"api_geo/#KitBase.mesh_area_2D","page":"Physical Space","title":"KitBase.mesh_area_2D","text":"Compute areas of 2D elements\n\nmesh_area_2D(nodes::AbstractArray{<:AbstractFloat,2}, cells::AbstractArray{<:Int,2})\n\n\n\n\n\n","category":"function"},{"location":"api_phase/#Phase-Space","page":"Phase Space","title":"Phase Space","text":"","category":"section"},{"location":"api_phase/","page":"Phase Space","title":"Phase Space","text":"VSpace1D\nVSpace2D\nVSpace3D\nMVSpace1D\nMVSpace2D\nMVSpace3D\nnewton_cotes\nlegendre_quadrature\nocta_quadrature\nquadrature_weights","category":"page"},{"location":"api_phase/#KitBase.VSpace1D","page":"Phase Space","title":"KitBase.VSpace1D","text":"1D velocity space\n\n@consts: u0, u1, nu, u, du, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.VSpace2D","page":"Phase Space","title":"KitBase.VSpace2D","text":"2D velocity space\n\n@consts: u0, u1, nu, v0, v1, nv, u, v, du, dv, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.VSpace3D","page":"Phase Space","title":"KitBase.VSpace3D","text":"3D velocity space\n\n@consts: u0, u1, nu, v0, v1, nv, w0, w1, nw, u, v, w, du, dv, dw, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.MVSpace1D","page":"Phase Space","title":"KitBase.MVSpace1D","text":"1D multi-component velocity space\n\n@consts: u0, u1, nu, u, du, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.MVSpace2D","page":"Phase Space","title":"KitBase.MVSpace2D","text":"2D multi-component velocity space\n\n@consts: u0, u1, nu, v0, v1, nv, u, v, du, dv, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.MVSpace3D","page":"Phase Space","title":"KitBase.MVSpace3D","text":"3D multi-component velocity space\n\n@consts: u0, u1, nu, v0, v1, nv, w0, w1, nw, u, v, w, du, dv, dw, weights\n\n\n\n\n\n","category":"type"},{"location":"api_phase/#KitBase.newton_cotes","page":"Phase Space","title":"KitBase.newton_cotes","text":"newton_cotes(idx::T, num::T) where {T<:Integer}\n\nEvaluate quadrature weight from Newton-Cotes rule\n\n\n\n\n\n","category":"function"},{"location":"api_phase/#KitBase.legendre_quadrature","page":"Phase Space","title":"KitBase.legendre_quadrature","text":"Gauss-Legendre quadrature\n\nlegendre_quadrature(n::Int)\n\n@arg n : quadrature order (MUST be even)\n@return points : quadrature points in 3D coordinate\n@return weights : quadrature weights\n\n\n\n\n\n","category":"function"},{"location":"api_phase/#KitBase.octa_quadrature","page":"Phase Space","title":"KitBase.octa_quadrature","text":"Octaeder quadrature\n\nocta_quadrature(n::Int, slerpflag = true::Bool)\n\n@arg n : quadrature order\n@arg slerpflag : flag of spherical linear interpolation\n@return points\n@return triangulation\n\n\n\n\n\n","category":"function"},{"location":"api_phase/#KitBase.quadrature_weights","page":"Phase Space","title":"KitBase.quadrature_weights","text":"Create quadrature weights from points and triangulation\n\ncreate_weights(n::Int, xyz::AbstractArray{<:Real,2}, triangles::AbstractArray{Int,2})\n\n@arg xyz : quadrature points\n@arg triangles : triangulation\n@return weights : quadrature weights\n\n\n\n\n\n","category":"function"},{"location":"api_step/#Stepper","page":"Stepper","title":"Stepper","text":"","category":"section"},{"location":"api_step/","page":"Stepper","title":"Stepper","text":"KitBase.step!","category":"page"},{"location":"api_step/#KitBase.step!","page":"Stepper","title":"KitBase.step!","text":"Update flow variables with finite volume formulation\n\nwrapper: step!(ks, faceL, cell, faceR, dt, res, avg, collision=:bgk, isMHD=:true)\n\n1d0f: step!(fwL, w, prim, fwR, γ, dx, RES, AVG)\n\n1d1f1v: step!(fwL, ffL, w, prim, f, fwR, ffR, u, weights, γ, μᵣ, ω, Pr, dx, dt, RES, AVG, collision=:bgk)\n\n1d1f3v: step!(fwL, ffL, w, prim, f, fwR, ffR, uVelo, vVelo, wVelo, weights, γ, μᵣ, ω, Pr, dx, dt, RES, AVG, collision=:bgk)\n\n1d2f1v: step!(fwL, fhL, fbL, w, prim, h, b, fwR, fhR, fbR, u, weights, K, γ, μᵣ, ω, Pr, dx, dt, RES, AVG, collision=:bgk)\n\n1d2f1v2s: step!(fwL, fhL, fbL, w, prim, h, b, fwR, fhR, fbR, u, weights, K, γ, mi, ni, me, ne, Kn, Pr, dx, dt, RES, AVG, collision=:bgk)\n\n\n\n\n\n","category":"function"},{"location":"solver/#General","page":"General","title":"General","text":"","category":"section"},{"location":"solver/","page":"General","title":"General","text":"Kinetic employs the finite volume method (FVM) for modeling and simulation.  The general solution algorithm can be conclude as follows, where both explicit and implicit methods are implemented.","category":"page"},{"location":"solver/","page":"General","title":"General","text":"(Image: )","category":"page"},{"location":"solver/","page":"General","title":"General","text":"The high-level solver function is ","category":"page"},{"location":"solver/","page":"General","title":"General","text":"solve!","category":"page"},{"location":"solver/#KitBase.solve!","page":"General","title":"KitBase.solve!","text":"Solution algorithm\n\n1D solver: solve!(KS::SolverSet, ctr::AbstractArray{<:AbstractControlVolume1D,1},   face::Array{<:AbstractInterface1D,1}, simTime::Float64)\n@return: ending time\n\n\n\n\n\n","category":"function"},{"location":"solver/","page":"General","title":"General","text":"The detailed solution procedures can be concluded as follows","category":"page"},{"location":"solver/","page":"General","title":"General","text":"pre-process\ntimestep calculation\nreconstruction\nevolution\nupdate\npost-process","category":"page"},{"location":"kitml/#KitML-and-Scientific-Machine-Learning","page":"KitML","title":"KitML and Scientific Machine Learning","text":"","category":"section"},{"location":"kitml/","page":"KitML","title":"KitML","text":"Machine learning is building its momentum in scientific computing. Given the nonlinear structure of differential and integral equations, it is promising to incorporate the universal function approximator from machine learning models into the governing equations and achieve the balance between efficiency and accuracy. In the following, we present a universal differential equation strategy to construct the neural network enhanced Boltzmann equation. The complicated fivefold integral operator is replaced by a combination of relaxation and neural models. It promises a completely differential structure and thus the neural ODE type training and computing becomes possible. The approach reduces the computational cost up to three orders of magnitude and preserves the perfect accuracy. The detailed theory and implementation can be found in Tianbai Xiao and Martin Frank, Using neural networks to accelerate the solution of the Boltzmann equation.","category":"page"},{"location":"kitml/","page":"KitML","title":"KitML","text":"First we load all the packages needed and set up the configurations.","category":"page"},{"location":"kitml/","page":"KitML","title":"KitML","text":"using OrdinaryDiffEq, Flux, DiffEqFlux, Plots\nusing KitBase\nimport KitML\n\n# config\nbegin\n    case = \"homogeneous\"\n    maxTime = 3\n    tlen = 16\n    u0 = -5\n    u1 = 5\n    nu = 80\n    nug = 0\n    v0 = -5\n    v1 = 5\n    nv = 28\n    nvg = 0\n    w0 = -5\n    w1 = 5\n    nw = 28\n    nwg = 0\n    vMeshType = \"rectangle\"\n    nm = 5\n    knudsen = 1\n    inK = 0\n    alpha = 1.0\n    omega = 0.5\n    nh = 8\nend","category":"page"},{"location":"kitml/","page":"KitML","title":"KitML","text":"The dataset is produced by the fast spectral method, which solves the nonlinear Boltzmann integral with fast Fourier transformation.","category":"page"},{"location":"kitml/","page":"KitML","title":"KitML","text":"# dataset\nbegin\n    tspan = (0.0, maxTime)\n    tran = linspace(tspan[1], tspan[2], tlen)\n    γ = heat_capacity_ratio(inK, 3)\n    vSpace = VSpace3D(u0, u1, nu, v0, v1, nv, w0, w1, nw, vMeshType)\n\n    f0 =\n        Float32.(\n            0.5 * (1 / π)^1.5 .*\n            (exp.(-(vSpace.u .- 0.99) .^ 2) .+ exp.(-(vSpace.u .+ 0.99) .^ 2)) .*\n            exp.(-vSpace.v .^ 2) .* exp.(-vSpace.w .^ 2),\n        ) |> Array\n    prim0 =\n        conserve_prim(moments_conserve(f0, vSpace.u, vSpace.v, vSpace.w, vSpace.weights), γ)\n    M0 = Float32.(maxwellian(vSpace.u, vSpace.v, vSpace.w, prim0)) |> Array\n\n    mu_ref = ref_vhs_vis(knudsen, alpha, omega)\n    kn_bzm = hs_boltz_kn(mu_ref, 1.0)\n    τ0 = mu_ref * 2.0 * prim0[end]^(0.5) / prim0[1]\n\n    phi, psi, phipsi = kernel_mode(\n        nm,\n        vSpace.u1,\n        vSpace.v1,\n        vSpace.w1,\n        vSpace.du[1, 1, 1],\n        vSpace.dv[1, 1, 1],\n        vSpace.dw[1, 1, 1],\n        vSpace.nu,\n        vSpace.nv,\n        vSpace.nw,\n        alpha,\n    )\n\n    # Boltzmann\n    prob = ODEProblem(boltzmann_ode!, f0, tspan, [kn_bzm, nm, phi, psi, phipsi])\n    data_boltz = solve(prob, Tsit5(), saveat = tran) |> Array\n\n    # BGK\n    prob1 = ODEProblem(bgk_ode!, f0, tspan, [M0, τ0])\n    data_bgk = solve(prob1, Tsit5(), saveat = tran) |> Array\n\n\n    data_boltz_1D = zeros(Float32, axes(data_boltz, 1), axes(data_boltz, 4))\n    data_bgk_1D = zeros(Float32, axes(data_bgk, 1), axes(data_bgk, 4))\n    for j in axes(data_boltz_1D, 2)\n        data_boltz_1D[:, j] .=\n            reduce_distribution(data_boltz[:, :, :, j], vSpace.weights[1, :, :])\n        data_bgk_1D[:, j] .=\n            reduce_distribution(data_bgk[:, :, :, j], vSpace.weights[1, :, :])\n    end\n    f0_1D = reduce_distribution(f0, vSpace.weights[1, :, :])\n    M0_1D = reduce_distribution(M0, vSpace.weights[1, :, :])\n\n    X = Array{Float32}(undef, vSpace.nu, 1)\n    for i in axes(X, 2)\n        X[:, i] .= f0_1D\n    end\n    Y = Array{Float32}(undef, vSpace.nu, 1, tlen)\n    for i in axes(Y, 2)\n        Y[:, i, :] .= data_boltz_1D\n    end\n    M = Array{Float32}(undef, nu, size(X, 2))\n    for i in axes(M, 2)\n        M[:, i] .= M0_1D\n    end\n    τ = Array{Float32}(undef, 1, size(X, 2))\n    for i in axes(τ, 2)\n        τ[1, i] = τ0\n    end\nend","category":"page"},{"location":"kitml/","page":"KitML","title":"KitML","text":"Then we define the neural network and construct the unified model with mechanical and neural parts. The training is conducted by DiffEqFlux.jl with ADAM optimizer.","category":"page"},{"location":"kitml/","page":"KitML","title":"KitML","text":"# neural model\nbegin\n    model_univ = DiffEqFlux.FastChain(\n        DiffEqFlux.FastDense(nu, nu * nh, tanh),\n        DiffEqFlux.FastDense(nu * nh, nu),\n    )\n    p_model = DiffEqFlux.initial_params(model_univ)\n\n    function dfdt(f, p, t)\n        df = (M .- f) ./ τ .+ model_univ(M .- f, p)\n    end\n    prob_ube = ODEProblem(dfdt, X, tspan, p_model)\n\n    function loss(p)\n        sol_ube = solve(prob_ube, Midpoint(), u0 = X, p = p, saveat = tran)\n        loss = sum(abs2, Array(sol_ube) .- Y)\n\n        return loss\n    end\n\n    his = []\n    cb = function (p, l)\n        display(l)\n        push!(his, l)\n        return false\n    end\nend\n\n# train\nres = DiffEqFlux.sciml_train(loss, p_model, ADAM(), cb = cb, maxiters = 200)\nres = DiffEqFlux.sciml_train(loss, res.minimizer, ADAM(), cb = cb, maxiters = 200)\n\n# residual history\nplot(log.(his))","category":"page"},{"location":"kitml/","page":"KitML","title":"KitML","text":"Once we have trained a hybrid Boltzmann collision term, we could solve it as a normal differential equation with any desirable solvers. Consider the Midpoint rule as an example, the solution algorithm and visualization can be organized.","category":"page"},{"location":"kitml/","page":"KitML","title":"KitML","text":"# solution\nube = ODEProblem(KitML.ube_dfdt, f0_1D, tspan, [M0_1D, τ0, (model_univ, res.minimizer)]);\nsol = solve(\n    ube,\n    Midpoint(),\n    u0 = f0_1D,\n    p = [M0_1D, τ0, (model_univ, res.minimizer)],\n    saveat = tran,\n);\n\n# result\nplot(\n    vSpace.u[:, vSpace.nv÷2, vSpace.nw÷2],\n    data_boltz_1D[:, 1],\n    lw = 2,\n    label = \"Initial\",\n    color = :gray32,\n    xlabel = \"u\",\n    ylabel = \"particle distribution\",\n)\nplot!(\n    vSpace.u[:, vSpace.nv÷2, vSpace.nw÷2],\n    data_boltz_1D[:, 2],\n    lw = 2,\n    label = \"Boltzmann\",\n    color = 1,\n)\nplot!(\n    vSpace.u[:, vSpace.nv÷2, vSpace.nw÷2],\n    data_bgk_1D[:, 2],\n    lw = 2,\n    line = :dash,\n    label = \"BGK\",\n    color = 2,\n)\nplot!(\n    vSpace.u[:, vSpace.nv÷2, vSpace.nw÷2],\n    M0_1D,\n    lw = 2,\n    label = \"Maxwellian\",\n    color = 10,\n)\nscatter!(vSpace.u[:, vSpace.nv÷2, vSpace.nw÷2], sol.u[2], lw = 2, label = \"UBE\", color = 3)","category":"page"},{"location":"solver_flux/#Evolution","page":"Flux","title":"Evolution","text":"","category":"section"},{"location":"solver_flux/","page":"Flux","title":"Flux","text":"evolve!","category":"page"},{"location":"solver_flux/#KitBase.evolve!","page":"Flux","title":"KitBase.evolve!","text":"Evolution\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/","page":"Flux","title":"Flux","text":"The evolution solver calculate the interface numerical fluxes based on two neighbor cells.","category":"page"},{"location":"solver_flux/","page":"Flux","title":"Flux","text":"macroscopic: Godunov, Lax, Roe, HLL, wave-propagation\nmesoscopic: upwind, central-upwind, gas-kinetic scheme","category":"page"},{"location":"solver_flux/","page":"Flux","title":"Flux","text":"The available flux solvers are","category":"page"},{"location":"solver_flux/","page":"Flux","title":"Flux","text":"flux_lax!\nflux_hll!\nflux_roe!\nflux_gks\nflux_gks!\nflux_kfvs!\nflux_kcu!\nflux_ugks!\nflux_boundary_maxwell!\nflux_boundary_specular!\nflux_em!\nflux_emx!\nflux_emy!","category":"page"},{"location":"solver_flux/#KitBase.flux_lax!","page":"Flux","title":"KitBase.flux_lax!","text":"flux_lax!(fw::AbstractArray{<:Real,1}, wL::AbstractArray{<:Real,1}, wR::AbstractArray{<:Real,1}, γ::Real, dt::Real, dx::Real)\n\nLax-Friedrichs flux\n\nP. D. Lax, Weak Solutions of Nonlinear Hyperbolic Equations and Their Numerical Computation, Commun. Pure and Applied Mathematics, 7, 159-193, 1954.\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_hll!","page":"Flux","title":"KitBase.flux_hll!","text":"flux_hll!(fw::AbstractArray{<:Real,1}, wL::AbstractArray{<:Real,1}, wR::AbstractArray{<:Real,1}, γ::Real, dt::Real)\n\nHLL flux for the Euler equations\n\n@args: variables at left & right sides of interface\n@args: specific heat ratio\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_roe!","page":"Flux","title":"KitBase.flux_roe!","text":"flux_roe!(fw::AbstractArray{<:Real,1}, wL::AbstractArray{<:Real,1}, wR::AbstractArray{<:Real,1},\nγ::Real, dt::Real, n = [1.0, 0.0]::AbstractArray{<:Real,1})\n\nRoe's flux with entropy fix    \n\nP. L. Roe, Approximate Riemann Solvers, Parameter Vectors and Difference Schemes, Journal of Computational Physics, 43, pp. 357-372. (cf. http://cfdbooks.com/cfdcodes.html)\n\n@args primL[1:4] = left state (rhoL, uL, vL, pL)\n@args primR[1:4] = right state (rhoR, uR, vR, pR)\n@args γ: specific heat ratio\n@args n[2]: unit face normal (L -> R)\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_gks","page":"Flux","title":"KitBase.flux_gks","text":"Gas kinetic flux\n\nflux_gks(u::Real, μ::Real, dt::Real, su = 0.0::Real, a = 0::Real)\nflux_gks(uL::Real, uR::Real, μ::Real, dt::Real, dxL::Real,\n    dxR::Real, suL = 0.0::Real, suR = 0.0::Real, a = 0::Real)\n\n@args: conservative scalars and their slopes\n@args: viscosity\n@args: time step and cell size\n@return: scalar flux\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_gks!","page":"Flux","title":"KitBase.flux_gks!","text":"Gas kinetic Navier-Stokes flux\n\n1D: flux_gks!(fw, wL, wR, γ, K, μᵣ, ω, dt, dx, swL, swR)\n2D: flux_gks!(fw, wL, wR, γ, K, μᵣ, ω, dt, dx, dy, swL, swR)\n\n@args: conservative variables and their left/right slopes\n@args: molecular and thermodynamic parameters\n@args: time step and cell size\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_boundary_maxwell!","page":"Flux","title":"KitBase.flux_boundary_maxwell!","text":"flux_boundary_maxwell!(\n    fw::T1,\n    fh::T2,\n    fb::T2,\n    bc::T3,\n    h::T4,\n    b::T4,\n    u::T5,\n    ω::T5,\n    inK,\n    dt,\n    rot = 1,\n) where {\n    T1<:AbstractArray{<:AbstractFloat,1},\n    T2<:AbstractArray{<:AbstractFloat,1},\n    T3<:Array{<:Real,1},\n    T4<:AbstractArray{<:AbstractFloat,1},\n    T5<:AbstractArray{<:AbstractFloat,1},\n}\n\nflux_boundary_maxwell!(\n    fw::T1,\n    fh::T2,\n    fb::T2,\n    bc::T3,\n    h::T4,\n    b::T4,\n    u::T5,\n    v::T5,\n    ω::T5,\n    inK,\n    dt,\n    len,\n    rot = 1,\n) where {\n    T1<:AbstractArray{<:AbstractFloat,1},\n    T2<:AbstractArray{<:AbstractFloat,2},\n    T3<:Array{<:Real,1},\n    T4<:AbstractArray{<:AbstractFloat,2},\n    T5<:AbstractArray{<:AbstractFloat,2},\n}\n\nMaxwell's diffusive boundary flux\n\n@args: particle distribution functions and their slopes at left/right sides of interface @args: particle velocity quadrature points and weights @args: time step\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_boundary_specular!","page":"Flux","title":"KitBase.flux_boundary_specular!","text":"flux_boundary_specular!(\n    fw::T1,\n    ff::T2,\n    f::T3,\n    u::T4,\n    ω::T4,\n    dt,\n) where {\n    T1<:AbstractArray{<:Real,1},\n    T2<:AbstractArray{<:AbstractFloat,1},\n    T3<:AbstractArray{<:AbstractFloat,1},\n    T4<:AbstractArray{<:AbstractFloat,1},\n}\n\nflux_boundary_specular!(\n    fw::T1,\n    fh::T2,\n    fb::T2,\n    h::T3,\n    b::T3,\n    u::T4,\n    ω::T4,\n    dt,\n) where {\n    T1<:AbstractArray{<:Real,1},\n    T2<:AbstractArray{<:AbstractFloat,1},\n    T3<:AbstractArray{<:AbstractFloat,1},\n    T4<:AbstractArray{<:AbstractFloat,1},\n}\n\nSpecular reflection boundary flux\n\n@args: particle distribution functions and their slopes at left/right sides of interface @args: particle velocity quadrature points and weights @args: time step\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_em!","page":"Flux","title":"KitBase.flux_em!","text":"flux_em!(femL, femR, ELL, BLL, EL, BL, ER, BR, ERR, BRR, ϕL, ϕR, ψL, ψR, dxL, dxR, Ap, An, D, sol, χ, ν, dt)\n\nWave propagation method for Maxwell's equations\n\n@args: {E, B, ϕ, ψ} in left-left, left, right, and right-right cells\n@args: eigenmatrix (A -> A+ & A-), eigenvalue (D)\n@args: full size of left & right cells\n@args: speed of light (sol)\n@args: auxiliary parameters (χₑ, νᵦ)\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_emx!","page":"Flux","title":"KitBase.flux_emx!","text":"flux_emx!(femL, femR, femLU, femLD, femRU, femRD,\nELL, BLL, EL, BL, ER, BR, ERR, BRR, ϕL, ϕR, ψL, ψR,\ndxL, dxR, A1p, A1n, A2p, A2n, D, sol, χ, ν, dt)\n\nWave propagation method for 2D Maxwell's equations\n\n@args: {E, B, ϕ, ψ} in left-left, left, right, and right-right cells\n@args: eigenmatrix (A -> A+ & A-), eigenvalue (D)\n@args: full size of left & right cells\n@args: speed of light (sol)\n@args: auxiliary parameters (χₑ, νᵦ)\n\n\n\n\n\n","category":"function"},{"location":"solver_flux/#KitBase.flux_emy!","page":"Flux","title":"KitBase.flux_emy!","text":"flux_emx!(femL, femR, femLU, femLD, femRU, femRD,\nELL, BLL, EL, BL, ER, BR, ERR, BRR, ϕL, ϕR, ψL, ψR,\ndxL, dxR, A1p, A1n, A2p, A2n, D, sol, χ, ν, dt)\n\nWave propagation method for 2D Maxwell's equations\n\n@args: {E, B, ϕ, ψ} in left-left, left, right, and right-right cells\n@args: eigenmatrix (A -> A+ & A-), eigenvalue (D)\n@args: full size of left & right cells\n@args: speed of light (sol)\n@args: auxiliary parameters (χₑ, νᵦ)\n\n\n\n\n\n","category":"function"},{"location":"solver_timestep/#Timestep","page":"Timestep","title":"Timestep","text":"","category":"section"},{"location":"solver_timestep/","page":"Timestep","title":"Timestep","text":"timestep","category":"page"},{"location":"solver_timestep/#KitBase.timestep","page":"Timestep","title":"KitBase.timestep","text":"timestep(KS, ctr, simTime)\n\nCalculate timestep\n\n@return: Δt\n\n\n\n\n\n","category":"function"},{"location":"solver_timestep/","page":"Timestep","title":"Timestep","text":"The timestep solver returns the time interval used for the upcoming solution loop based on the current variables.","category":"page"},{"location":"type/#Data-Structure","page":"Type","title":"Data Structure","text":"","category":"section"},{"location":"type/","page":"Type","title":"Type","text":"Kinetic is organized with the data structures and methods of both generality and convenience.  While most of the methods can be applied to multi-dimensional arrays directly, we provide a set of domain-specific structs that handles multiple dispatch in an elegant way. In the finite volume method, the data is stored separately throughout the cells. Therefore, we provide AbstractControlVolume structs for solving different equations that are used as arrays of structs (AoS) in the simulations.","category":"page"},{"location":"type/","page":"Type","title":"Type","text":"The 1D control volume structs are","category":"page"},{"location":"type/","page":"Type","title":"Type","text":"ControlVolume1D\nControlVolume1D1F\nControlVolume1D2F\nControlVolume1D3F\nControlVolume1D4F","category":"page"},{"location":"type/#KitBase.ControlVolume1D","page":"Type","title":"KitBase.ControlVolume1D","text":"ControlVolume1D(X::T1, DX::T1, W::T2, PRIM::T2) where {T1<:Real,T2<:AbstractArray}\n\n1D control volume with no distribution function\n\n@vars: x, dx, w, prim, sw\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume1D1F","page":"Type","title":"KitBase.ControlVolume1D1F","text":"ControlVolume1D1F(\n    X,\n    DX,\n    W::T1,\n    PRIM::T1,\n    F::T2,\n) where {T1<:AbstractArray,T2<:AbstractArray}\n\n1D control volume with 1 distribution function\n\n@vars: x, dx, w, prim, sw, f, sf\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume1D2F","page":"Type","title":"KitBase.ControlVolume1D2F","text":"ControlVolume1D2F(\n    X,\n    DX,\n    W::T1,\n    PRIM::T1,\n    H::T2,\n    B::T2,\n) where {T1<:AbstractArray,T2<:AbstractArray}\n\n1D control volume with 2 distribution functions\n\n@vars: x, dx, w, prim, sw, h, b, sh, sb\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume1D3F","page":"Type","title":"KitBase.ControlVolume1D3F","text":"ControlVolume1D3F(\n    X::Real,\n    DX::Real,\n    W::AbstractArray{<:Real,2},\n    PRIM::AbstractArray{<:Real,2},\n    H0::AbstractArray{<:AbstractFloat,3},\n    H1::AbstractArray{<:AbstractFloat,3},\n    H2::AbstractArray{<:AbstractFloat,3},\n    E0::AbstractArray{<:AbstractFloat,1},\n    B0::AbstractArray{<:AbstractFloat,1},\n    L::AbstractArray{<:AbstractFloat,2},\n)\n\nControlVolume1D3F(\n    X::Real,\n    DX::Real,\n    W::AbstractArray{<:Real,1},\n    PRIM::AbstractArray{<:Real,1},\n    H0::AbstractArray{<:AbstractFloat,1},\n    H1::AbstractArray{<:AbstractFloat,1},\n    H2::AbstractArray{<:AbstractFloat,1},\n)\n\nControlVolume1D3F(\n    X::Real,\n    DX::Real,\n    W::AbstractArray{<:Real,3},\n    PRIM::AbstractArray{<:Real,3},\n    H0::AbstractArray{<:AbstractFloat,4},\n    H1::AbstractArray{<:AbstractFloat,4},\n    H2::AbstractArray{<:AbstractFloat,4},\n    E0::AbstractArray{<:AbstractFloat,2},\n    B0::AbstractArray{<:AbstractFloat,2},\n    L::AbstractArray{<:AbstractFloat,3},\n)\n\n1D control volume with 3 distribution functions\n\n@vars: x, dx, w, prim, sw, h0, h1, h2, sh0, sh1, sh2, E, B, ϕ, ψ, lorenz\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume1D4F","page":"Type","title":"KitBase.ControlVolume1D4F","text":"ControlVolume1D4F(\n    X::Real,\n    DX::Real,\n    W::AbstractArray{<:Real,2},\n    PRIM::AbstractArray{<:Real,2},\n    H0::AbstractArray{<:AbstractFloat,2},\n    H1::AbstractArray{Float64,2},\n    H2::AbstractArray{Float64,2},\n    H3::AbstractArray{Float64,2},\n    E0::AbstractArray{Float64,1},\n    B0::AbstractArray{Float64,1},\n    L::AbstractArray{Float64,2},\n)\n\nControlVolume1D4F(\n    X::Real,\n    DX::Real,\n    W::AbstractArray{<:Real,3},\n    PRIM::AbstractArray{<:Real,3},\n    H0::AbstractArray{<:AbstractFloat,3},\n    H1::AbstractArray{Float64,3},\n    H2::AbstractArray{Float64,3},\n    H3::AbstractArray{Float64,3},\n    E0::AbstractArray{Float64,2},\n    B0::AbstractArray{Float64,2},\n    L::AbstractArray{Float64,3},\n)\n\n1D control volume with 4 distribution functions\n\n@vars: x, dx, w, prim, sw, h0, h1, h2, h3, sh0, sh1, sh2, sh3, E, B, ϕ, ψ, lorenz\n\n\n\n\n\n","category":"type"},{"location":"type/","page":"Type","title":"Type","text":"The 2D control volume structs are","category":"page"},{"location":"type/","page":"Type","title":"Type","text":"ControlVolume2D\nControlVolume2D1F\nControlVolume2D2F\nControlVolume2D3F","category":"page"},{"location":"type/#KitBase.ControlVolume2D","page":"Type","title":"KitBase.ControlVolume2D","text":"ControlVolume2D(\n    X::Real,\n    DX::Real,\n    Y::Real,\n    DY::Real,\n    W::AbstractArray,\n    PRIM::AbstractArray,\n)\n\n2D control volume with no distribution function\n\n@vars: x, y, dx, dy, w, prim, sw\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume2D1F","page":"Type","title":"KitBase.ControlVolume2D1F","text":"ControlVolume2D1F(\n    X::Real,\n    DX::Real,\n    Y::Real,\n    DY::Real,\n    W::AbstractArray,\n    PRIM::AbstractArray,\n    F::AbstractArray,\n)\n\n2D control volume with 1 distribution function\n\n@vars: x, y, dx, dy, w, prim, sw, f, sf\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume2D2F","page":"Type","title":"KitBase.ControlVolume2D2F","text":"ControlVolume2D2F(\n    X::Real,\n    DX::Real,\n    Y::Real,\n    DY::Real,\n    W::AbstractArray,\n    PRIM::AbstractArray,\n    H::AbstractArray,\n    B::AbstractArray,\n)\n\n2D control volume with 2 distribution functions\n\n@vars: x, y, dx, dy, w, prim, sw, h, b, sh, sb\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolume2D3F","page":"Type","title":"KitBase.ControlVolume2D3F","text":"ControlVolume2D3F(\n    X::Real,\n    DX::Real,\n    Y::Real,\n    DY::Real,\n    W::AbstractArray,\n    PRIM::AbstractArray,\n    H0::AbstractArray,\n    H1::AbstractArray,\n    H2::AbstractArray,\n    E0::AbstractArray,\n    B0::AbstractArray,\n    L::AbstractArray,\n)\n\nControlVolume2D3F(\n    X::Real,\n    DX::Real,\n    Y::Real,\n    DY::Real,\n    W::AbstractArray{<:Real,1},\n    PRIM::AbstractArray{<:Real,1},\n    H0::AbstractArray{<:AbstractFloat,2},\n    H1::AbstractArray{<:AbstractFloat,2},\n    H2::AbstractArray{<:AbstractFloat,2},\n)\n\n2D control volume with 3 distribution functions\n\n@vars: x, y, dx, dy, w, prim, sw, h0, h1, h2, sh0, sh1, sh2, E, B, ϕ, ψ, lorenz\n\n\n\n\n\n","category":"type"},{"location":"type/","page":"Type","title":"Type","text":"The numerical fluxes are evaluated through AbstractInterface structs","category":"page"},{"location":"type/","page":"Type","title":"Type","text":"Interface1D\nInterface1D1F\nInterface1D2F\nInterface1D3F\nInterface1D4F\nInterface2D\nInterface2D1F\nInterface2D2F","category":"page"},{"location":"type/#KitBase.Interface1D","page":"Type","title":"KitBase.Interface1D","text":"Interface1D(w::AbstractArray)\n\n1D cell interface with no distribution function\n\n@vars: fw\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface1D1F","page":"Type","title":"KitBase.Interface1D1F","text":"Interface1D1F(w::AbstractArray, f::AbstractArray)\n\n1D cell interface with 1 distribution function\n\n@vars: fw, ff\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface1D2F","page":"Type","title":"KitBase.Interface1D2F","text":"Interface1D2F(w::AbstractArray, f::AbstractArray)\n\n1D cell interface with 2 distribution functions\n\n@vars: fw, fh, fb\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface1D3F","page":"Type","title":"KitBase.Interface1D3F","text":"Interface1D3F(w::AbstractArray, f::AbstractArray, E::AbstractArray{<:Real,1})\nInterface1D3F(w::AbstractArray, f::AbstractArray, E::AbstractArray{<:Real,2})\nInterface1D3F(w::AbstractArray, f::AbstractArray)\n\n1D cell interface with 3 distribution functions\n\n@vars: fw, fh0, fh1, fh2, femL, femR,\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface1D4F","page":"Type","title":"KitBase.Interface1D4F","text":"Interface1D4F(w::AbstractArray, f::AbstractArray, E::AbstractArray{<:Real,1})\nInterface1D4F(w::AbstractArray, f::AbstractArray, E::AbstractArray{<:Real,2})\n\n1D cell interface with 4 distribution functions\n\n@vars: fw, fh0, fh1, fh2, fh3, femL, femR\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface2D","page":"Type","title":"KitBase.Interface2D","text":"Interface2D(L::Real, C::Real, S::Real, w::AbstractArray)\n\n2D cell interface with no distribution function\n\n@vars: len, n, fw\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface2D1F","page":"Type","title":"KitBase.Interface2D1F","text":"Interface2D1F(L::Real, C::Real, S::Real, w::AbstractArray, f::AbstractArray)\n\n2D cell interface with 1 distribution function\n\n@vars: len, n, fw, ff\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface2D2F","page":"Type","title":"KitBase.Interface2D2F","text":"Interface2D2F(L::Real, C::Real, S::Real, w::AbstractArray, f::AbstractArray)\n\n2D cell interface with 2 distribution functions\n\n@vars: len, n, fw, fh, fb\n\n\n\n\n\n","category":"type"},{"location":"type/","page":"Type","title":"Type","text":"The rest structs for saving general computational setups are","category":"page"},{"location":"type/","page":"Type","title":"Type","text":"SolverSet","category":"page"},{"location":"type/#KitBase.SolverSet","page":"Type","title":"KitBase.SolverSet","text":"Structure of solver setup\n\n\n\n\n\n","category":"type"},{"location":"type/","page":"Type","title":"Type","text":"Modules = [KitBase]\nOrder = [:type]","category":"page"},{"location":"type/#KitBase.ControlVolumeParticle1D","page":"Type","title":"KitBase.ControlVolumeParticle1D","text":"ControlVolume1D(X::Real, DX::Real, W::AbstractArray, PRIM::AbstractArray)\n\n1D control volume in correspondence with particle simulation\n\n@vars: x, dx, w, prim, sw, wg, τ, np, vrmax, remainder\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.ControlVolumeParticle2D","page":"Type","title":"KitBase.ControlVolumeParticle2D","text":"ControlVolume2D(X::Real, DX::Real, Y::Real, DY::Real, W::AbstractArray, PRIM::AbstractArray)\n\n2D control volume in correspondence with particle simulation\n\n@vars: x, y, dx, dy, w, prim, sw, wg, τ, np, vrmax, remainder\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.DiatomicGas","page":"Type","title":"KitBase.DiatomicGas","text":"Diatomic gas property\n\n@vars: Kn, Ma, Pr, K, γ, ω, αᵣ, ωᵣ, μᵣ, m, np\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Gas","page":"Type","title":"KitBase.Gas","text":"Particle property\n\n@vars: Kn, Ma, Pr, K, γ, ω, αᵣ, ωᵣ, μᵣ, m, np\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.IB","page":"Type","title":"KitBase.IB","text":"Initial & boundary condition with no distribution function\n\n@vars: wL, primL, bcL, wR, primR, bcR, bcU, bcD\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.IB1F","page":"Type","title":"KitBase.IB1F","text":"Initial & boundary condition with 1 distribution function\n\n@vars: wL, primL, fL, bcL, wR, primR, fR, bcR, bcU, bcD\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.IB2F","page":"Type","title":"KitBase.IB2F","text":"Initial & boundary condition with 2 distribution functions\n\n@vars: wL, primL, hL, bL, bcL, wR, primR, hR, bR, bcR, bcU, bcD\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.IB3F","page":"Type","title":"KitBase.IB3F","text":"Initial & boundary condition with 3 distribution functions\n\n@vars: wL, primL, h0L, h1L, h2L, bcL, EL, BL, lorenzL, wR, primR, h0R, h1R, h2R, bcR, ER, BR, lorenzR, bcU, bcD\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.IB4F","page":"Type","title":"KitBase.IB4F","text":"Initial & boundary condition with 4 distribution functions\n\n@vars: wL, primL, h0L, h1L, h2L, h3L, bcL, EL, BL, lorenzL, wR, primR, h0R, h1R, h2R, h3R, bcR, ER, BR, lorenzR, bcU, bcD\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Interface2D3F","page":"Type","title":"KitBase.Interface2D3F","text":"Interface2D3F(\n    L::Real,\n    C::Real,\n    S::Real,\n    w::AbstractArray,\n    f::AbstractArray,\n    E::AbstractArray{<:Real,1},\n)\nInterface2D3F(\n    L::Real,\n    C::Real,\n    S::Real,\n    w::AbstractArray,\n    f::AbstractArray,\n    E::AbstractArray{<:Real,2},\n)\nInterface2D3F(L::Real, C::Real, S::Real, w::AbstractArray, f::AbstractArray)\n\n2D cell interface with 3 distribution functions\n\n@vars: len, n, fw, fh, fb\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Mixture","page":"Type","title":"KitBase.Mixture","text":"Multi-component gas property\n\n@consts: Kn, Ma, Pr, K, γ, mi, ni, me, ne\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Particle","page":"Type","title":"KitBase.Particle","text":"Particle(M, X, V, E, IDX, FLAG = zeros(eltype(IDX), axes(IDX, 1)), T = zero(M))\n\nStruct of arrays for particle simulation\n\n@vars: m, x, v, e, idx, flag, tc\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Particle1D","page":"Type","title":"KitBase.Particle1D","text":"Particle1D(M::AbstractFloat, X::Real, V::AbstractArray, IDX::Integer, T::Real)\n\n1D particle\n\n@vars: m, x, v, e, idx, tc\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Particle2D","page":"Type","title":"KitBase.Particle2D","text":"Particle2D(M::AbstractFloat, X::Real, V::AbstractArray, IDX::Integer, T::Real)\n\n2D particle\n\n@vars: m, x, v, idx, tb\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Plasma1D","page":"Type","title":"KitBase.Plasma1D","text":"1D plasma property\n\n@consts: Kn, Ma, Pr, K, γ, mi, ni, me, ne, lD, rL, sol, χ, ν, Ap, An, D\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Plasma2D","page":"Type","title":"KitBase.Plasma2D","text":"2D plasma property\n\n@consts: Kn, Ma, Pr, K, γ, mi, ni, me, ne, lD, rL, sol, χ, ν, A1p, A1n, A2p, A2n, D1, D2\n\n\n\n\n\n","category":"type"},{"location":"type/#KitBase.Setup","page":"Type","title":"KitBase.Setup","text":"Computational setup\n\n@consts: case, space, flux, collision, nSpecies, interpOrder, limiter, cfl, maxTime\n\n\n\n\n\n","category":"type"},{"location":"kitfort/#KitFort-and-High-Performance-Computing","page":"KitFort","title":"KitFort and High-Performance Computing","text":"","category":"section"},{"location":"kitfort/","page":"KitFort","title":"KitFort","text":"Numerical simulations of nonlinear models and differential equations are essentially connected with supercomputers and high-performance computing (HPC). The performance of a supercomputer or a software program is commonly measured in floating-point operations per second (FLOPS). Through the milestone astronomy research of Celeste, Julia has entered the PetaFLOPS club (together with C/C++ and Fortran) since 2017. Julia is experiencing a dramatic Rise in HPC and elsewhere, and that is why we use Julia to organize the Kinetic. However, compared with the mature C/C++ ecosystem, the equivalent execution efficiency isn't going to happen in all time and situations. Some existing hardware architecture, e.g. Sunway TaihuLight, the previou fastest supercomputer in TOP500 list, is built upon 40,960 Chinese-designed SW26010 manycore 64-bit RISC processors, which is not specifically optimized for Julia. Therefore, we've develop an accompanying package KitFort.jl. The Fortran codes have been linked to the Julia syntax with the built-in ccall function. It's not a default submodule of Kinetic since we believe the Julia codes are sufficient for general users and developers and encounter no two-language problem. However, it can be manually imported when the executing efficiency becomes the first priority by executing","category":"page"},{"location":"kitfort/","page":"KitFort","title":"KitFort","text":"julia> ]\n(v1.5) pkg> add KitFort","category":"page"},{"location":"kitfort/","page":"KitFort","title":"KitFort","text":"After that, using/import the package.","category":"page"},{"location":"kitfort/","page":"KitFort","title":"KitFort","text":"julia> using KitFort","category":"page"},{"location":"kitfort/","page":"KitFort","title":"KitFort","text":"It can be updated to the latest tagged release from the package manager by executing","category":"page"},{"location":"kitfort/","page":"KitFort","title":"KitFort","text":"(v1.5) pkg> update KitFort","category":"page"},{"location":"kitfort/","page":"KitFort","title":"KitFort","text":"Modules = [KitFort]\nOrder = [:type, :function]","category":"page"},{"location":"api_math/#Math","page":"Math","title":"Math","text":"","category":"section"},{"location":"api_math/","page":"Math","title":"Math","text":"linspace\nheaviside\nfortsign\nmat_split\ncentral_diff\ncentral_diff!\nupwind_diff\nupwind_diff!\nunstruct_diff\nKitBase.lgwt\nKitBase.extract_last","category":"page"},{"location":"api_math/#KitBase.linspace","page":"Math","title":"KitBase.linspace","text":"Python linspace function\n\nlinspace(start::Real, stop::Real, n::Int)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.heaviside","page":"Math","title":"KitBase.heaviside","text":"Heaviside step function\n\nheaviside(x::Real)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.fortsign","page":"Math","title":"KitBase.fortsign","text":"Fortran sign function\n\nfortsign(x::Real, y::Real)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.mat_split","page":"Math","title":"KitBase.mat_split","text":"Split matrix into row vectors\n\nmat_split(m::AbstractArray)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.central_diff","page":"Math","title":"KitBase.central_diff","text":"Central difference\n\ncentral_diff(y::AbstractArray{<:Any,1}, x::AbstractArray{<:Any,1})\n\ncentral_diff(y::AbstractArray{<:Any,1}, dx::Any)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.central_diff!","page":"Math","title":"KitBase.central_diff!","text":"Central difference\n\ncentral_diff!(dy::AbstractArray{<:Any,1}, y::AbstractArray{<:Any,1}, x::AbstractArray{<:Any,1})\n\ncentral_diff!(dy::AbstractArray{<:Any,1}, y::AbstractArray{<:Any,1}, dx::Any)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.upwind_diff","page":"Math","title":"KitBase.upwind_diff","text":"Upwind difference\n\nupwind_diff(\n    y::AbstractArray{<:Any,1},\n    x::AbstractArray{<:Any,1};\n    stream = :right::Symbol,\n)\n\nupwind_diff(y::AbstractArray{<:Any,1}, dx::Any; stream = :right::Symbol)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.upwind_diff!","page":"Math","title":"KitBase.upwind_diff!","text":"Upwind difference\n\nupwind_diff!(\n    dy::AbstractArray{<:Any,1},\n    y::AbstractArray{<:Any,1},\n    x::AbstractArray{<:Any,1};\n    stream = :right::Symbol,\n)\n\nupwind_diff!(\n    dy::AbstractArray{<:Any,1},\n    y::AbstractArray{<:Any,1},\n    dx::Any;\n    stream = :right::Symbol,\n)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.unstruct_diff","page":"Math","title":"KitBase.unstruct_diff","text":"Finite difference for pseudo-unstructured mesh\n\nunstruct_diff(u::AbstractArray{<:Any,1}, x::AbstractArray{<:Any,1}, nx::Int; mode = :central::Symbol)\n\nunstruct_diff(u::Function, x::AbstractArray{<:Any,2}, nx::Int, dim::Int; mode = :central::Symbol)\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.lgwt","page":"Math","title":"KitBase.lgwt","text":"Gauss Legendre integral for fast spectral method\n\nlgwt(N::Int, a::Real, b::Real)\n\n@args: number of quadrature points N, integral range [a, b]\n@args: quadrature points x & weights w\n\n\n\n\n\n","category":"function"},{"location":"api_math/#KitBase.extract_last","page":"Math","title":"KitBase.extract_last","text":"Extract subarray except the last column\n\nextract_last(a::AbstractArray, idx::Int; mode=:view::Symbol)\n\n\n\n\n\n","category":"function"},{"location":"solver_post/#Post-process","page":"Postprocess","title":"Post-process","text":"","category":"section"},{"location":"solver_post/","page":"Postprocess","title":"Postprocess","text":"plot_line\nwrite_jld","category":"page"},{"location":"solver_post/#KitBase.plot_line","page":"Postprocess","title":"KitBase.plot_line","text":"plot_line(KS, ctr; backend)\n\nPlot solution profiles\n\n\n\n\n\n","category":"function"},{"location":"solver_post/#KitBase.write_jld","page":"Postprocess","title":"KitBase.write_jld","text":"write_jld(KS, ctr, t)\n\nWrite data into JLD2\n\n\n\n\n\n","category":"function"},{"location":"solver_post/","page":"Postprocess","title":"Postprocess","text":"The post-process solver handles the simulation data and visualization.","category":"page"},{"location":"physics/#Basic-Physics","page":"Physics","title":"Basic Physics","text":"","category":"section"},{"location":"physics/","page":"Physics","title":"Physics","text":"The physical world shows a diverse set of behaviors on different characteristic scales. Consider the molecular motion of gases as an example. Down to the finest scale of a many-particle system, the Newton's second law depicts particle motions via","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"mathbfF = m mathbfa","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"As a first order system it reads","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"fracd mathbf xdt = mathbf v  fracd mathbf vdt = fracmathbf Fm","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"An intuitive numerical algorithm is to get the numerous particles on board and track the trajectories of them. A typical example is the Molecular Dynamics. This is not going to be efficient since there are more than 2e25 molecules per cubic meter in normal atmosphere, and things get even more complicated when you count on the N-body interactions all the time. Some methods have been proposed to simplify the computation. As an example, the Direct simulation Monte Carlo employs certain molecular models and conduct the intermolecular collisions in a stochastic manner. It significantly reduces the computational cost, while the trade-off is the artificial fluctuations. Many realizations must be simulated successively to average the solutions and reduce the errors.","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"An alternative strategy is made from ensemble averaging, where the coarse-grained modeling is used to provide a bottom-up view. At the mean free path and collision time scale of molecules, particles travel freely during most of time with mild intermolecular collisions. Such dynamics can be described with an operator splitting approach, i.e. the kinetic transport equation","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"fracpartial fpartial t+ mathbf v cdot nabla_mathbf x f + mathbf a cdot nabla_mathbf v f = Q(f)","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"where the left and right hand sides model particle transports and collisions correspondingly. Different collision models can be inserted into such equation. If the particles only collide with a background material one obtains linear Boltzmann collision operator","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"Q(f)=int_mathbb R^3 mathcal B(mathbf v_* mathbf v) left f(mathbf v_*)-f(mathbf v)right dmathbf v_*","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"where the collision kernel mathcal B models the strength of collisions at different velocities.  If the interactions among particles are considered, the collision operator becomes nonlinear.  For example, the two-body collision results in nonlinear Boltzmann equation","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"Q(f)=int_mathbb R^3 int_mathcal S^2 mathcal B(cos beta mathbfv-mathbfv_*) left f(mathbf v)f(mathbf v_*)-f(mathbf v)f(mathbf v_*)right dmathbf Omega dmathbf v_*","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"To solve the Boltzmann equation, a discretized phase space needs to be introduced and the solution algorithm is called discrete ordinates method or discrete velocity method. Due to the complicated fivefold integral in the nonlinear Boltzmann collision operator, sometimes it is replaced by the simplified models in the discrete velocity method, e.g. the relaxation model","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"Q(f) = nu (mathcal M - f)","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"Meanwhile, with the enlargement of modeling scale to a macroscopic hydrodynamic level, the accumulating effect of particle collisions results in an equalization of local temperature and velocity, where the moderate non-equilibrium effects can be well described by viscous transport, heat conduction and mass diffusion, i.e., the so called transport phenomena.  Large-scale dynamics presents the property of waves, and the macroscopic transport equations can be constructed to describe the bulk behaviors of fluids. Typical examples are the Euler and Navier-Stokes equations","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"fracpartial mathbf Wpartial t + nabla_mathbf x cdot mathbf F = mathbf S","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"From microscopic particle transport to macroscopic fluid motion, there is a continuous variation of flow dynamics. ","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"Kinetic.jl is designed to solve different physical models. We pay special attentions to Hilbert's sixth problem, i.e. building the numerical passage between the kinetic theory of gases and continuum mechanics.  A list of current supported models and equations include","category":"page"},{"location":"physics/","page":"Physics","title":"Physics","text":"linear Boltzmann equation\nnonlinear Boltzmann equation\nnonlinear kinetic model equation\nmulti-component Boltzmann equations\ndirect simulation Monte Carlo\nstochastic particle method based on relaxation model\nadvection-diffusion equation\nBurgers equation\nEuler equations\nNavier-Stokes equations\nExtended hydrodynamical equations from gas kinetic expansion\nMagnetohydrodynamical equations\nPoisson equation\nFokker-Planck-Landau equation\nMaxwell's equations","category":"page"},{"location":"eg_shock/#Tutorial","page":"Shock tube problem","title":"Tutorial","text":"","category":"section"},{"location":"eg_shock/","page":"Shock tube problem","title":"Shock tube problem","text":"Thanks to the brilliant expressiveness and low-overhead abstraction, we provide different levels of solution algorithm for modeling and simulating advection-diffusion dynamics. The high-level solver is able to solve complex physics in a few lines, while the low-level APIs keep all the detailed implementations and are easy to be called from Python and C. In the following, we present two quick tutorials to illustrate the usage of Kinetic.","category":"page"},{"location":"eg_shock/#Shock-tube-problem","page":"Shock tube problem","title":"Shock tube problem","text":"","category":"section"},{"location":"eg_shock/","page":"Shock tube problem","title":"Shock tube problem","text":"We first solve the shock tube problem in gas dynamics. It's a two dimensional problem, with one in physical domain x and another in particle velocity domain u. First let us prepare the configuration file as","category":"page"},{"location":"eg_shock/","page":"Shock tube problem","title":"Shock tube problem","text":"# case\ncase = sod\nspace = 1d2f1v\nnSpecies = 1\nflux = kfvs\ncollision = bgk\ninterpOrder = 2\nlimiter = vanleer\nboundary = fix\ncfl = 0.5\nmaxTime = 0.2\n\n# physical space\nx0 = 0\nx1 = 1\nnx = 200\npMeshType = uniform\nnxg = 1\n\n# velocity space\nvMeshType = rectangle\numin = -5\numax = 5\nnu = 28\nnug = 0\n\n# gas\nknudsen = 0.0001\nmach = 0.0\nprandtl = 1\ninK = 2\nomega = 0.81\nalphaRef = 1.0\nomegaRef = 0.5","category":"page"},{"location":"eg_shock/","page":"Shock tube problem","title":"Shock tube problem","text":"The configuration file can be understood as follows:","category":"page"},{"location":"eg_shock/","page":"Shock tube problem","title":"Shock tube problem","text":"The simulation case is the standard Sod shock tube\nA phase space in 1D physical and 1D velocity space is created with two particle distribution functions inside\nThe numerical flux function is the kinetic flux vector splitting method and the collision term uses the BGK relaxation\nThe reconstruction step employs van Leer limiter to create 2nd-order interpolation\nThe two boundaries are fixed with Dirichlet boundary condition\nThe timestep is determined with a CFL number of 0.5\nThe maximum simulation time is 0.2\nThe physical space spans in [0, 1] with 200 uniform cells\nThe velocity space spans in [-5, 5] with 28 uniform cells\nThe reference Knudsen number is set as 1e-4\nThe reference Mach number is absent\nThe reference Prandtl number is 1\nThe gas molecule contains two internal degrees of freedom\nThe viscosity is evaluated with the following formulas","category":"page"},{"location":"eg_shock/","page":"Shock tube problem","title":"Shock tube problem","text":"mu = mu_ref left(fracTT_refright)^omega","category":"page"},{"location":"eg_shock/","page":"Shock tube problem","title":"Shock tube problem","text":"mu_ref=frac5(alpha+1)(alpha+2) sqrtpi4 alpha(5-2 omega)(7-2 omega) Kn_ref","category":"page"},{"location":"eg_shock/","page":"Shock tube problem","title":"Shock tube problem","text":"The configuration file directly generate variables during runtime via meta-programming in Julia, and it can be stored in any text format (txt, toml, cfg, etc.).  For example, if config.txt is created,  we then execute the following codes to conduct a simulation","category":"page"},{"location":"eg_shock/","page":"Shock tube problem","title":"Shock tube problem","text":"using Kinetic\nset, ctr, face, t = initialize(\"config.txt\")\nt = solve!(set, ctr, face, t)","category":"page"},{"location":"eg_shock/","page":"Shock tube problem","title":"Shock tube problem","text":"The computational setup is stored in set and the control volume solutions are stored in ctr and face.  The high-level solver solve! is equivalent as the following low-level procedures","category":"page"},{"location":"eg_shock/","page":"Shock tube problem","title":"Shock tube problem","text":"dt = timestep(ks, ctr, t)\nnt = Int(floor(ks.set.maxTime / dt))\nres = zeros(3)\nfor iter = 1:nt\n    reconstruct!(ks, ctr)\n    evolve!(ks, ctr, face, dt)\n    update!(ks, ctr, face, dt, res)\nend","category":"page"},{"location":"eg_shock/","page":"Shock tube problem","title":"Shock tube problem","text":"The result can be visualized with built-in function plot_line, which presents the profiles of gas density, velocity and temperature inside the tube.","category":"page"},{"location":"eg_shock/","page":"Shock tube problem","title":"Shock tube problem","text":"plot_line(set, ctr)","category":"page"},{"location":"eg_shock/","page":"Shock tube problem","title":"Shock tube problem","text":"(Image: )","category":"page"},{"location":"solver_pre/#Pre-process","page":"Preprocess","title":"Pre-process","text":"","category":"section"},{"location":"solver_pre/","page":"Preprocess","title":"Preprocess","text":"initialize","category":"page"},{"location":"solver_pre/#KitBase.initialize","page":"Preprocess","title":"KitBase.initialize","text":"Initialize solver from input file\n\n\n\n\n\n","category":"function"},{"location":"solver_pre/","page":"Preprocess","title":"Preprocess","text":"The pre-process solver initializes the simulation that returns solver set, control volumes, interfaces, and current time. It could be a new simulation or restart of an interrupted one.","category":"page"},{"location":"solver_pre/","page":"Preprocess","title":"Preprocess","text":"new run: .txt / .cfg / .toml / etc.\nrestart: .jld2","category":"page"},{"location":"eg_cavity/#Lid-Driven-Cavity","page":"Lid-driven cavity","title":"Lid-Driven Cavity","text":"","category":"section"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"We then show the lid-driven cavity. It's a four dimensional problem, with two in physical domain (xy) and another in particle velocity domain (uv). Similarly, we prepare the configuration file as","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"# setup\ncase = cavity\nspace = 2d2f2v\nflux = kfvs\ncollision = bgk\nnSpecies = 1\ninterpOrder = 2\nlimiter = vanleer\nboundary = maxwell\ncfl = 0.8\nmaxTime = 2.0\n\n# phase space\nx0 = 0.0\nx1 = 1.0\nnx = 45\ny0 = 0.0\ny1 = 1.0\nny = 45\npMeshType = uniform\nnxg = 0\nnyg = 0\n\n# velocity space\numin = -5.0\numax = 5.0\nnu = 28\nvmin = -5.0\nvmax = 5.0\nnv = 28\nvMeshType = rectangle\nnug = 0\nnvg = 0\n\n# gas\nknudsen = 0.075\nmach = 2.0\nprandtl = 1.0\ninK = 1.0\nomega = 0.72\nalphaRef = 1.0\nomegaRef = 0.5\n\n# boundary\nuLid = 0.15\nvLid = 0.0\ntLid = 1.0","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"We then execute the following codes to conduct a simulation","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"using Kinetic\nset, ctr, a1face, a2face, t = initialize(\"config.txt\")\nt = solve!(set, ctr, a1face, a2face, t)","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"The high-level solver solve! is equivalent as the following low-level procedures","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"using ProgressMeter\nres = zeros(4)\ndt = timestep(ks, ctr, simTime)\nnt = floor(ks.set.maxTime / dt) |> Int\n@showprogress for iter = 1:nt\n    reconstruct!(ks, ctr)\n    evolve!(ks, ctr, a1face, a2face, dt; mode = Symbol(ks.set.flux), bc = Symbol(ks.set.boundary))\n    update!(ks, ctr, a1face, a2face, dt, res; coll = Symbol(ks.set.collision), bc = Symbol(ks.set.boundary))\nend","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"It can be further expanded into the lower-level backend.","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"# lower-level backend \n@showprogress for iter = 1:nt\n    # horizontal flux\n    @inbounds Threads.@threads for j = 1:ks.pSpace.ny\n        for i = 2:ks.pSpace.nx\n            KitBase.flux_kfvs!(\n                a1face[i, j].fw,\n                a1face[i, j].fh,\n                a1face[i, j].fb,\n                ctr[i-1, j].h,\n                ctr[i-1, j].b,\n                ctr[i, j].h,\n                ctr[i, j].b,\n                ks.vSpace.u,\n                ks.vSpace.v,\n                ks.vSpace.weights,\n                dt,\n                a1face[i, j].len,\n            )\n        end\n    end\n    \n    # vertical flux\n    vn = ks.vSpace.v\n    vt = -ks.vSpace.u\n    @inbounds Threads.@threads for j = 2:ks.pSpace.ny\n        for i = 1:ks.pSpace.nx\n            KitBase.flux_kfvs!(\n                a2face[i, j].fw,\n                a2face[i, j].fh,\n                a2face[i, j].fb,\n                ctr[i, j-1].h,\n                ctr[i, j-1].b,\n                ctr[i, j].h,\n                ctr[i, j].b,\n                vn,\n                vt,\n                ks.vSpace.weights,\n                dt,\n                a2face[i, j].len,\n            )\n            a2face[i, j].fw .= KitBase.global_frame(a2face[i, j].fw, 0., 1.)\n        end\n    end\n    \n    # boundary flux\n    @inbounds Threads.@threads for j = 1:ks.pSpace.ny\n        KitBase.flux_boundary_maxwell!(\n            a1face[1, j].fw,\n            a1face[1, j].fh,\n            a1face[1, j].fb,\n            ks.ib.bcL,\n            ctr[1, j].h,\n            ctr[1, j].b,\n            ks.vSpace.u,\n            ks.vSpace.v,\n            ks.vSpace.weights,\n            ks.gas.K,\n            dt,\n            ctr[1, j].dy,\n            1.,\n        )\n\n        KitBase.flux_boundary_maxwell!(\n            a1face[ks.pSpace.nx+1, j].fw,\n            a1face[ks.pSpace.nx+1, j].fh,\n            a1face[ks.pSpace.nx+1, j].fb,\n            ks.ib.bcR,\n            ctr[ks.pSpace.nx, j].h,\n            ctr[ks.pSpace.nx, j].b,\n            ks.vSpace.u,\n            ks.vSpace.v,\n            ks.vSpace.weights,\n            ks.gas.K,\n            dt,\n            ctr[ks.pSpace.nx, j].dy,\n            -1.,\n        )\n    end\n    \n    @inbounds Threads.@threads for i = 1:ks.pSpace.nx\n        KitBase.flux_boundary_maxwell!(\n            a2face[i, 1].fw,\n            a2face[i, 1].fh,\n            a2face[i, 1].fb,\n            ks.ib.bcD,\n            ctr[i, 1].h,\n            ctr[i, 1].b,\n            vn,\n            vt,\n            ks.vSpace.weights,\n            ks.gas.K,\n            dt,\n            ctr[i, 1].dx,\n            1,\n        )\n        a2face[i, 1].fw .= KitBase.global_frame(a2face[i, 1].fw, 0., 1.)\n        \n        KitBase.flux_boundary_maxwell!(\n            a2face[i, ks.pSpace.ny+1].fw,\n            a2face[i, ks.pSpace.ny+1].fh,\n            a2face[i, ks.pSpace.ny+1].fb,\n            [1., 0.0, -0.15, 1.0],\n            ctr[i, ks.pSpace.ny].h,\n            ctr[i, ks.pSpace.ny].b,\n            vn,\n            vt,\n            ks.vSpace.weights,\n            ks.gas.K,\n            dt,\n            ctr[i, ks.pSpace.ny].dy,\n            -1,\n        )\n        a2face[i, ks.pSpace.ny+1].fw .= KitBase.global_frame(\n            a2face[i, ks.pSpace.ny+1].fw,\n            0.,\n            1.,\n        )\n    end\n\n    # update\n    @inbounds for j = 1:ks.pSpace.ny\n        for i = 1:ks.pSpace.nx\n            KitBase.step!(\n                ctr[i, j].w,\n                ctr[i, j].prim,\n                ctr[i, j].h,\n                ctr[i, j].b,\n                a1face[i, j].fw,\n                a1face[i, j].fh,\n                a1face[i, j].fb,\n                a1face[i+1, j].fw,\n                a1face[i+1, j].fh,\n                a1face[i+1, j].fb,\n                a2face[i, j].fw,\n                a2face[i, j].fh,\n                a2face[i, j].fb,\n                a2face[i, j+1].fw,\n                a2face[i, j+1].fh,\n                a2face[i, j+1].fb,\n                ks.vSpace.u,\n                ks.vSpace.v,\n                ks.vSpace.weights,\n                ks.gas.K,\n                ks.gas.γ,\n                ks.gas.μᵣ,\n                ks.gas.ω,\n                ks.gas.Pr,\n                ctr[i, j].dx * ctr[i, j].dy,\n                dt,\n                zeros(4),\n                zeros(4),\n                :bgk,\n            )\n        end\n    end\nend","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"The result can be visualized with built-in function plot_contour, which presents the contours of gas density, U-velocity, V-velocity and temperature inside the cavity.","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"KitBase.plot_contour(ks, ctr)","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"(Image: )","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"It is equivalent as the following low-level backend.","category":"page"},{"location":"eg_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"begin\n    using Plots\n    sol = zeros(4, ks.pSpace.nx, ks.pSpace.ny)\n    for i in axes(ρ, 1)\n        for j in axes(ρ, 2)\n            sol[1:3, i, j] .= ctr[i, j].prim[1:3]\n            sol[4, i, j] = 1.0 / ctr[i, j].prim[4]\n        end\n    end\n    contourf(ks.pSpace.x[1:ks.pSpace.nx, 1], ks.pSpace.y[1, 1:ks.pSpace.ny], sol[3, :, :]')\nend","category":"page"},{"location":"solver_reconstruction/#Reconstruction","page":"Reconstruction","title":"Reconstruction","text":"","category":"section"},{"location":"solver_reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"reconstruct!","category":"page"},{"location":"solver_reconstruction/#KitBase.reconstruct!","page":"Reconstruction","title":"KitBase.reconstruct!","text":"Reconstructor\n\n1D solver: reconstruct!(KS::SolverSet, ctr::AbstractArray{<:AbstractControlVolume1D,1})\n2D solver: reconstruct!(KS::SolverSet, ctr::AbstractArray{ControlVolume2D2F,2})\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"The reconstruction solver interpolates piecewise solutions with the desirable order of accuracy. The reconstruction stencils can be based on 2 or 3 cells","category":"page"},{"location":"solver_reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"reconstruct2\nreconstruct2!\nreconstruct3\nreconstruct3!","category":"page"},{"location":"solver_reconstruction/#KitBase.reconstruct2","page":"Reconstruction","title":"KitBase.reconstruct2","text":"Two-cell reconstruction\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.reconstruct2!","page":"Reconstruction","title":"KitBase.reconstruct2!","text":"Two-cell reconstruction\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.reconstruct3","page":"Reconstruction","title":"KitBase.reconstruct3","text":"Three-cell reconstruction\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.reconstruct3!","page":"Reconstruction","title":"KitBase.reconstruct3!","text":"Three-cell reconstruction\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"The available schemes are","category":"page"},{"location":"solver_reconstruction/","page":"Reconstruction","title":"Reconstruction","text":"vanleer\nminmod\nsuperbee\nvanalbaba\nweno5","category":"page"},{"location":"solver_reconstruction/#KitBase.vanleer","page":"Reconstruction","title":"KitBase.vanleer","text":"van Leer limiter\n\nvanleer(sL::Real, sR::Real)\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.minmod","page":"Reconstruction","title":"KitBase.minmod","text":"minmod limiter\n\nminmod(sL::Real, sR::Real)\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.superbee","page":"Reconstruction","title":"KitBase.superbee","text":"superbee limiter\n\nsuperbee(sL::Real, sR::Real)\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.vanalbaba","page":"Reconstruction","title":"KitBase.vanalbaba","text":"van Albaba limiter\n\nvanalbaba(sL::Real, sR::Real)\n\n\n\n\n\n","category":"function"},{"location":"solver_reconstruction/#KitBase.weno5","page":"Reconstruction","title":"KitBase.weno5","text":"5th-order WENO-JS interpolation\n\nweno5(wL2::T, wL1::T, wN::T, wR1::T, wR2::T) where {T}\n\n\n\n\n\n","category":"function"},{"location":"#Kinetic.jl","page":"Home","title":"Kinetic.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetic is a lightweight Julia toolbox for the study of computational fluid dynamics and scientific machine learning. The main module consists of KitBase.jl with basic physics and KitML.jl with neural dynamics.  The high-performance Fortran library KitFort.jl is optional and can be manually imported when the executing efficiency becomes the first priority.  A wrapper kineticpy has been built to locate the data hierarchies and methods in Python.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Kinetic is interested in theoretical modeling and numerical simulation of many-particle systems, e.g. gases, photons, plasmas, neutrons, electrons, etc. It employs the finite volume method (FVM) to conduct 1-3 dimensional numerical simulations on CPUs and GPUs. Any advection-diffusion type equation can be hooked and solved within the framework. The user interface is designed as intuitive and neat as possible. The combined development of high-level and low-level APIs allows users to focus on physics and to cooperate with existing packages in the Julia ecosystem.","category":"page"},{"location":"#Getting-help","page":"Home","title":"Getting help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are interested in using Kinetic.jl or are trying to figure out how to use it, please feel free to get in touch and raise questions. Open an issue or pull request if you have questions, suggestions or solutions.","category":"page"}]
}
