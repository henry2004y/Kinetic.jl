<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Type · Kinetic.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Kinetic.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li class="is-active"><a class="tocitem" href>Type</a></li><li><a class="tocitem" href="../algorithm/">Algorithm</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api_io/">I / O</a></li><li><a class="tocitem" href="../api_math/">Math</a></li><li><a class="tocitem" href="../api_geo/">Physical Space</a></li><li><a class="tocitem" href="../api_theory/">Theory</a></li><li><a class="tocitem" href="../api_phase/">Phase Space</a></li><li><a class="tocitem" href="../api_reconstruct/">Reconstruction</a></li><li><a class="tocitem" href="../api_flux/">Flux</a></li><li><a class="tocitem" href="../api_config/">Configuration</a></li><li><a class="tocitem" href="../api_solver/">Solver</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Type</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Type</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/vavrines/Kinetic.jl/blob/master/docs/src/type.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Structure"><a class="docs-heading-anchor" href="#Data-Structure">Data Structure</a><a id="Data-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structure" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.ControlVolume1D</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.ControlVolume1D1F</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.ControlVolume1D2F</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.ControlVolume1D3F</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.ControlVolume1D4F</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.ControlVolume2D</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.ControlVolume2D1F</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.ControlVolume2D2F</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.ControlVolume2D3F</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.Interface1D</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.Interface1D1F</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.Interface1D2F</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.Interface1D3F</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.Interface1D4F</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.Interface2D</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.Interface2D1F</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Kinetic.KitBase.Interface2D2F</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="KitBase.aap_hs_collision_time-Union{Tuple{T}, Tuple{T,Any,Any,Any,Any,Any}} where T&lt;:(AbstractArray{var&quot;#s58&quot;,2} where var&quot;#s58&quot;&lt;:Real)" href="#KitBase.aap_hs_collision_time-Union{Tuple{T}, Tuple{T,Any,Any,Any,Any,Any}} where T&lt;:(AbstractArray{var&quot;#s58&quot;,2} where var&quot;#s58&quot;&lt;:Real)"><code>KitBase.aap_hs_collision_time</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate mixture collision time from AAP model</p><p><code>aap_hs_collision_time(     prim::AbstractArray{&lt;:Real,2},     mi::Real,     ni::Real,     me::Real,     ne::Real,     kn::Real, )</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.aap_hs_diffeq!-NTuple{4,Any}" href="#KitBase.aap_hs_diffeq!-NTuple{4,Any}"><code>KitBase.aap_hs_diffeq!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Source term of AAP model in DifferentialEquations.jl</p><p><code>aap_hs_diffeq!(du, u, p, t)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.aap_hs_prim-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Any,Any,Any,Any,Any}} where Y&lt;:(AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s57&quot;,2} where var&quot;#s57&quot;&lt;:Real)" href="#KitBase.aap_hs_prim-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Any,Any,Any,Any,Any}} where Y&lt;:(AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s57&quot;,2} where var&quot;#s57&quot;&lt;:Real)"><code>KitBase.aap_hs_prim</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate mixture primitive variables from AAP model</p><p><em>tested √</em></p><p><code>aap_hs_prim(     prim::AbstractArray{&lt;:Real,2},     tau::AbstractArray{&lt;:Real,1},     mi::Real,     ni::Real,     me::Real,     ne::Real,     kn::Real, )</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.advection_flux-Tuple{Any,Any}" href="#KitBase.advection_flux-Tuple{Any,Any}"><code>KitBase.advection_flux</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Theoretical flux of linear advection equation</p><pre><code class="language-none">advection_flux(u, a)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.angle-Union{Tuple{T}, Tuple{T,T,T}, Tuple{T,T,T,Any}} where T&lt;:(AbstractArray{var&quot;#s57&quot;,1} where var&quot;#s57&quot;&lt;:Real)" href="#KitBase.angle-Union{Tuple{T}, Tuple{T,T,T}, Tuple{T,T,T,Any}} where T&lt;:(AbstractArray{var&quot;#s57&quot;,1} where var&quot;#s57&quot;&lt;:Real)"><code>KitBase.angle</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Args order (B,A,C) isn&#39;t a mistake</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.boltzmann_fft!-Union{Tuple{I}, Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,X,Any,I,Y,Y,Z}} where I&lt;:Int64 where Z&lt;:(AbstractArray{var&quot;#s53&quot;,3} where var&quot;#s53&quot;&lt;:AbstractFloat) where Y&lt;:(AbstractArray{var&quot;#s54&quot;,4} where var&quot;#s54&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s55&quot;,3} where var&quot;#s55&quot;&lt;:AbstractFloat)" href="#KitBase.boltzmann_fft!-Union{Tuple{I}, Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,X,Any,I,Y,Y,Z}} where I&lt;:Int64 where Z&lt;:(AbstractArray{var&quot;#s53&quot;,3} where var&quot;#s53&quot;&lt;:AbstractFloat) where Y&lt;:(AbstractArray{var&quot;#s54&quot;,4} where var&quot;#s54&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s55&quot;,3} where var&quot;#s55&quot;&lt;:AbstractFloat)"><code>KitBase.boltzmann_fft!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate collision operator with FFT-based fast spectral method</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.boltzmann_fft-Union{Tuple{I}, Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Any,I,Y,Y,Z}} where I&lt;:Int64 where Z&lt;:(AbstractArray{var&quot;#s53&quot;,3} where var&quot;#s53&quot;&lt;:AbstractFloat) where Y&lt;:(AbstractArray{var&quot;#s54&quot;,4} where var&quot;#s54&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s55&quot;,3} where var&quot;#s55&quot;&lt;:AbstractFloat)" href="#KitBase.boltzmann_fft-Union{Tuple{I}, Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Any,I,Y,Y,Z}} where I&lt;:Int64 where Z&lt;:(AbstractArray{var&quot;#s53&quot;,3} where var&quot;#s53&quot;&lt;:AbstractFloat) where Y&lt;:(AbstractArray{var&quot;#s54&quot;,4} where var&quot;#s54&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s55&quot;,3} where var&quot;#s55&quot;&lt;:AbstractFloat)"><code>KitBase.boltzmann_fft</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate collision operator with FFT-based fast spectral method</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.burgers_flux-Tuple{Any}" href="#KitBase.burgers_flux-Tuple{Any}"><code>KitBase.burgers_flux</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Theoretical flux of Burgers&#39; equation</p><pre><code class="language-none">burgers_flux(u)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.central_diff!-Tuple{AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;,AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;,AbstractArray{var&quot;#s53&quot;,1} where var&quot;#s53&quot;}" href="#KitBase.central_diff!-Tuple{AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;,AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;,AbstractArray{var&quot;#s53&quot;,1} where var&quot;#s53&quot;}"><code>KitBase.central_diff!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Central difference</p><pre><code class="language-none">central_diff!(dy::AbstractArray{&lt;:Any,1}, y::AbstractArray{&lt;:Any,1}, x::AbstractArray{&lt;:Any,1})

central_diff!(dy::AbstractArray{&lt;:Any,1}, y::AbstractArray{&lt;:Any,1}, dx::Any)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.central_diff-Tuple{AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;,AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;}" href="#KitBase.central_diff-Tuple{AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;,AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;}"><code>KitBase.central_diff</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Central difference</p><pre><code class="language-none">central_diff(y::AbstractArray{&lt;:Any,1}, x::AbstractArray{&lt;:Any,1})

central_diff(y::AbstractArray{&lt;:Any,1}, dx::Any)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.conserve_prim-Tuple{Any}" href="#KitBase.conserve_prim-Tuple{Any}"><code>KitBase.conserve_prim</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transform conservative -&gt; primitive variables</p><ul><li><p>scalar: pseudo primitive vector for scalar conservation laws</p><p>conserve_prim(u)</p><p>conserve_prim(u, a)</p></li><li><p>vector: primitive vector for Euler, Navier-Stokes and extended equations</p><p>conserve_prim(W::T, γ) where {T&lt;:AbstractArray{&lt;:Real,1}}</p><p>conserve_prim(ρ, M, E, γ)</p><p>conserve_prim(ρ, MX, MY, E, γ)</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.discrete_moments-Union{Tuple{T}, Tuple{X}, Tuple{X,T}} where T&lt;:(AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s57&quot;,1} where var&quot;#s57&quot;&lt;:AbstractFloat)" href="#KitBase.discrete_moments-Union{Tuple{T}, Tuple{X}, Tuple{X,T}} where T&lt;:(AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s57&quot;,1} where var&quot;#s57&quot;&lt;:AbstractFloat)"><code>KitBase.discrete_moments</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Discrete moments of particle distribution</p><ul><li><code>discrete_moments(f, ω)</code>: direct quadrature</li><li><code>discrete_moments(f, u, ω, n)</code>: velocity moments</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.em_coefficients-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Z,Any,Any,Any,Any}} where Z&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:Real) where Y&lt;:(AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s56&quot;,2} where var&quot;#s56&quot;&lt;:Real)" href="#KitBase.em_coefficients-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Z,Any,Any,Any,Any}} where Z&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:Real) where Y&lt;:(AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s56&quot;,2} where var&quot;#s56&quot;&lt;:Real)"><code>KitBase.em_coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate electromagnetic coeffcients in hyperbolic Maxwell&#39;s equations</p><pre><code class="language-none">em_coefficients(
    prim::X,
    E::Y,
    B::Z,
    mr,
    lD,
    rL,
    dt,
) where {X&lt;:AbstractArray{&lt;:Real,2},Y&lt;:AbstractArray{&lt;:Real,1},Z&lt;:AbstractArray{&lt;:Real,1}}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.euler_flux-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:(AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;&lt;:Real)" href="#KitBase.euler_flux-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:(AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;&lt;:Real)"><code>KitBase.euler_flux</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Theoretical fluxes of Euler Equations</p><pre><code class="language-none">euler_flux(w::A, γ; frame = :cartesian::Symbol) where {A&lt;:AbstractArray{&lt;:Real,1}}</code></pre><ul><li>@return: flux tuple</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.euler_jacobi-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:(AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Real)" href="#KitBase.euler_jacobi-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:(AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Real)"><code>KitBase.euler_jacobi</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Flux Jacobian of Euler Equations</p><pre><code class="language-none">euler_jacobi(w::T, γ) where {T&lt;:AbstractArray{&lt;:Real,1}}</code></pre><ul><li>@return: Jacobian matrix A</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.evolve!-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Z,Any}} where Z&lt;:(AbstractArray{var&quot;#s53&quot;,1} where var&quot;#s53&quot;&lt;:AbstractInterface1D) where Y&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:AbstractControlVolume1D) where X&lt;:AbstractSolverSet" href="#KitBase.evolve!-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Z,Any}} where Z&lt;:(AbstractArray{var&quot;#s53&quot;,1} where var&quot;#s53&quot;&lt;:AbstractInterface1D) where Y&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:AbstractControlVolume1D) where X&lt;:AbstractSolverSet"><code>KitBase.evolve!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evolution</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.extract_last-Tuple{AbstractArray,Int64}" href="#KitBase.extract_last-Tuple{AbstractArray,Int64}"><code>KitBase.extract_last</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Extract subarray except the last column</p><pre><code class="language-none">extract_last(a::AbstractArray, idx::Int; mode=:view::Symbol)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.flux_boundary_maxwell!-Union{Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T3,T4,T4,T5,T5,T5,Any,Any,Any}, Tuple{T1,T2,T2,T3,T4,T4,T5,T5,T5,Any,Any,Any,Any}} where T5&lt;:(AbstractArray{var&quot;#s195&quot;,2} where var&quot;#s195&quot;&lt;:AbstractFloat) where T4&lt;:(AbstractArray{var&quot;#s196&quot;,2} where var&quot;#s196&quot;&lt;:AbstractFloat) where T3&lt;:(Array{var&quot;#s197&quot;,1} where var&quot;#s197&quot;&lt;:Real) where T2&lt;:(AbstractArray{var&quot;#s198&quot;,2} where var&quot;#s198&quot;&lt;:AbstractFloat) where T1&lt;:(AbstractArray{var&quot;#s199&quot;,1} where var&quot;#s199&quot;&lt;:AbstractFloat)" href="#KitBase.flux_boundary_maxwell!-Union{Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T3,T4,T4,T5,T5,T5,Any,Any,Any}, Tuple{T1,T2,T2,T3,T4,T4,T5,T5,T5,Any,Any,Any,Any}} where T5&lt;:(AbstractArray{var&quot;#s195&quot;,2} where var&quot;#s195&quot;&lt;:AbstractFloat) where T4&lt;:(AbstractArray{var&quot;#s196&quot;,2} where var&quot;#s196&quot;&lt;:AbstractFloat) where T3&lt;:(Array{var&quot;#s197&quot;,1} where var&quot;#s197&quot;&lt;:Real) where T2&lt;:(AbstractArray{var&quot;#s198&quot;,2} where var&quot;#s198&quot;&lt;:AbstractFloat) where T1&lt;:(AbstractArray{var&quot;#s199&quot;,1} where var&quot;#s199&quot;&lt;:AbstractFloat)"><code>KitBase.flux_boundary_maxwell!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Maxwell&#39;s diffusive boundary flux</p><ul><li>@args: particle distribution functions and their slopes at left/right sides of interface</li><li>@args: particle velocity quadrature points and weights</li><li>@args: time step</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.flux_em!-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T1,T2,T2,T2,T2,T2,T2,T2,T2,Any,Any,Any,Any,Any,Any,T3,T3,T4,Any,Any,Any,Any}} where T4&lt;:(AbstractArray{var&quot;#s200&quot;,1} where var&quot;#s200&quot;&lt;:Real) where T3&lt;:(AbstractArray{var&quot;#s201&quot;,2} where var&quot;#s201&quot;&lt;:Real) where T2&lt;:(AbstractArray{var&quot;#s202&quot;,1} where var&quot;#s202&quot;&lt;:Real) where T1&lt;:(AbstractArray{var&quot;#s203&quot;,1} where var&quot;#s203&quot;&lt;:AbstractFloat)" href="#KitBase.flux_em!-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T1,T2,T2,T2,T2,T2,T2,T2,T2,Any,Any,Any,Any,Any,Any,T3,T3,T4,Any,Any,Any,Any}} where T4&lt;:(AbstractArray{var&quot;#s200&quot;,1} where var&quot;#s200&quot;&lt;:Real) where T3&lt;:(AbstractArray{var&quot;#s201&quot;,2} where var&quot;#s201&quot;&lt;:Real) where T2&lt;:(AbstractArray{var&quot;#s202&quot;,1} where var&quot;#s202&quot;&lt;:Real) where T1&lt;:(AbstractArray{var&quot;#s203&quot;,1} where var&quot;#s203&quot;&lt;:AbstractFloat)"><code>KitBase.flux_em!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Wave propagation method for Maxwell&#39;s equations</p><pre><code class="language-none">flux_em!(femL, femR, ELL, BLL, EL, BL, ER, BR, ERR, BRR, ϕL, ϕR, ψL, ψR, dxL, dxR, Ap, An, D, sol, χ, ν, dt)</code></pre><ul><li>@args: {E, B, ϕ, ψ} in left-left, left, right, and right-right cells</li><li>@args: eigenmatrix (A -&gt; A+ &amp; A-), eigenvalue (D)</li><li>@args: full size of left &amp; right cells</li><li>@args: speed of light (sol)</li><li>@args: auxiliary parameters (χₑ, νᵦ)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.flux_emx!-Union{Tuple{B}, Tuple{A}, Tuple{Y}, Tuple{X}, Tuple{X,X,X,X,X,X,Y,Y,Y,Y,Y,Y,Y,Y,Any,Any,Any,Any,Any,Any,A,A,A,A,B,Any,Any,Any,Any}} where B&lt;:(AbstractArray{var&quot;#s198&quot;,1} where var&quot;#s198&quot;&lt;:Real) where A&lt;:(AbstractArray{var&quot;#s199&quot;,2} where var&quot;#s199&quot;&lt;:Real) where Y&lt;:(AbstractArray{var&quot;#s200&quot;,1} where var&quot;#s200&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s201&quot;,1} where var&quot;#s201&quot;&lt;:AbstractFloat)" href="#KitBase.flux_emx!-Union{Tuple{B}, Tuple{A}, Tuple{Y}, Tuple{X}, Tuple{X,X,X,X,X,X,Y,Y,Y,Y,Y,Y,Y,Y,Any,Any,Any,Any,Any,Any,A,A,A,A,B,Any,Any,Any,Any}} where B&lt;:(AbstractArray{var&quot;#s198&quot;,1} where var&quot;#s198&quot;&lt;:Real) where A&lt;:(AbstractArray{var&quot;#s199&quot;,2} where var&quot;#s199&quot;&lt;:Real) where Y&lt;:(AbstractArray{var&quot;#s200&quot;,1} where var&quot;#s200&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s201&quot;,1} where var&quot;#s201&quot;&lt;:AbstractFloat)"><code>KitBase.flux_emx!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Wave propagation method for 2D Maxwell&#39;s equations</p><pre><code class="language-none">flux_emx!(femL, femR, femLU, femLD, femRU, femRD,
ELL, BLL, EL, BL, ER, BR, ERR, BRR, ϕL, ϕR, ψL, ψR,
dxL, dxR, A1p, A1n, A2p, A2n, D, sol, χ, ν, dt)</code></pre><ul><li>@args: {E, B, ϕ, ψ} in left-left, left, right, and right-right cells</li><li>@args: eigenmatrix (A -&gt; A+ &amp; A-), eigenvalue (D)</li><li>@args: full size of left &amp; right cells</li><li>@args: speed of light (sol)</li><li>@args: auxiliary parameters (χₑ, νᵦ)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.flux_emy!-Tuple{AbstractArray{var&quot;#s186&quot;,1} where var&quot;#s186&quot;&lt;:Real,AbstractArray{var&quot;#s185&quot;,1} where var&quot;#s185&quot;&lt;:Real,AbstractArray{var&quot;#s184&quot;,1} where var&quot;#s184&quot;&lt;:Real,AbstractArray{var&quot;#s59&quot;,1} where var&quot;#s59&quot;&lt;:Real,AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Real,AbstractArray{var&quot;#s57&quot;,1} where var&quot;#s57&quot;&lt;:Real,AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;&lt;:Real,AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;&lt;:Real,AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:Real,AbstractArray{var&quot;#s53&quot;,1} where var&quot;#s53&quot;&lt;:Real,AbstractArray{var&quot;#s52&quot;,1} where var&quot;#s52&quot;&lt;:Real,AbstractArray{var&quot;#s51&quot;,1} where var&quot;#s51&quot;&lt;:Real,AbstractArray{var&quot;#s50&quot;,1} where var&quot;#s50&quot;&lt;:Real,AbstractArray{var&quot;#s49&quot;,1} where var&quot;#s49&quot;&lt;:Real,Real,Real,Real,Real,Real,Real,AbstractArray{var&quot;#s48&quot;,2} where var&quot;#s48&quot;&lt;:Real,AbstractArray{var&quot;#s47&quot;,2} where var&quot;#s47&quot;&lt;:Real,AbstractArray{var&quot;#s46&quot;,2} where var&quot;#s46&quot;&lt;:Real,AbstractArray{var&quot;#s45&quot;,2} where var&quot;#s45&quot;&lt;:Real,AbstractArray{var&quot;#s44&quot;,1} where var&quot;#s44&quot;&lt;:Real,Real,Real,Real,Real}" href="#KitBase.flux_emy!-Tuple{AbstractArray{var&quot;#s186&quot;,1} where var&quot;#s186&quot;&lt;:Real,AbstractArray{var&quot;#s185&quot;,1} where var&quot;#s185&quot;&lt;:Real,AbstractArray{var&quot;#s184&quot;,1} where var&quot;#s184&quot;&lt;:Real,AbstractArray{var&quot;#s59&quot;,1} where var&quot;#s59&quot;&lt;:Real,AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Real,AbstractArray{var&quot;#s57&quot;,1} where var&quot;#s57&quot;&lt;:Real,AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;&lt;:Real,AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;&lt;:Real,AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:Real,AbstractArray{var&quot;#s53&quot;,1} where var&quot;#s53&quot;&lt;:Real,AbstractArray{var&quot;#s52&quot;,1} where var&quot;#s52&quot;&lt;:Real,AbstractArray{var&quot;#s51&quot;,1} where var&quot;#s51&quot;&lt;:Real,AbstractArray{var&quot;#s50&quot;,1} where var&quot;#s50&quot;&lt;:Real,AbstractArray{var&quot;#s49&quot;,1} where var&quot;#s49&quot;&lt;:Real,Real,Real,Real,Real,Real,Real,AbstractArray{var&quot;#s48&quot;,2} where var&quot;#s48&quot;&lt;:Real,AbstractArray{var&quot;#s47&quot;,2} where var&quot;#s47&quot;&lt;:Real,AbstractArray{var&quot;#s46&quot;,2} where var&quot;#s46&quot;&lt;:Real,AbstractArray{var&quot;#s45&quot;,2} where var&quot;#s45&quot;&lt;:Real,AbstractArray{var&quot;#s44&quot;,1} where var&quot;#s44&quot;&lt;:Real,Real,Real,Real,Real}"><code>KitBase.flux_emy!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Wave propagation method for 2D Maxwell&#39;s equations</p><pre><code class="language-none">flux_emx!(femL, femR, femLU, femLD, femRU, femRD,
ELL, BLL, EL, BL, ER, BR, ERR, BRR, ϕL, ϕR, ψL, ψR,
dxL, dxR, A1p, A1n, A2p, A2n, D, sol, χ, ν, dt)</code></pre><ul><li>@args: {E, B, ϕ, ψ} in left-left, left, right, and right-right cells</li><li>@args: eigenmatrix (A -&gt; A+ &amp; A-), eigenvalue (D)</li><li>@args: full size of left &amp; right cells</li><li>@args: speed of light (sol)</li><li>@args: auxiliary parameters (χₑ, νᵦ)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.flux_gks!-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,Real,Real,Real,Real,Real,Real}, Tuple{X,Y,Y,Real,Real,Real,Real,Real,Real,Any}, Tuple{X,Y,Y,Real,Real,Real,Real,Real,Real,Any,Any}} where Y&lt;:(AbstractArray{var&quot;#s198&quot;,1} where var&quot;#s198&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s199&quot;,1} where var&quot;#s199&quot;&lt;:AbstractFloat)" href="#KitBase.flux_gks!-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,Real,Real,Real,Real,Real,Real}, Tuple{X,Y,Y,Real,Real,Real,Real,Real,Real,Any}, Tuple{X,Y,Y,Real,Real,Real,Real,Real,Real,Any,Any}} where Y&lt;:(AbstractArray{var&quot;#s198&quot;,1} where var&quot;#s198&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s199&quot;,1} where var&quot;#s199&quot;&lt;:AbstractFloat)"><code>KitBase.flux_gks!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gas kinetic Navier-Stokes flux</p><pre><code class="language-none">1D: flux_gks!(fw, wL, wR, γ, K, μᵣ, ω, dt, dx, swL, swR)
2D: flux_gks!(fw, wL, wR, γ, K, μᵣ, ω, dt, dx, dy, swL, swR)</code></pre><ul><li>@args: conservative variables and their left/right slopes</li><li>@args: molecular and thermodynamic parameters</li><li>@args: time step and cell size</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.flux_gks-Union{Tuple{T}, Tuple{T,Any,Any}, Tuple{T,Any,Any,Any}, Tuple{T,Any,Any,Any,Any}} where T&lt;:Real" href="#KitBase.flux_gks-Union{Tuple{T}, Tuple{T,Any,Any}, Tuple{T,Any,Any,Any}, Tuple{T,Any,Any,Any,Any}} where T&lt;:Real"><code>KitBase.flux_gks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gas kinetic Navier-Stokes flux</p><pre><code class="language-none">flux_gks(u::Real, μ::Real, dt::Real, su = 0.0::Real, a = 0::Real)
flux_gks(uL::Real, uR::Real, μ::Real, dt::Real, dxL::Real,
    dxR::Real, suL = 0.0::Real, suR = 0.0::Real, a = 0::Real)</code></pre><ul><li>@args: conservative scalars and their slopes</li><li>@args: viscosity</li><li>@args: time step and cell size</li><li>@return: scalar flux</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.flux_hll!-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,Any,Any}} where Y&lt;:(AbstractArray{var&quot;#s206&quot;,1} where var&quot;#s206&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s207&quot;,1} where var&quot;#s207&quot;&lt;:Real)" href="#KitBase.flux_hll!-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,Any,Any}} where Y&lt;:(AbstractArray{var&quot;#s206&quot;,1} where var&quot;#s206&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s207&quot;,1} where var&quot;#s207&quot;&lt;:Real)"><code>KitBase.flux_hll!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>HLL flux for the Euler equations</p><pre><code class="language-none">flux_hll!(fw::AbstractArray{&lt;:Real,1}, wL::AbstractArray{&lt;:Real,1}, wR::AbstractArray{&lt;:Real,1}, γ::Real, dt::Real)</code></pre><ul><li>@args: variables at left &amp; right sides of interface</li><li>@args: specific heat ratio</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.flux_kcu!-Union{Tuple{B}, Tuple{A}, Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Z,A,Z,A,B,B,Any,Any,Any,Any,Any,Any}} where B&lt;:(AbstractArray{var&quot;#s196&quot;,1} where var&quot;#s196&quot;&lt;:AbstractFloat) where A&lt;:(AbstractArray{var&quot;#s197&quot;,1} where var&quot;#s197&quot;&lt;:AbstractFloat) where Z&lt;:(AbstractArray{var&quot;#s198&quot;,1} where var&quot;#s198&quot;&lt;:Real) where Y&lt;:(AbstractArray{var&quot;#s199&quot;,1} where var&quot;#s199&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s200&quot;,1} where var&quot;#s200&quot;&lt;:AbstractFloat)" href="#KitBase.flux_kcu!-Union{Tuple{B}, Tuple{A}, Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Z,A,Z,A,B,B,Any,Any,Any,Any,Any,Any}} where B&lt;:(AbstractArray{var&quot;#s196&quot;,1} where var&quot;#s196&quot;&lt;:AbstractFloat) where A&lt;:(AbstractArray{var&quot;#s197&quot;,1} where var&quot;#s197&quot;&lt;:AbstractFloat) where Z&lt;:(AbstractArray{var&quot;#s198&quot;,1} where var&quot;#s198&quot;&lt;:Real) where Y&lt;:(AbstractArray{var&quot;#s199&quot;,1} where var&quot;#s199&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s200&quot;,1} where var&quot;#s200&quot;&lt;:AbstractFloat)"><code>KitBase.flux_kcu!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Kinetic central-upwind (KCU) method</p><pre><code class="language-none">1D1F1V: flux_kcu!(fw, ff, wL, fL, wR, fR, u, ω, inK, γ, visRef, visIdx, Pr, dt)
1D2F1V: flux_kcu!(fw, fh, fb, wL, hL, bL, wR, hR, bR, u, ω, inK, γ, visRef, visIdx, Pr, dt)
1D4F1V: flux_kcu!(fw, fh0, fh1, fh2, fh3, wL, h0L, h1L, h2L, h3L, wR, h0R, h1R, h2R, h3R, u, ω, inK, γ, visRef, visIdx, Pr, dt)
2D1F2V: flux_kcu!(fw, ff, wL, fL, wR, fR, u, v, ω, inK, γ, visRef, visIdx, Pr, dt, len)
2D2F2V: flux_kcu!(fw, fh, fb, wL, hL, bL, wR, hR, bR, u, v, ω, inK, γ, visRef, visIdx, Pr, dt, len)
2D3F2V: flux_kcu!(fw, fh0, fh1, fh2, wL, h0L, h1L, h2L, wR, h0R, h1R, h2R, u, v, ω, inK, γ, visRef, visIdx, Pr, dt, len)</code></pre><ul><li>@args: particle distribution functions and their slopes at left/right sides of interface</li><li>@args: particle velocity quadrature points and weights</li><li>@args: time step and cell size</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.flux_kfvs!-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,Z,Any}, Tuple{X,Y,Y,Z,Any,Any}, Tuple{X,Y,Y,Z,Any,Any,Any}} where Z&lt;:(AbstractArray{var&quot;#s48&quot;,1} where var&quot;#s48&quot;&lt;:AbstractFloat) where Y&lt;:(AbstractArray{var&quot;#s49&quot;,1} where var&quot;#s49&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s50&quot;,1} where var&quot;#s50&quot;&lt;:AbstractFloat)" href="#KitBase.flux_kfvs!-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,Z,Any}, Tuple{X,Y,Y,Z,Any,Any}, Tuple{X,Y,Y,Z,Any,Any,Any}} where Z&lt;:(AbstractArray{var&quot;#s48&quot;,1} where var&quot;#s48&quot;&lt;:AbstractFloat) where Y&lt;:(AbstractArray{var&quot;#s49&quot;,1} where var&quot;#s49&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s50&quot;,1} where var&quot;#s50&quot;&lt;:AbstractFloat)"><code>KitBase.flux_kfvs!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Kinetic flux vector splitting (KFVS) flux</p><pre><code class="language-none">DOM: `flux_kfvs!(ff, fL, fR, u, dt, sfL, sfR)`
1D1F1V: `flux_kfvs!(fw, ff, fL, fR, u, ω, dt, sfL, sfR)`
1D1F3V: `flux_kfvs!(fw, ff, fL, fR, u, v, w, ω, dt, sfL, sfR)`
1D2F1V: `flux_kfvs!(fw, fh, fb, hL, bL, hR, bR, u, ω, dt, shL, sbL, shR, sbR)`
1D4F1V: `flux_kfvs!(fw, fh0, fh1, fh2, fh3, h0L, h1L, h2L, h3L, h0R, h1R, h2R, h3R, u, ω, dt, sh0L, sh1L, sh2L, sh3L, sh0R, sh1R, sh2R, sh3R)`
2D1F2V: `flux_kfvs!(fw, ff, fL, fR, u, v, ω, dt, len, sfL, sfR)`
2D2F2V: `flux_kfvs!(fw, fh, fb, hL, bL, hR, bR, u, v, ω, dt, len, shL, sbL, shR, sbR)`</code></pre><ul><li>@args: particle distribution functions and their left/right slopes</li><li>@args: particle velocity quadrature points and weights</li><li>@args: time step and cell size</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.flux_lax!-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,Any,Any,Any}} where Y&lt;:(AbstractArray{var&quot;#s206&quot;,1} where var&quot;#s206&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s207&quot;,1} where var&quot;#s207&quot;&lt;:Real)" href="#KitBase.flux_lax!-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,Any,Any,Any}} where Y&lt;:(AbstractArray{var&quot;#s206&quot;,1} where var&quot;#s206&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s207&quot;,1} where var&quot;#s207&quot;&lt;:Real)"><code>KitBase.flux_lax!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Lax-Friedrichs flux</p><pre><code class="language-none">flux_lax!(fw::AbstractArray{&lt;:Real,1}, wL::AbstractArray{&lt;:Real,1}, wR::AbstractArray{&lt;:Real,1}, γ::Real, dt::Real, dx::Real)</code></pre><p><em>P. D. Lax, Weak Solutions of Nonlinear Hyperbolic Equations and Their Numerical Computation, Commun. Pure and Applied Mathematics, 7, 159-193, 1954.</em></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.flux_roe!-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,Any,Any}, Tuple{X,Y,Y,Any,Any,Any}} where Z&lt;:(AbstractArray{var&quot;#s198&quot;,1} where var&quot;#s198&quot;&lt;:Real) where Y&lt;:(AbstractArray{var&quot;#s199&quot;,1} where var&quot;#s199&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s200&quot;,1} where var&quot;#s200&quot;&lt;:Real)" href="#KitBase.flux_roe!-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,Any,Any}, Tuple{X,Y,Y,Any,Any,Any}} where Z&lt;:(AbstractArray{var&quot;#s198&quot;,1} where var&quot;#s198&quot;&lt;:Real) where Y&lt;:(AbstractArray{var&quot;#s199&quot;,1} where var&quot;#s199&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s200&quot;,1} where var&quot;#s200&quot;&lt;:Real)"><code>KitBase.flux_roe!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Roe&#39;s flux with entropy fix</p><pre><code class="language-none">flux_roe!(fw::AbstractArray{&lt;:Real,1}, wL::AbstractArray{&lt;:Real,1}, wR::AbstractArray{&lt;:Real,1},
γ::Real, dt::Real, n = [1.0, 0.0]::AbstractArray{&lt;:Real,1})</code></pre><p><em>P. L. Roe, Approximate Riemann Solvers, Parameter Vectors and Difference Schemes, Journal of Computational Physics, 43, pp. 357-372.</em> (<em>cf. http://cfdbooks.com/cfdcodes.html</em>)</p><ul><li>@args primL[1:4] = left state (rhoL, uL, vL, pL)</li><li>@args primR[1:4] = right state (rhoR, uR, vR, pR)</li><li>@args γ: specific heat ratio</li><li>@args n[2]: unit face normal (L -&gt; R)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.flux_ugks!-Union{Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T3,T4,T4,T3,T4,T4,T5,T5,Any,Any,Any,Any,Any,Any,Any,Any}, Tuple{T1,T2,T2,T3,T4,T4,T3,T4,T4,T5,T5,Any,Any,Any,Any,Any,Any,Any,Any,Any}, Tuple{T1,T2,T2,T3,T4,T4,T3,T4,T4,T5,T5,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any}, Tuple{T1,T2,T2,T3,T4,T4,T3,T4,T4,T5,T5,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any}, Tuple{T1,T2,T2,T3,T4,T4,T3,T4,T4,T5,T5,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any}} where T5&lt;:(AbstractArray{var&quot;#s52&quot;,1} where var&quot;#s52&quot;&lt;:AbstractFloat) where T4&lt;:(AbstractArray{var&quot;#s53&quot;,1} where var&quot;#s53&quot;&lt;:AbstractFloat) where T3&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:Real) where T2&lt;:(AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;&lt;:AbstractFloat) where T1&lt;:(AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;&lt;:AbstractFloat)" href="#KitBase.flux_ugks!-Union{Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T3,T4,T4,T3,T4,T4,T5,T5,Any,Any,Any,Any,Any,Any,Any,Any}, Tuple{T1,T2,T2,T3,T4,T4,T3,T4,T4,T5,T5,Any,Any,Any,Any,Any,Any,Any,Any,Any}, Tuple{T1,T2,T2,T3,T4,T4,T3,T4,T4,T5,T5,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any}, Tuple{T1,T2,T2,T3,T4,T4,T3,T4,T4,T5,T5,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any}, Tuple{T1,T2,T2,T3,T4,T4,T3,T4,T4,T5,T5,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any}} where T5&lt;:(AbstractArray{var&quot;#s52&quot;,1} where var&quot;#s52&quot;&lt;:AbstractFloat) where T4&lt;:(AbstractArray{var&quot;#s53&quot;,1} where var&quot;#s53&quot;&lt;:AbstractFloat) where T3&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:Real) where T2&lt;:(AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;&lt;:AbstractFloat) where T1&lt;:(AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;&lt;:AbstractFloat)"><code>KitBase.flux_ugks!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unified gas kinetic scheme (UGKS)</p><ul><li>@args: particle distribution functions and their slopes at left/right sides of interface</li><li>@args: particle velocity quadrature points and weights</li><li>@args: time step</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.fortsign-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:Real" href="#KitBase.fortsign-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:Real"><code>KitBase.fortsign</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Fortran sign function</p><pre><code class="language-none">fortsign(x::Real, y::Real)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.full_distribution-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,X,Y,Y,Z,Z,Any}, Tuple{X,X,Y,Y,Z,Z,Any,Any}} where Z&lt;:(AbstractArray{var&quot;#s48&quot;,3} where var&quot;#s48&quot;&lt;:AbstractFloat) where Y&lt;:(AbstractArray{var&quot;#s49&quot;,1} where var&quot;#s49&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s50&quot;,1} where var&quot;#s50&quot;&lt;:AbstractFloat)" href="#KitBase.full_distribution-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,X,Y,Y,Z,Z,Any}, Tuple{X,X,Y,Y,Z,Z,Any,Any}} where Z&lt;:(AbstractArray{var&quot;#s48&quot;,3} where var&quot;#s48&quot;&lt;:AbstractFloat) where Y&lt;:(AbstractArray{var&quot;#s49&quot;,1} where var&quot;#s49&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s50&quot;,1} where var&quot;#s50&quot;&lt;:AbstractFloat)"><code>KitBase.full_distribution</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Recover full distribution function from reduced ones</p><ul><li>@arg h &amp; b : reduced particle distribution function with 1D velocity space</li><li>@arg u : quadrature nodes in 1D velocity space</li><li>@arg weights : quadrature weights in 1D velocity space</li><li>@arg v &amp; w : quadrature nodes in the rest velocity space (with 3D setting)</li><li>@return f : particle distribution function with 3D velocity space</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.gauss_moments-Tuple{T} where T&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:Real)" href="#KitBase.gauss_moments-Tuple{T} where T&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:Real)"><code>KitBase.gauss_moments</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate moments of Gaussian distribution <code>G = (λ / π)^(D / 2) * exp[-λ(c^2 + ξ^2)]</code></p><ul><li>internality: <code>gauss_moments(prim::T) where {T&lt;:AbstractArray{&lt;:Real,1}}</code></li><li>no internality: <code>gauss_moments(prim::T, inK) where {T&lt;:AbstractArray{&lt;:Real,1}}</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.global_frame-Union{Tuple{T}, Tuple{T,Any,Any}} where T&lt;:(AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Real)" href="#KitBase.global_frame-Union{Tuple{T}, Tuple{T,Any,Any}} where T&lt;:(AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Real)"><code>KitBase.global_frame</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transform local flow variables to global frame</p><ul><li>2D: <code>global_frame(w::AbstractArray{&lt;:Real,1}, cosa::Real, sina::Real)</code></li><li>3D: <code>global_frame(w::AbstractArray{&lt;:Real,1}, dirccos::AbstractArray{&lt;:Real,2})</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.heat_capacity_ratio-Tuple{Real,Int64}" href="#KitBase.heat_capacity_ratio-Tuple{Real,Int64}"><code>KitBase.heat_capacity_ratio</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate heat capacity ratio</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.heat_flux-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Z,Z}} where Z&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:AbstractFloat) where Y&lt;:(AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;&lt;:AbstractFloat)" href="#KitBase.heat_flux-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Z,Z}} where Z&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:AbstractFloat) where Y&lt;:(AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;&lt;:AbstractFloat)"><code>KitBase.heat_flux</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate heat flux from particle distribution function</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.heaviside-Tuple{T} where T&lt;:Real" href="#KitBase.heaviside-Tuple{T} where T&lt;:Real"><code>KitBase.heaviside</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Heaviside step function</p><pre><code class="language-none">heaviside(x::Real)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.hs_boltz_kn-Tuple{Any,Any}" href="#KitBase.hs_boltz_kn-Tuple{Any,Any}"><code>KitBase.hs_boltz_kn</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Calculate effective Knudsen number for fast spectral method</strong></p><ul><li>hard sphere (HS) model</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.ib_briowu-Union{Tuple{T}, Tuple{Any,Any,Any,T}} where T&lt;:(AbstractArray{var&quot;#s206&quot;,2} where var&quot;#s206&quot;&lt;:AbstractFloat)" href="#KitBase.ib_briowu-Union{Tuple{T}, Tuple{Any,Any,Any,T}} where T&lt;:(AbstractArray{var&quot;#s206&quot;,2} where var&quot;#s206&quot;&lt;:AbstractFloat)"><code>KitBase.ib_briowu</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initialize Brio-Wu MHD shock</p><pre><code class="language-none">ib_briowu(gam, uspace::T, mi, me) where {T&lt;:AbstractArray{&lt;:AbstractFloat,2}}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.ib_cavity-Union{Tuple{T}, Tuple{Any,Any,Any,Any,T,T}} where T&lt;:(AbstractArray{var&quot;#s208&quot;,2} where var&quot;#s208&quot;&lt;:AbstractFloat)" href="#KitBase.ib_cavity-Union{Tuple{T}, Tuple{Any,Any,Any,Any,T,T}} where T&lt;:(AbstractArray{var&quot;#s208&quot;,2} where var&quot;#s208&quot;&lt;:AbstractFloat)"><code>KitBase.ib_cavity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initialize lid-driven cavity</p><ul><li>2d1f2v: <code>ib_cavity(   gam,   Um,   Vm,   Tm,   u::T,   v::T) where {T&lt;:AbstractArray{&lt;:AbstractFloat,2}}</code></li><li>2d2f2v: <code>ib_cavity(   gam,   Um,   Vm,   Tm,   u::T,   v::T,   K) where {T&lt;:AbstractArray{&lt;:AbstractFloat,2}}</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.ib_rh-Union{Tuple{T}, Tuple{Any,Any,T}} where T&lt;:(AbstractArray{var&quot;#s208&quot;,1} where var&quot;#s208&quot;&lt;:AbstractFloat)" href="#KitBase.ib_rh-Union{Tuple{T}, Tuple{Any,Any,T}} where T&lt;:(AbstractArray{var&quot;#s208&quot;,1} where var&quot;#s208&quot;&lt;:AbstractFloat)"><code>KitBase.ib_rh</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initialize Rankine-Hugoniot relation</p><ul><li>1d1f1v: <code>ib_rh(MaL, gam, u::T) where {T&lt;:AbstractArray{&lt;:AbstractFloat,1}}</code></li><li>1d2f1v: <code>ib_rh(MaL, gam, u::T, K) where {T&lt;:AbstractArray{&lt;:AbstractFloat,1}}</code></li><li>1d1f3v: <code>ib_rh(MaL, gam, u::T, v::T, w::T) where {T&lt;:AbstractArray{&lt;:AbstractFloat,3}}</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.ib_sod-Union{Tuple{T}, Tuple{Any,T}} where T&lt;:(AbstractArray{var&quot;#s208&quot;,1} where var&quot;#s208&quot;&lt;:AbstractFloat)" href="#KitBase.ib_sod-Union{Tuple{T}, Tuple{Any,T}} where T&lt;:(AbstractArray{var&quot;#s208&quot;,1} where var&quot;#s208&quot;&lt;:AbstractFloat)"><code>KitBase.ib_sod</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initialize Sod shock tube</p><ul><li>1d1f1v: <code>ib_sod(γ, u::T) where {T&lt;:AbstractArray{&lt;:AbstractFloat,1}}</code></li><li>1d1f3v: <code>ib_sod(γ, u::T, v::T, w::T) where {T&lt;:AbstractArray{&lt;:AbstractFloat,3}}</code></li><li>1d2f1v: <code>ib_sod(γ, u::T, K) where {T&lt;:AbstractArray{&lt;:AbstractFloat,1}}</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.init_fvm-Tuple{T} where T&lt;:AbstractSolverSet" href="#KitBase.init_fvm-Tuple{T} where T&lt;:AbstractSolverSet"><code>KitBase.init_fvm</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initialize finite volume method</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.initialize-Tuple{T} where T&lt;:AbstractString" href="#KitBase.initialize-Tuple{T} where T&lt;:AbstractString"><code>KitBase.initialize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initialize solver from input file</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.kernel_mode-Union{Tuple{R}, Tuple{I}, Tuple{I,R,R,R,R,R,R,I,I,I,R}} where R&lt;:Real where I&lt;:Int64" href="#KitBase.kernel_mode-Union{Tuple{R}, Tuple{I}, Tuple{I,R,R,R,R,R,R,I,I,I,R}} where R&lt;:Real where I&lt;:Int64"><code>KitBase.kernel_mode</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate collision kernel for fast spectral method</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.legendre_quadrature-Tuple{T} where T&lt;:Int64" href="#KitBase.legendre_quadrature-Tuple{T} where T&lt;:Int64"><code>KitBase.legendre_quadrature</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gauss-Legendre quadrature</p><p><code>legendre_quadrature(n::Int)</code></p><ul><li>@arg n : quadrature order (MUST be even)</li><li>@return points : quadrature points in 3D coordinate</li><li>@return weights : quadrature weights</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.lgwt-Tuple{Int64,Real,Real}" href="#KitBase.lgwt-Tuple{Int64,Real,Real}"><code>KitBase.lgwt</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gauss Legendre integral for fast spectral method</p><pre><code class="language-none">lgwt(N::Int, a::Real, b::Real)</code></pre><ul><li>@args: number of quadrature points N, integral range [a, b]</li><li>@args: quadrature points x &amp; weights w</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.linspace-Union{Tuple{T}, Tuple{Any,Any,T}} where T&lt;:Int64" href="#KitBase.linspace-Union{Tuple{T}, Tuple{Any,Any,T}} where T&lt;:Int64"><code>KitBase.linspace</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Python linspace function</p><pre><code class="language-none">linspace(start::Real, stop::Real, n::Int)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.local_frame-Union{Tuple{T}, Tuple{T,Any,Any}} where T&lt;:(AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Real)" href="#KitBase.local_frame-Union{Tuple{T}, Tuple{T,Any,Any}} where T&lt;:(AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Real)"><code>KitBase.local_frame</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transform global flow variables to local frame</p><ul><li>2D: <code>local_frame(w::AbstractArray{&lt;:Real,1}, cosa::Real, sina::Real)</code></li><li>3D: <code>local_frame(w::AbstractArray{&lt;:Real,1}, dirccos::AbstractArray{&lt;:Real,2})</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.mat_split-Tuple{T} where T&lt;:AbstractArray" href="#KitBase.mat_split-Tuple{T} where T&lt;:AbstractArray"><code>KitBase.mat_split</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Split matrix into row vectors</p><pre><code class="language-none">mat_split(m::AbstractArray)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.maxwellian-Union{Tuple{T}, Tuple{T,Any,Any,Any}} where T&lt;:(AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:AbstractFloat)" href="#KitBase.maxwellian-Union{Tuple{T}, Tuple{T,Any,Any,Any}} where T&lt;:(AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:AbstractFloat)"><code>KitBase.maxwellian</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Maxwellian in discrete form</p><ul><li>@args: particle velocity quadrature points</li><li>@args: density, velocity and inverse of temperature</li><li>@return: Maxwellian distribution function</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.mesh_area_2D-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}} where Y&lt;:(AbstractArray{var&quot;#s54&quot;,2} where var&quot;#s54&quot;&lt;:Int64) where X&lt;:(AbstractArray{var&quot;#s55&quot;,2} where var&quot;#s55&quot;&lt;:AbstractFloat)" href="#KitBase.mesh_area_2D-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}} where Y&lt;:(AbstractArray{var&quot;#s54&quot;,2} where var&quot;#s54&quot;&lt;:Int64) where X&lt;:(AbstractArray{var&quot;#s55&quot;,2} where var&quot;#s55&quot;&lt;:AbstractFloat)"><code>KitBase.mesh_area_2D</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute areas of 2D elements</p><p><code>mesh_area_2D(nodes::AbstractArray{&lt;:AbstractFloat,2}, cells::AbstractArray{&lt;:Int,2})</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.mesh_center_2D-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}} where Y&lt;:(AbstractArray{var&quot;#s54&quot;,2} where var&quot;#s54&quot;&lt;:Int64) where X&lt;:(AbstractArray{var&quot;#s55&quot;,2} where var&quot;#s55&quot;&lt;:AbstractFloat)" href="#KitBase.mesh_center_2D-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}} where Y&lt;:(AbstractArray{var&quot;#s54&quot;,2} where var&quot;#s54&quot;&lt;:Int64) where X&lt;:(AbstractArray{var&quot;#s55&quot;,2} where var&quot;#s55&quot;&lt;:AbstractFloat)"><code>KitBase.mesh_center_2D</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute central points of 2D elements</p><p><code>mesh_center_2D(nodes::AbstractArray{&lt;:AbstractFloat,2}, cells::AbstractArray{&lt;:Int,2})</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.mesh_connectivity_2D-Tuple{T} where T&lt;:(AbstractArray{var&quot;#s52&quot;,2} where var&quot;#s52&quot;&lt;:Int64)" href="#KitBase.mesh_connectivity_2D-Tuple{T} where T&lt;:(AbstractArray{var&quot;#s52&quot;,2} where var&quot;#s52&quot;&lt;:Int64)"><code>KitBase.mesh_connectivity_2D</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute connectivity of 2D unstructured mesh</p><p><code>mesh_connectivity_2D(cells::AbstractArray{&lt;:Int,2})</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.meshgrid-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:Real)" href="#KitBase.meshgrid-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:Real)"><code>KitBase.meshgrid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Equivalent structured mesh generator as matlab</p><ul><li>2D: <code>meshgrid(x::AbstractArray{&lt;:Real,1}, y::AbstractArray{&lt;:Real,1})</code></li><li>3D: <code>meshgrid(x::AbstractArray{&lt;:Real,1}, y::AbstractArray{&lt;:Real,1}, z::AbstractArray{&lt;:Real,1})</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.minmod-Union{Tuple{T}, Tuple{T,T}} where T" href="#KitBase.minmod-Union{Tuple{T}, Tuple{T,T}} where T"><code>KitBase.minmod</code></a> — <span class="docstring-category">Method</span></header><section><div><p>minmod limiter</p><pre><code class="language-none">minmod(sL::Real, sR::Real)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.mixture_conserve_prim-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:(AbstractArray{var&quot;#s57&quot;,2} where var&quot;#s57&quot;&lt;:Real)" href="#KitBase.mixture_conserve_prim-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:(AbstractArray{var&quot;#s57&quot;,2} where var&quot;#s57&quot;&lt;:Real)"><code>KitBase.mixture_conserve_prim</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transform multi-component conservative -&gt; primitive variables</p><pre><code class="language-none">mixture_conserve_prim(W::T, γ) where {T&lt;:AbstractArray{&lt;:Real,2}}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.mixture_gauss_moments-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:(AbstractArray{var&quot;#s52&quot;,2} where var&quot;#s52&quot;&lt;:Real)" href="#KitBase.mixture_gauss_moments-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:(AbstractArray{var&quot;#s52&quot;,2} where var&quot;#s52&quot;&lt;:Real)"><code>KitBase.mixture_gauss_moments</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate moments of Gaussian distribution in multi-component gas</p><pre><code class="language-none">mixture_gauss_moments(prim::T, inK) where {T&lt;:AbstractArray{&lt;:Real,2}}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.mixture_maxwellian-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}} where Y&lt;:(AbstractArray{var&quot;#s55&quot;,2} where var&quot;#s55&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s56&quot;,2} where var&quot;#s56&quot;&lt;:AbstractFloat)" href="#KitBase.mixture_maxwellian-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}} where Y&lt;:(AbstractArray{var&quot;#s55&quot;,2} where var&quot;#s55&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s56&quot;,2} where var&quot;#s56&quot;&lt;:AbstractFloat)"><code>KitBase.mixture_maxwellian</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Multi-component Maxwellian in discrete form</p><pre><code class="language-none">mixture_maxwellian(u::X, prim::Y) where {X&lt;:AbstractArray{&lt;:AbstractFloat,2},Y&lt;:AbstractArray{&lt;:Real,2}}

mixture_maxwellian(
    u::X,
    v::X,
    prim::Y,
) where {X&lt;:AbstractArray{&lt;:AbstractFloat,3},Y&lt;:AbstractArray{&lt;:Real,2}}

mixture_maxwellian(
    u::X,
    v::X,
    w::X,
    prim::Y,
) where {X&lt;:AbstractArray{&lt;:AbstractFloat,4},Y&lt;:AbstractArray{&lt;:Real,2}}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.mixture_moments_conserve-Union{Tuple{I}, Tuple{T}, Tuple{T,T,I,I}} where I&lt;:Int64 where T&lt;:(OffsetArrays.OffsetArray{var&quot;#s57&quot;,2,AA} where AA&lt;:AbstractArray{var&quot;#s57&quot;,2} where var&quot;#s57&quot;&lt;:AbstractFloat)" href="#KitBase.mixture_moments_conserve-Union{Tuple{I}, Tuple{T}, Tuple{T,T,I,I}} where I&lt;:Int64 where T&lt;:(OffsetArrays.OffsetArray{var&quot;#s57&quot;,2,AA} where AA&lt;:AbstractArray{var&quot;#s57&quot;,2} where var&quot;#s57&quot;&lt;:AbstractFloat)"><code>KitBase.mixture_moments_conserve</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate conservative moments of particle distribution in multi-component gas</p><pre><code class="language-none">mixture_moments_conserve(
    Mu::T,
    Mxi::T,
    alpha::I,
    delta::I,
) where {T&lt;:OffsetArray{&lt;:AbstractFloat,2},I&lt;:Int}

function mixture_moments_conserve(
    Mu::T,
    Mv::T,
    Mw::T,
    alpha::I,
    beta::I,
    delta::I,
) where {T&lt;:OffsetArray{&lt;:AbstractFloat,2},I&lt;:Int}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.mixture_moments_conserve_slope-Union{Tuple{I}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,I}} where I&lt;:Int64 where Y&lt;:(OffsetArrays.OffsetArray{var&quot;#s55&quot;,2,AA} where AA&lt;:AbstractArray{var&quot;#s55&quot;,2} where var&quot;#s55&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s56&quot;,2} where var&quot;#s56&quot;&lt;:Real)" href="#KitBase.mixture_moments_conserve_slope-Union{Tuple{I}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,I}} where I&lt;:Int64 where Y&lt;:(OffsetArrays.OffsetArray{var&quot;#s55&quot;,2,AA} where AA&lt;:AbstractArray{var&quot;#s55&quot;,2} where var&quot;#s55&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s56&quot;,2} where var&quot;#s56&quot;&lt;:Real)"><code>KitBase.mixture_moments_conserve_slope</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate slope-related conservative moments <code>a = a1 + u * a2 + 0.5 * u^2 * a3</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.mixture_pdf_slope-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Any}} where Y&lt;:(AbstractArray{var&quot;#s55&quot;,2} where var&quot;#s55&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s56&quot;,2} where var&quot;#s56&quot;&lt;:Real)" href="#KitBase.mixture_pdf_slope-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Any}} where Y&lt;:(AbstractArray{var&quot;#s55&quot;,2} where var&quot;#s55&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s56&quot;,2} where var&quot;#s56&quot;&lt;:Real)"><code>KitBase.mixture_pdf_slope</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate slope of multi-component particle distribution function, assuming <code>a = a1 + u * a2 + 0.5 * u^2 * a3</code></p><pre><code class="language-none">mixture_pdf_slope(prim::X, sw::Y, inK) where {X&lt;:AbstractArray{&lt;:Real,2},Y&lt;:AbstractArray{&lt;:Real,2}}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.mixture_prim_conserve-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:(AbstractArray{var&quot;#s57&quot;,2} where var&quot;#s57&quot;&lt;:Real)" href="#KitBase.mixture_prim_conserve-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:(AbstractArray{var&quot;#s57&quot;,2} where var&quot;#s57&quot;&lt;:Real)"><code>KitBase.mixture_prim_conserve</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transform multi-component primitive -&gt; conservative variables</p><pre><code class="language-none">mixture_prim_conserve(prim::T, γ) where {T&lt;:AbstractArray{&lt;:Real,2}}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.moments_conserve-Union{Tuple{I}, Tuple{T}, Tuple{T,I}} where I&lt;:Int64 where T&lt;:(OffsetArrays.OffsetArray{var&quot;#s58&quot;,1,AA} where AA&lt;:AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:AbstractFloat)" href="#KitBase.moments_conserve-Union{Tuple{I}, Tuple{T}, Tuple{T,I}} where I&lt;:Int64 where T&lt;:(OffsetArrays.OffsetArray{var&quot;#s58&quot;,1,AA} where AA&lt;:AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:AbstractFloat)"><code>KitBase.moments_conserve</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate conservative moments of particle distribution</p><p><code>moments_conserve(Mu::OffsetArray{&lt;:AbstractFloat,1}, alpha::Int)</code></p><p><code>moments_conserve(Mu::OffsetArray{&lt;:Real,1}, Mxi::OffsetArray{&lt;:Real,1},     alpha::Int, delta::Int)</code></p><p><code>moments_conserve(Mu::OffsetArray{&lt;:Real,1}, Mv::OffsetArray{&lt;:Real,1},     Mw::OffsetArray{&lt;:Real,1}, alpha::Int, beta::Int, delta::Int)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.moments_conserve_slope-Union{Tuple{I}, Tuple{T}, Tuple{Any,T,I}} where I&lt;:Int64 where T&lt;:(OffsetArrays.OffsetArray{var&quot;#s58&quot;,1,AA} where AA&lt;:AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Real)" href="#KitBase.moments_conserve_slope-Union{Tuple{I}, Tuple{T}, Tuple{Any,T,I}} where I&lt;:Int64 where T&lt;:(OffsetArrays.OffsetArray{var&quot;#s58&quot;,1,AA} where AA&lt;:AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Real)"><code>KitBase.moments_conserve_slope</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate slope-related conservative moments <code>a = a1 + u * a2 + 0.5 * u^2 * a3</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.newton_cotes-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Int64" href="#KitBase.newton_cotes-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Int64"><code>KitBase.newton_cotes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Newton-Cotes rule</p><pre><code class="language-none">newton_cotes(idx::T, num::T) where {T&lt;:Int}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.octa_quadrature-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:Int64" href="#KitBase.octa_quadrature-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:Int64"><code>KitBase.octa_quadrature</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Octaeder quadrature</p><p><code>octa_quadrature(n::Int, slerpflag = true::Bool)</code></p><ul><li>@arg n : quadrature order</li><li>@arg slerpflag : flag of spherical linear interpolation</li><li>@return points</li><li>@return triangulation</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.pdf_slope-Tuple{Any,Any}" href="#KitBase.pdf_slope-Tuple{Any,Any}"><code>KitBase.pdf_slope</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate slope of particle distribution function, assuming a = a1 + u * a2 + 0.5 * u^2 * a3</p><pre><code class="language-none">pdf_slope(u, Δ)

pdf_slope(prim::A, sw::B, inK) where {A&lt;:AbstractArray{&lt;:Real,1},B&lt;:AbstractArray{&lt;:Real,1}}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.plot_line-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}} where Y&lt;:(AbstractArray{var&quot;#s53&quot;,1} where var&quot;#s53&quot;&lt;:AbstractControlVolume) where X&lt;:AbstractSolverSet" href="#KitBase.plot_line-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}} where Y&lt;:(AbstractArray{var&quot;#s53&quot;,1} where var&quot;#s53&quot;&lt;:AbstractControlVolume) where X&lt;:AbstractSolverSet"><code>KitBase.plot_line</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Plot 1D profile</p><pre><code class="language-none">plot_line(KS, ctr; backend)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.prim_conserve-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:(AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Real)" href="#KitBase.prim_conserve-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:(AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Real)"><code>KitBase.prim_conserve</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transform primitive -&gt; conservative variables</p><pre><code class="language-none">prim_conserve(prim::T, γ) where {T&lt;:AbstractArray{&lt;:Real,1}}

prim_conserve(ρ, U, λ, γ)

prim_conserve(ρ, U, V, λ, γ)

prim_conserve(ρ, U, V, W, λ, γ)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.quadrature_weights-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}} where Y&lt;:AbstractArray{Int64,2} where X&lt;:(AbstractArray{var&quot;#s56&quot;,2} where var&quot;#s56&quot;&lt;:Real)" href="#KitBase.quadrature_weights-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}} where Y&lt;:AbstractArray{Int64,2} where X&lt;:(AbstractArray{var&quot;#s56&quot;,2} where var&quot;#s56&quot;&lt;:Real)"><code>KitBase.quadrature_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create quadrature weights from points and triangulation</p><p><code>create_weights(n::Int, xyz::AbstractArray{&lt;:Real,2}, triangles::AbstractArray{Int,2})</code></p><ul><li>@arg xyz : quadrature points</li><li>@arg triangles : triangulation</li><li>@return weights : quadrature weights</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.read_dict-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:AbstractString" href="#KitBase.read_dict-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:AbstractString"><code>KitBase.read_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read text into dictionary</p><pre><code class="language-none">read_dict(filename::String, allowed)
read_dict(filename::String)</code></pre><ul><li>@args filename: configuration text file</li><li>@args allowed: keywords</li><li>@return vars: dictionary with values of variables</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.read_mesh-Tuple{T} where T&lt;:AbstractString" href="#KitBase.read_mesh-Tuple{T} where T&lt;:AbstractString"><code>KitBase.read_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read mesh file</p><p><code>read_mesh(file)</code></p><ul><li>@return nodes : are saved with 3D coordinates (z=0 for 2D case)</li><li>@return cells : node ids inside cells</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.reconstruct!-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}} where Y&lt;:(AbstractArray{var&quot;#s204&quot;,1} where var&quot;#s204&quot;&lt;:AbstractControlVolume) where X&lt;:AbstractSolverSet" href="#KitBase.reconstruct!-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}} where Y&lt;:(AbstractArray{var&quot;#s204&quot;,1} where var&quot;#s204&quot;&lt;:AbstractControlVolume) where X&lt;:AbstractSolverSet"><code>KitBase.reconstruct!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reconstructor</p><ul><li>1D solver: <code>reconstruct!(KS::SolverSet, ctr::AbstractArray{&lt;:AbstractControlVolume1D,1})</code></li><li>2D solver: <code>reconstruct!(KS::SolverSet, ctr::AbstractArray{ControlVolume2D2F,2})</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.reconstruct2!-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,Any}} where Y&lt;:(AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s57&quot;,1} where var&quot;#s57&quot;&lt;:AbstractFloat)" href="#KitBase.reconstruct2!-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,Any}} where Y&lt;:(AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s57&quot;,1} where var&quot;#s57&quot;&lt;:AbstractFloat)"><code>KitBase.reconstruct2!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Two-cell reconstruction</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.reconstruct2-Union{Tuple{Y}, Tuple{X}, Tuple{X,X,Y}} where Y where X" href="#KitBase.reconstruct2-Union{Tuple{Y}, Tuple{X}, Tuple{X,X,Y}} where Y where X"><code>KitBase.reconstruct2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Two-cell reconstruction</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.reconstruct3!-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,Y,Any,Any}, Tuple{X,Y,Y,Y,Any,Any,Any}} where Y&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;&lt;:AbstractFloat)" href="#KitBase.reconstruct3!-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,Y,Any,Any}, Tuple{X,Y,Y,Y,Any,Any,Any}} where Y&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;&lt;:AbstractFloat)"><code>KitBase.reconstruct3!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Three-cell reconstruction</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.reconstruct3-Union{Tuple{T}, NTuple{5,T}, Tuple{T,T,T,T,T,Any}} where T" href="#KitBase.reconstruct3-Union{Tuple{T}, NTuple{5,T}, Tuple{T,T,T,T,T,Any}} where T"><code>KitBase.reconstruct3</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Three-cell reconstruction</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.reduce_distribution-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}, Tuple{X,Y,Any}} where Y&lt;:(AbstractArray{var&quot;#s52&quot;,1} where var&quot;#s52&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s53&quot;,2} where var&quot;#s53&quot;&lt;:AbstractFloat)" href="#KitBase.reduce_distribution-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}, Tuple{X,Y,Any}} where Y&lt;:(AbstractArray{var&quot;#s52&quot;,1} where var&quot;#s52&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s53&quot;,2} where var&quot;#s53&quot;&lt;:AbstractFloat)"><code>KitBase.reduce_distribution</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reduced distribution function</p><ul><li>@arg : particle distribution function with full velocity space</li><li>@arg : quadrature weights with reduced velocity setting (v &amp; w by default)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.ref_vhs_vis-Tuple{Any,Any,Any}" href="#KitBase.ref_vhs_vis-Tuple{Any,Any,Any}"><code>KitBase.ref_vhs_vis</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate reference viscosity</p><ul><li>variable hard sphere (VHS) model</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.set_ib-Union{Tuple{T}, Tuple{T,Any,Any}, Tuple{T,Any,Any,Any}, Tuple{T,Any,Any,Any,Any}, Tuple{T,Any,Any,Any,Any,Any}} where T&lt;:AbstractSetup" href="#KitBase.set_ib-Union{Tuple{T}, Tuple{T,Any,Any}, Tuple{T,Any,Any,Any}, Tuple{T,Any,Any,Any,Any}, Tuple{T,Any,Any,Any,Any,Any}} where T&lt;:AbstractSetup"><code>KitBase.set_ib</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate AbstractIB</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.shakhov-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Any,Z,Any}} where Z&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:Real) where Y&lt;:(AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;&lt;:AbstractFloat)" href="#KitBase.shakhov-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Any,Z,Any}} where Z&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:Real) where Y&lt;:(AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;&lt;:AbstractFloat)"><code>KitBase.shakhov</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shakhov non-equilibrium part</p><ul><li>@arg: particle velocity quadrature points</li><li>@arg: discrete Maxwellian</li><li>@arg: primitive variables, Prandtl number, heat flux, inner degree of freedom</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.shift_pdf!-Union{Tuple{T}, Tuple{T,Any,Any,Any}} where T&lt;:(AbstractArray{var&quot;#s52&quot;,1} where var&quot;#s52&quot;&lt;:AbstractFloat)" href="#KitBase.shift_pdf!-Union{Tuple{T}, Tuple{T,Any,Any,Any}} where T&lt;:(AbstractArray{var&quot;#s52&quot;,1} where var&quot;#s52&quot;&lt;:AbstractFloat)"><code>KitBase.shift_pdf!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shift distribution function by external force</p><pre><code class="language-none">shift_pdf!(
    f::T,
    a,
    du,
    dt,
) where {T&lt;:AbstractArray{&lt;:AbstractFloat,1}}

shift_pdf!(
    f::X,
    a::Y,
    du::Z,
    dt,
) where {X&lt;:AbstractArray{&lt;:AbstractFloat,2},Y&lt;:AbstractArray{&lt;:Real,1},Z&lt;:AbstractArray{&lt;:AbstractFloat,1}}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.slerp-Union{Tuple{I}, Tuple{T}, Tuple{T,T,I}} where I&lt;:Int64 where T&lt;:(AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Real)" href="#KitBase.slerp-Union{Tuple{I}, Tuple{T}, Tuple{T,T,I}} where I&lt;:Int64 where T&lt;:(AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Real)"><code>KitBase.slerp</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Spherical linear interpolation</p><pre><code class="language-none">slerp(pt1::T, pt2::T, n::I) where {T&lt;:AbstractArray{&lt;:Real,1},I&lt;:Int}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.solve!-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Z,Any}} where Z&lt;:(AbstractArray{var&quot;#s205&quot;,1} where var&quot;#s205&quot;&lt;:AbstractInterface1D) where Y&lt;:(AbstractArray{var&quot;#s206&quot;,1} where var&quot;#s206&quot;&lt;:AbstractControlVolume) where X&lt;:AbstractSolverSet" href="#KitBase.solve!-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Z,Any}} where Z&lt;:(AbstractArray{var&quot;#s205&quot;,1} where var&quot;#s205&quot;&lt;:AbstractInterface1D) where Y&lt;:(AbstractArray{var&quot;#s206&quot;,1} where var&quot;#s206&quot;&lt;:AbstractControlVolume) where X&lt;:AbstractSolverSet"><code>KitBase.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Solution algorithm</p><ul><li><p>1D solver: <code>solve!(KS::SolverSet, ctr::AbstractArray{&lt;:AbstractControlVolume1D,1},   face::Array{&lt;:AbstractInterface1D,1}, simTime::Float64)</code></p></li><li><p>@return: ending time</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.sound_speed-Tuple{Real,Real}" href="#KitBase.sound_speed-Tuple{Real,Real}"><code>KitBase.sound_speed</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate speed of sound</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.step!-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,X,Any,Any,Any,Any}} where Y&lt;:(AbstractArray{var&quot;#s762&quot;,1} where var&quot;#s762&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s763&quot;,1} where var&quot;#s763&quot;&lt;:AbstractFloat)" href="#KitBase.step!-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Y,X,Any,Any,Any,Any}} where Y&lt;:(AbstractArray{var&quot;#s762&quot;,1} where var&quot;#s762&quot;&lt;:AbstractFloat) where X&lt;:(AbstractArray{var&quot;#s763&quot;,1} where var&quot;#s763&quot;&lt;:AbstractFloat)"><code>KitBase.step!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Update flow variables with finite volume formulation</p><p>wrapper: <code>step!(ks, faceL, cell, faceR, dt, res, avg, collision=:bgk, isMHD=:true)</code></p><p>1d0f: <code>step!(fwL, w, prim, fwR, γ, dx, RES, AVG)</code></p><p>1d1f1v: <code>step!(fwL, ffL, w, prim, f, fwR, ffR, u, weights, γ, μᵣ, ω, Pr, dx, dt, RES, AVG, collision=:bgk)</code></p><p>1d1f3v: <code>step!(fwL, ffL, w, prim, f, fwR, ffR, uVelo, vVelo, wVelo, weights, γ, μᵣ, ω, Pr, dx, dt, RES, AVG, collision=:bgk)</code></p><p>1d2f1v: <code>step!(fwL, fhL, fbL, w, prim, h, b, fwR, fhR, fbR, u, weights, K, γ, μᵣ, ω, Pr, dx, dt, RES, AVG, collision=:bgk)</code></p><p>1d2f1v2s: <code>step!(fwL, fhL, fbL, w, prim, h, b, fwR, fhR, fbR, u, weights, K, γ, mi, ni, me, ne, Kn, Pr, dx, dt, RES, AVG, collision=:bgk)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.stress-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Z,Z}} where Z&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:AbstractFloat) where Y&lt;:(AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;&lt;:AbstractFloat)" href="#KitBase.stress-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Z,Z}} where Z&lt;:(AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:AbstractFloat) where Y&lt;:(AbstractArray{var&quot;#s55&quot;,1} where var&quot;#s55&quot;&lt;:Real) where X&lt;:(AbstractArray{var&quot;#s56&quot;,1} where var&quot;#s56&quot;&lt;:AbstractFloat)"><code>KitBase.stress</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate stress tensor from particle distribution function</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.superbee-Union{Tuple{T}, Tuple{T,T}} where T" href="#KitBase.superbee-Union{Tuple{T}, Tuple{T,T}} where T"><code>KitBase.superbee</code></a> — <span class="docstring-category">Method</span></header><section><div><p>superbee limiter</p><pre><code class="language-none">superbee(sL::Real, sR::Real)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.timestep-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Any}} where Y&lt;:(AbstractArray{var&quot;#s204&quot;,1} where var&quot;#s204&quot;&lt;:AbstractControlVolume) where X&lt;:AbstractSolverSet" href="#KitBase.timestep-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y,Any}} where Y&lt;:(AbstractArray{var&quot;#s204&quot;,1} where var&quot;#s204&quot;&lt;:AbstractControlVolume) where X&lt;:AbstractSolverSet"><code>KitBase.timestep</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Timestep calculator</p><ul><li><p>1D solver: <code>timestep(KS::SolverSet, ctr::AbstractArray{&lt;:AbstractControlVolume1D,1},   simTime::Real)</code></p></li><li><p>@return: Δt</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.uniform_mesh-Union{Tuple{T}, Tuple{Any,T,Any}} where T&lt;:Int64" href="#KitBase.uniform_mesh-Union{Tuple{T}, Tuple{Any,T,Any}} where T&lt;:Int64"><code>KitBase.uniform_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate uniform mesh</p><p><code>uniform_mesh(x0::Real, xnum::Int, dx::Real)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.unique-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}} where Y&lt;:(AbstractArray{var&quot;#s49&quot;,2} where var&quot;#s49&quot;&lt;:Int64) where X&lt;:(AbstractArray{var&quot;#s50&quot;,2} where var&quot;#s50&quot;&lt;:AbstractFloat)" href="#KitBase.unique-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}} where Y&lt;:(AbstractArray{var&quot;#s49&quot;,2} where var&quot;#s49&quot;&lt;:Int64) where X&lt;:(AbstractArray{var&quot;#s50&quot;,2} where var&quot;#s50&quot;&lt;:AbstractFloat)"><code>KitBase.unique</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Cleaner for all duplicate (non unique) entries of quadrature points and triangles</p><pre><code class="language-none">unique(Points::X, Triangles::Y) where {X&lt;:AbstractArray{&lt;:AbstractFloat,2},Y&lt;:AbstractArray{&lt;:Int,2}}</code></pre><ul><li>@arg Points : quadrature points</li><li>@arg Triangles : triangulation</li><li>@return xyz &amp; triangulation : new quadrature points and triangulation</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.unstruct_diff-Tuple{AbstractArray{var&quot;#s51&quot;,1} where var&quot;#s51&quot;,AbstractArray{var&quot;#s50&quot;,1} where var&quot;#s50&quot;,Int64}" href="#KitBase.unstruct_diff-Tuple{AbstractArray{var&quot;#s51&quot;,1} where var&quot;#s51&quot;,AbstractArray{var&quot;#s50&quot;,1} where var&quot;#s50&quot;,Int64}"><code>KitBase.unstruct_diff</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Finite difference for pseudo-unstructured mesh</p><pre><code class="language-none">unstruct_diff(
    u::AbstractArray{&lt;:Any,1},
    x::AbstractArray{&lt;:Any,1},
    nx::Int;
    mode = :central::Symbol,
)

unstruct_diff(u::Function, x::AbstractArray{&lt;:Any,2}, nx::Int, dim::Int; mode = :central::Symbol)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.update!-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Z,Any,Any}} where Z&lt;:AbstractArray{Interface1D1F,1} where Y&lt;:AbstractArray{ControlVolume1D1F,1} where X&lt;:AbstractSolverSet" href="#KitBase.update!-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X,Y,Z,Any,Any}} where Z&lt;:AbstractArray{Interface1D1F,1} where Y&lt;:AbstractArray{ControlVolume1D1F,1} where X&lt;:AbstractSolverSet"><code>KitBase.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Update flow variables</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.upwind_diff!-Tuple{AbstractArray{var&quot;#s47&quot;,1} where var&quot;#s47&quot;,AbstractArray{var&quot;#s46&quot;,1} where var&quot;#s46&quot;,AbstractArray{var&quot;#s45&quot;,1} where var&quot;#s45&quot;}" href="#KitBase.upwind_diff!-Tuple{AbstractArray{var&quot;#s47&quot;,1} where var&quot;#s47&quot;,AbstractArray{var&quot;#s46&quot;,1} where var&quot;#s46&quot;,AbstractArray{var&quot;#s45&quot;,1} where var&quot;#s45&quot;}"><code>KitBase.upwind_diff!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Upwind difference</p><pre><code class="language-none">upwind_diff!(
    dy::AbstractArray{&lt;:Any,1},
    y::AbstractArray{&lt;:Any,1},
    x::AbstractArray{&lt;:Any,1};
    stream = :right::Symbol,
)

upwind_diff!(
    dy::AbstractArray{&lt;:Any,1},
    y::AbstractArray{&lt;:Any,1},
    dx::Any;
    stream = :right::Symbol,
)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.upwind_diff-Tuple{AbstractArray{var&quot;#s50&quot;,1} where var&quot;#s50&quot;,AbstractArray{var&quot;#s49&quot;,1} where var&quot;#s49&quot;}" href="#KitBase.upwind_diff-Tuple{AbstractArray{var&quot;#s50&quot;,1} where var&quot;#s50&quot;,AbstractArray{var&quot;#s49&quot;,1} where var&quot;#s49&quot;}"><code>KitBase.upwind_diff</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Upwind difference</p><pre><code class="language-none">upwind_diff(
    y::AbstractArray{&lt;:Any,1},
    x::AbstractArray{&lt;:Any,1};
    stream = :right::Symbol,
)

upwind_diff(y::AbstractArray{&lt;:Any,1}, dx::Any; stream = :right::Symbol)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.vanalbaba-Union{Tuple{T}, Tuple{T,T}} where T" href="#KitBase.vanalbaba-Union{Tuple{T}, Tuple{T,T}} where T"><code>KitBase.vanalbaba</code></a> — <span class="docstring-category">Method</span></header><section><div><p>van Albaba limiter</p><pre><code class="language-none">vanalbaba(sL::Real, sR::Real)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.vanleer-Union{Tuple{T}, Tuple{T,T}} where T" href="#KitBase.vanleer-Union{Tuple{T}, Tuple{T,T}} where T"><code>KitBase.vanleer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>van Leer limiter</p><pre><code class="language-none">vanleer(sL::Real, sR::Real)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.vhs_collision_time-Union{Tuple{T}, Tuple{T,Any,Any}} where T&lt;:(AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Real)" href="#KitBase.vhs_collision_time-Union{Tuple{T}, Tuple{T,Any,Any}} where T&lt;:(AbstractArray{var&quot;#s58&quot;,1} where var&quot;#s58&quot;&lt;:Real)"><code>KitBase.vhs_collision_time</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate collision time</p><ul><li>variable hard sphere (VHS) model</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.weno5-Union{Tuple{T}, NTuple{5,T}} where T" href="#KitBase.weno5-Union{Tuple{T}, NTuple{5,T}} where T"><code>KitBase.weno5</code></a> — <span class="docstring-category">Method</span></header><section><div><p>5th-order WENO-JS interpolation</p><pre><code class="language-none">weno5(wL2::T, wL1::T, wN::T, wR1::T, wR2::T) where {T}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.write_jld-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}, Tuple{X,Y,Any}} where Y&lt;:(AbstractArray{var&quot;#s57&quot;,1} where var&quot;#s57&quot;&lt;:AbstractControlVolume) where X&lt;:AbstractSolverSet" href="#KitBase.write_jld-Union{Tuple{Y}, Tuple{X}, Tuple{X,Y}, Tuple{X,Y,Any}} where Y&lt;:(AbstractArray{var&quot;#s57&quot;,1} where var&quot;#s57&quot;&lt;:AbstractControlVolume) where X&lt;:AbstractSolverSet"><code>KitBase.write_jld</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Write data into JLD2</p><pre><code class="language-none">write_jld(KS, ctr, t)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.ControlVolume1D" href="#KitBase.ControlVolume1D"><code>KitBase.ControlVolume1D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>1D control volume with no distribution function</p><pre><code class="language-none">ControlVolume1D(X::Real, DX::Real, W::AbstractArray, PRIM::AbstractArray)</code></pre><ul><li>@vars: x, dx, w, prim, sw</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.ControlVolume1D1F" href="#KitBase.ControlVolume1D1F"><code>KitBase.ControlVolume1D1F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>1D control volume with 1 distribution function</p><pre><code class="language-none">ControlVolume1D1F(X::Real, DX::Real, W::AbstractArray, PRIM::AbstractArray, F::AbstractArray)</code></pre><ul><li>@vars: x, dx, w, prim, sw, f, sf</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.ControlVolume1D2F" href="#KitBase.ControlVolume1D2F"><code>KitBase.ControlVolume1D2F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>1D control volume with 2 distribution functions</p><pre><code class="language-none">ControlVolume1D2F(X::Real, DX::Real, W::AbstractArray, PRIM::AbstractArray, H::AbstractArray, B::AbstractArray)</code></pre><ul><li>@vars: x, dx, w, prim, sw, h, b, sh, sb</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.ControlVolume1D3F" href="#KitBase.ControlVolume1D3F"><code>KitBase.ControlVolume1D3F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>1D control volume with 3 distribution functions</p><pre><code class="language-none">ControlVolume1D3F(X, DX, W, PRIM, H0, H1, H2, E0, B0, L)</code></pre><ul><li>@vars: x, dx, w, prim, sw, h0, h1, h2, sh0, sh1, sh2, E, B, ϕ, ψ, lorenz</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.ControlVolume1D4F" href="#KitBase.ControlVolume1D4F"><code>KitBase.ControlVolume1D4F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>1D control volume with 4 distribution functions</p><pre><code class="language-none">ControlVolume1D4F(X, DX, W, PRIM, H0, H1, H2, H3, E0, B0, L)</code></pre><ul><li>@vars: x, dx, w, prim, sw, h0, h1, h2, h3, sh0, sh1, sh2, sh3, E, B, ϕ, ψ, lorenz</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.ControlVolume2D" href="#KitBase.ControlVolume2D"><code>KitBase.ControlVolume2D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>2D control volume with no distribution function</p><pre><code class="language-none">ControlVolume2D(X::Real, DX::Real, Y::Real, DY::Real, W::AbstractArray, PRIM::AbstractArray)</code></pre><ul><li>@vars: x, y, dx, dy, w, prim, sw</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.ControlVolume2D1F" href="#KitBase.ControlVolume2D1F"><code>KitBase.ControlVolume2D1F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>2D control volume with 1 distribution function</p><pre><code class="language-none">ControlVolume2D1F(X::Real, DX::Real, Y::Real, DY::Real, W::AbstractArray, PRIM::AbstractArray, F::AbstractArray)</code></pre><ul><li>@vars: x, y, dx, dy, w, prim, sw, f, sf</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.ControlVolume2D2F" href="#KitBase.ControlVolume2D2F"><code>KitBase.ControlVolume2D2F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>2D control volume with 2 distribution functions</p><pre><code class="language-none">ControlVolume2D2F(X::Real, DX::Real, Y::Real, DY::Real, W::AbstractArray, PRIM::AbstractArray, H::AbstractArray, B::AbstractArray)</code></pre><ul><li>@vars: x, y, dx, dy, w, prim, sw, h, b, sh, sb</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.ControlVolume2D3F" href="#KitBase.ControlVolume2D3F"><code>KitBase.ControlVolume2D3F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>2D control volume with 3 distribution functions</p><pre><code class="language-none">ControlVolume2D3F(X, DX, Y, DY, W, PRIM, H0, H1, H2, E0, B0, L)</code></pre><ul><li>@vars: x, y, dx, dy, w, prim, sw, h0, h1, h2, sh0, sh1, sh2, E, B, ϕ, ψ, lorenz</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.Gas" href="#KitBase.Gas"><code>KitBase.Gas</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Gas property</p><pre><code class="language-none">@consts: Kn, Ma, Pr, K, γ, ω, αᵣ, ωᵣ, μᵣ</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.IB" href="#KitBase.IB"><code>KitBase.IB</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Initial &amp; boundary condition with no distribution function</p><pre><code class="language-none">@consts: wL, primL, bcL, wR, primR, bcR, bcU, bcD</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.IB1F" href="#KitBase.IB1F"><code>KitBase.IB1F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Initial &amp; boundary condition with 1 distribution function</p><pre><code class="language-none">@consts: wL, primL, fL, bcL, wR, primR, fR, bcR, bcU, bcD</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.IB2F" href="#KitBase.IB2F"><code>KitBase.IB2F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Initial &amp; boundary condition with 2 distribution functions</p><pre><code class="language-none">@consts: wL, primL, hL, bL, bcL, wR, primR, hR, bR, bcR, bcU, bcD</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.IB3F" href="#KitBase.IB3F"><code>KitBase.IB3F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Initial &amp; boundary condition with 3 distribution functions</p><pre><code class="language-none">@consts: wL, primL, h0L, h1L, h2L, bcL, EL, BL, lorenzL, wR, primR, h0R, h1R, h2R, bcR, ER, BR, lorenzR, bcU, bcD</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.IB4F" href="#KitBase.IB4F"><code>KitBase.IB4F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Initial &amp; boundary condition with 4 distribution functions</p><pre><code class="language-none">@consts: wL, primL, h0L, h1L, h2L, h3L, bcL, EL, BL, lorenzL, wR, primR, h0R, h1R, h2R, h3R, bcR, ER, BR, lorenzR, bcU, bcD</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.Interface1D" href="#KitBase.Interface1D"><code>KitBase.Interface1D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>1D cell interface with no distribution function</p><pre><code class="language-none">@vars: fw</code></pre><p><code>Interface1D(w::AbstractArray)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.Interface1D1F" href="#KitBase.Interface1D1F"><code>KitBase.Interface1D1F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>1D cell interface with 1 distribution function</p><pre><code class="language-none">@vars: fw, ff</code></pre><p><code>Interface1D1F(w::AbstractArray, f::AbstractArray)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.Interface1D2F" href="#KitBase.Interface1D2F"><code>KitBase.Interface1D2F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>1D cell interface with 2 distribution functions</p><pre><code class="language-none">@vars: fw, fh, fb</code></pre><p><code>Interface1D2F(w::AbstractArray, f::AbstractArray)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.Interface1D3F" href="#KitBase.Interface1D3F"><code>KitBase.Interface1D3F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>1D cell interface with 3 distribution functions</p><pre><code class="language-none">@vars: fw, fh0, fh1, fh2, femL, femR,</code></pre><ul><li>deterministic: <code>Interface1D3F(w::AbstractArray, f::AbstractArray, E::AbstractArray{&lt;:Real,1})</code></li><li>stochastic: <code>Interface1D3F(w::AbstractArray, f::AbstractArray, E::AbstractArray{&lt;:Real,2})</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.Interface1D4F" href="#KitBase.Interface1D4F"><code>KitBase.Interface1D4F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>1D cell interface with 4 distribution functions</p><pre><code class="language-none">@vars: fw, fh0, fh1, fh2, fh3, femL, femR,</code></pre><ul><li>deterministic: <code>Interface1D4F(w::AbstractArray, f::AbstractArray, E::AbstractArray{&lt;:Real,1})</code></li><li>stochastic: <code>Interface1D4F(w::AbstractArray, f::AbstractArray, E::AbstractArray{&lt;:Real,2})</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.Interface2D" href="#KitBase.Interface2D"><code>KitBase.Interface2D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>2D cell interface with no distribution function</p><pre><code class="language-none">@vars: len, n, fw</code></pre><p><code>Interface2D(L::Real, C::Real, S::Real, w::AbstractArray)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.Interface2D1F" href="#KitBase.Interface2D1F"><code>KitBase.Interface2D1F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>2D cell interface with 1 distribution function</p><pre><code class="language-none">@vars: len, n, fw, ff</code></pre><p><code>Interface2D1F(L::Real, C::Real, S::Real, w::AbstractArray, f::AbstractArray)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.Interface2D2F" href="#KitBase.Interface2D2F"><code>KitBase.Interface2D2F</code></a> — <span class="docstring-category">Type</span></header><section><div><p>2D cell interface with 2 distribution functions</p><pre><code class="language-none">@vars: len, n, fw, fh, fb</code></pre><p><code>Interface2D2F(L::Real, C::Real, S::Real, w::AbstractArray, f::AbstractArray)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.MVSpace1D" href="#KitBase.MVSpace1D"><code>KitBase.MVSpace1D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>1D multi-component velocity space</p><ul><li>@consts: u0, u1, nu, u, du, weights</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.MVSpace2D" href="#KitBase.MVSpace2D"><code>KitBase.MVSpace2D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>2D multi-component velocity space</p><ul><li>@consts: u0, u1, nu, v0, v1, nv, u, v, du, dv, weights</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.MVSpace3D" href="#KitBase.MVSpace3D"><code>KitBase.MVSpace3D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>3D multi-component velocity space</p><ul><li>@consts: u0, u1, nu, v0, v1, nv, w0, w1, nw, u, v, w, du, dv, dw, weights</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.Mixture" href="#KitBase.Mixture"><code>KitBase.Mixture</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multi-component gas property</p><pre><code class="language-none">@consts: Kn, Ma, Pr, K, γ, mi, ni, me, ne</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.PSpace1D" href="#KitBase.PSpace1D"><code>KitBase.PSpace1D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>1D physical space with structured mesh</p><pre><code class="language-none">@consts: x0, x1, nx, x, dx</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.PSpace2D" href="#KitBase.PSpace2D"><code>KitBase.PSpace2D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>2D Physical space with structured mesh</p><pre><code class="language-none">@consts: x0, x1, nx, y0, y1, ny, x, y, dx, dy</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.Plasma1D" href="#KitBase.Plasma1D"><code>KitBase.Plasma1D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>1D plasma property</p><pre><code class="language-none">@consts: Kn, Ma, Pr, K, γ, mi, ni, me, ne, lD, rL, sol, χ, ν, Ap, An, D</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.Plasma2D" href="#KitBase.Plasma2D"><code>KitBase.Plasma2D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>2D plasma property</p><pre><code class="language-none">@consts: Kn, Ma, Pr, K, γ, mi, ni, me, ne, lD, rL, sol, χ, ν, A1p, A1n, A2p, A2n, D1, D2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.Setup" href="#KitBase.Setup"><code>KitBase.Setup</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Computational setup</p><pre><code class="language-none">@consts: case, space, flux, collision, nSpecies, interpOrder, limiter, cfl, maxTime</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.SolverSet" href="#KitBase.SolverSet"><code>KitBase.SolverSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure of solver setup</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.UnstructMesh" href="#KitBase.UnstructMesh"><code>KitBase.UnstructMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Physical space with unstructured mesh</p><pre><code class="language-none">@consts: nodes, cells</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.VSpace1D" href="#KitBase.VSpace1D"><code>KitBase.VSpace1D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>1D velocity space</p><ul><li>@consts: u0, u1, nu, u, du, weights</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.VSpace2D" href="#KitBase.VSpace2D"><code>KitBase.VSpace2D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>2D velocity space</p><ul><li>@consts: u0, u1, nu, v0, v1, nv, u, v, du, dv, weights</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="KitBase.VSpace3D" href="#KitBase.VSpace3D"><code>KitBase.VSpace3D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>3D velocity space</p><ul><li>@consts: u0, u1, nu, v0, v1, nv, w0, w1, nw, u, v, w, du, dv, dw, weights</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../install/">« Installation</a><a class="docs-footer-nextpage" href="../algorithm/">Algorithm »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 9 December 2020 23:04">Wednesday 9 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
